
FRTOS.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00005482  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000006  00800060  00005482  00005516  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          0000064a  00800066  00800066  0000551c  2**0
                  ALLOC
  3 .stab         00008784  00000000  00000000  0000551c  2**2
                  CONTENTS, READONLY, DEBUGGING
  4 .stabstr      00004a39  00000000  00000000  0000dca0  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 2a 00 	jmp	0x54	; 0x54 <__ctors_end>
       4:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
       8:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
       c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      10:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      14:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      18:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      1c:	0c 94 4e 0b 	jmp	0x169c	; 0x169c <__vector_7>
      20:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      24:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      28:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      2c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      30:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      34:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      38:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      3c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      40:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      44:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      48:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      4c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      50:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>

00000054 <__ctors_end>:
      54:	11 24       	eor	r1, r1
      56:	1f be       	out	0x3f, r1	; 63
      58:	cf e5       	ldi	r28, 0x5F	; 95
      5a:	d8 e0       	ldi	r29, 0x08	; 8
      5c:	de bf       	out	0x3e, r29	; 62
      5e:	cd bf       	out	0x3d, r28	; 61

00000060 <__do_copy_data>:
      60:	10 e0       	ldi	r17, 0x00	; 0
      62:	a0 e6       	ldi	r26, 0x60	; 96
      64:	b0 e0       	ldi	r27, 0x00	; 0
      66:	e2 e8       	ldi	r30, 0x82	; 130
      68:	f4 e5       	ldi	r31, 0x54	; 84
      6a:	02 c0       	rjmp	.+4      	; 0x70 <.do_copy_data_start>

0000006c <.do_copy_data_loop>:
      6c:	05 90       	lpm	r0, Z+
      6e:	0d 92       	st	X+, r0

00000070 <.do_copy_data_start>:
      70:	a6 36       	cpi	r26, 0x66	; 102
      72:	b1 07       	cpc	r27, r17
      74:	d9 f7       	brne	.-10     	; 0x6c <.do_copy_data_loop>

00000076 <__do_clear_bss>:
      76:	16 e0       	ldi	r17, 0x06	; 6
      78:	a6 e6       	ldi	r26, 0x66	; 102
      7a:	b0 e0       	ldi	r27, 0x00	; 0
      7c:	01 c0       	rjmp	.+2      	; 0x80 <.do_clear_bss_start>

0000007e <.do_clear_bss_loop>:
      7e:	1d 92       	st	X+, r1

00000080 <.do_clear_bss_start>:
      80:	a0 3b       	cpi	r26, 0xB0	; 176
      82:	b1 07       	cpc	r27, r17
      84:	e1 f7       	brne	.-8      	; 0x7e <.do_clear_bss_loop>
      86:	0e 94 40 08 	call	0x1080	; 0x1080 <main>
      8a:	0c 94 3f 2a 	jmp	0x547e	; 0x547e <_exit>

0000008e <__bad_interrupt>:
      8e:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00000092 <mdio_setPinstatus>:
      92:	df 93       	push	r29
      94:	cf 93       	push	r28
      96:	cd b7       	in	r28, 0x3d	; 61
      98:	de b7       	in	r29, 0x3e	; 62
      9a:	2d 97       	sbiw	r28, 0x0d	; 13
      9c:	0f b6       	in	r0, 0x3f	; 63
      9e:	f8 94       	cli
      a0:	de bf       	out	0x3e, r29	; 62
      a2:	0f be       	out	0x3f, r0	; 63
      a4:	cd bf       	out	0x3d, r28	; 61
      a6:	89 83       	std	Y+1, r24	; 0x01
      a8:	6a 83       	std	Y+2, r22	; 0x02
      aa:	4b 83       	std	Y+3, r20	; 0x03
      ac:	89 81       	ldd	r24, Y+1	; 0x01
      ae:	28 2f       	mov	r18, r24
      b0:	30 e0       	ldi	r19, 0x00	; 0
      b2:	3d 87       	std	Y+13, r19	; 0x0d
      b4:	2c 87       	std	Y+12, r18	; 0x0c
      b6:	8c 85       	ldd	r24, Y+12	; 0x0c
      b8:	9d 85       	ldd	r25, Y+13	; 0x0d
      ba:	82 30       	cpi	r24, 0x02	; 2
      bc:	91 05       	cpc	r25, r1
      be:	09 f4       	brne	.+2      	; 0xc2 <mdio_setPinstatus+0x30>
      c0:	54 c0       	rjmp	.+168    	; 0x16a <mdio_setPinstatus+0xd8>
      c2:	2c 85       	ldd	r18, Y+12	; 0x0c
      c4:	3d 85       	ldd	r19, Y+13	; 0x0d
      c6:	23 30       	cpi	r18, 0x03	; 3
      c8:	31 05       	cpc	r19, r1
      ca:	34 f4       	brge	.+12     	; 0xd8 <mdio_setPinstatus+0x46>
      cc:	8c 85       	ldd	r24, Y+12	; 0x0c
      ce:	9d 85       	ldd	r25, Y+13	; 0x0d
      d0:	81 30       	cpi	r24, 0x01	; 1
      d2:	91 05       	cpc	r25, r1
      d4:	71 f0       	breq	.+28     	; 0xf2 <mdio_setPinstatus+0x60>
      d6:	fb c0       	rjmp	.+502    	; 0x2ce <mdio_setPinstatus+0x23c>
      d8:	2c 85       	ldd	r18, Y+12	; 0x0c
      da:	3d 85       	ldd	r19, Y+13	; 0x0d
      dc:	23 30       	cpi	r18, 0x03	; 3
      de:	31 05       	cpc	r19, r1
      e0:	09 f4       	brne	.+2      	; 0xe4 <mdio_setPinstatus+0x52>
      e2:	7f c0       	rjmp	.+254    	; 0x1e2 <mdio_setPinstatus+0x150>
      e4:	8c 85       	ldd	r24, Y+12	; 0x0c
      e6:	9d 85       	ldd	r25, Y+13	; 0x0d
      e8:	84 30       	cpi	r24, 0x04	; 4
      ea:	91 05       	cpc	r25, r1
      ec:	09 f4       	brne	.+2      	; 0xf0 <mdio_setPinstatus+0x5e>
      ee:	b5 c0       	rjmp	.+362    	; 0x25a <mdio_setPinstatus+0x1c8>
      f0:	ee c0       	rjmp	.+476    	; 0x2ce <mdio_setPinstatus+0x23c>
      f2:	8b 81       	ldd	r24, Y+3	; 0x03
      f4:	28 2f       	mov	r18, r24
      f6:	30 e0       	ldi	r19, 0x00	; 0
      f8:	3b 87       	std	Y+11, r19	; 0x0b
      fa:	2a 87       	std	Y+10, r18	; 0x0a
      fc:	8a 85       	ldd	r24, Y+10	; 0x0a
      fe:	9b 85       	ldd	r25, Y+11	; 0x0b
     100:	82 30       	cpi	r24, 0x02	; 2
     102:	91 05       	cpc	r25, r1
     104:	a1 f0       	breq	.+40     	; 0x12e <mdio_setPinstatus+0x9c>
     106:	2a 85       	ldd	r18, Y+10	; 0x0a
     108:	3b 85       	ldd	r19, Y+11	; 0x0b
     10a:	23 30       	cpi	r18, 0x03	; 3
     10c:	31 05       	cpc	r19, r1
     10e:	d1 f0       	breq	.+52     	; 0x144 <mdio_setPinstatus+0xb2>
     110:	8a 85       	ldd	r24, Y+10	; 0x0a
     112:	9b 85       	ldd	r25, Y+11	; 0x0b
     114:	81 30       	cpi	r24, 0x01	; 1
     116:	91 05       	cpc	r25, r1
     118:	09 f0       	breq	.+2      	; 0x11c <mdio_setPinstatus+0x8a>
     11a:	d9 c0       	rjmp	.+434    	; 0x2ce <mdio_setPinstatus+0x23c>
     11c:	aa e3       	ldi	r26, 0x3A	; 58
     11e:	b0 e0       	ldi	r27, 0x00	; 0
     120:	ea e3       	ldi	r30, 0x3A	; 58
     122:	f0 e0       	ldi	r31, 0x00	; 0
     124:	90 81       	ld	r25, Z
     126:	8a 81       	ldd	r24, Y+2	; 0x02
     128:	89 2b       	or	r24, r25
     12a:	8c 93       	st	X, r24
     12c:	d0 c0       	rjmp	.+416    	; 0x2ce <mdio_setPinstatus+0x23c>
     12e:	aa e3       	ldi	r26, 0x3A	; 58
     130:	b0 e0       	ldi	r27, 0x00	; 0
     132:	ea e3       	ldi	r30, 0x3A	; 58
     134:	f0 e0       	ldi	r31, 0x00	; 0
     136:	80 81       	ld	r24, Z
     138:	98 2f       	mov	r25, r24
     13a:	8a 81       	ldd	r24, Y+2	; 0x02
     13c:	80 95       	com	r24
     13e:	89 23       	and	r24, r25
     140:	8c 93       	st	X, r24
     142:	c5 c0       	rjmp	.+394    	; 0x2ce <mdio_setPinstatus+0x23c>
     144:	aa e3       	ldi	r26, 0x3A	; 58
     146:	b0 e0       	ldi	r27, 0x00	; 0
     148:	ea e3       	ldi	r30, 0x3A	; 58
     14a:	f0 e0       	ldi	r31, 0x00	; 0
     14c:	80 81       	ld	r24, Z
     14e:	98 2f       	mov	r25, r24
     150:	8a 81       	ldd	r24, Y+2	; 0x02
     152:	80 95       	com	r24
     154:	89 23       	and	r24, r25
     156:	8c 93       	st	X, r24
     158:	ab e3       	ldi	r26, 0x3B	; 59
     15a:	b0 e0       	ldi	r27, 0x00	; 0
     15c:	eb e3       	ldi	r30, 0x3B	; 59
     15e:	f0 e0       	ldi	r31, 0x00	; 0
     160:	90 81       	ld	r25, Z
     162:	8a 81       	ldd	r24, Y+2	; 0x02
     164:	89 2b       	or	r24, r25
     166:	8c 93       	st	X, r24
     168:	b2 c0       	rjmp	.+356    	; 0x2ce <mdio_setPinstatus+0x23c>
     16a:	8b 81       	ldd	r24, Y+3	; 0x03
     16c:	28 2f       	mov	r18, r24
     16e:	30 e0       	ldi	r19, 0x00	; 0
     170:	39 87       	std	Y+9, r19	; 0x09
     172:	28 87       	std	Y+8, r18	; 0x08
     174:	88 85       	ldd	r24, Y+8	; 0x08
     176:	99 85       	ldd	r25, Y+9	; 0x09
     178:	82 30       	cpi	r24, 0x02	; 2
     17a:	91 05       	cpc	r25, r1
     17c:	a1 f0       	breq	.+40     	; 0x1a6 <mdio_setPinstatus+0x114>
     17e:	28 85       	ldd	r18, Y+8	; 0x08
     180:	39 85       	ldd	r19, Y+9	; 0x09
     182:	23 30       	cpi	r18, 0x03	; 3
     184:	31 05       	cpc	r19, r1
     186:	d1 f0       	breq	.+52     	; 0x1bc <mdio_setPinstatus+0x12a>
     188:	88 85       	ldd	r24, Y+8	; 0x08
     18a:	99 85       	ldd	r25, Y+9	; 0x09
     18c:	81 30       	cpi	r24, 0x01	; 1
     18e:	91 05       	cpc	r25, r1
     190:	09 f0       	breq	.+2      	; 0x194 <mdio_setPinstatus+0x102>
     192:	9d c0       	rjmp	.+314    	; 0x2ce <mdio_setPinstatus+0x23c>
     194:	a7 e3       	ldi	r26, 0x37	; 55
     196:	b0 e0       	ldi	r27, 0x00	; 0
     198:	e7 e3       	ldi	r30, 0x37	; 55
     19a:	f0 e0       	ldi	r31, 0x00	; 0
     19c:	90 81       	ld	r25, Z
     19e:	8a 81       	ldd	r24, Y+2	; 0x02
     1a0:	89 2b       	or	r24, r25
     1a2:	8c 93       	st	X, r24
     1a4:	94 c0       	rjmp	.+296    	; 0x2ce <mdio_setPinstatus+0x23c>
     1a6:	a7 e3       	ldi	r26, 0x37	; 55
     1a8:	b0 e0       	ldi	r27, 0x00	; 0
     1aa:	e7 e3       	ldi	r30, 0x37	; 55
     1ac:	f0 e0       	ldi	r31, 0x00	; 0
     1ae:	80 81       	ld	r24, Z
     1b0:	98 2f       	mov	r25, r24
     1b2:	8a 81       	ldd	r24, Y+2	; 0x02
     1b4:	80 95       	com	r24
     1b6:	89 23       	and	r24, r25
     1b8:	8c 93       	st	X, r24
     1ba:	89 c0       	rjmp	.+274    	; 0x2ce <mdio_setPinstatus+0x23c>
     1bc:	a7 e3       	ldi	r26, 0x37	; 55
     1be:	b0 e0       	ldi	r27, 0x00	; 0
     1c0:	e7 e3       	ldi	r30, 0x37	; 55
     1c2:	f0 e0       	ldi	r31, 0x00	; 0
     1c4:	80 81       	ld	r24, Z
     1c6:	98 2f       	mov	r25, r24
     1c8:	8a 81       	ldd	r24, Y+2	; 0x02
     1ca:	80 95       	com	r24
     1cc:	89 23       	and	r24, r25
     1ce:	8c 93       	st	X, r24
     1d0:	a8 e3       	ldi	r26, 0x38	; 56
     1d2:	b0 e0       	ldi	r27, 0x00	; 0
     1d4:	e8 e3       	ldi	r30, 0x38	; 56
     1d6:	f0 e0       	ldi	r31, 0x00	; 0
     1d8:	90 81       	ld	r25, Z
     1da:	8a 81       	ldd	r24, Y+2	; 0x02
     1dc:	89 2b       	or	r24, r25
     1de:	8c 93       	st	X, r24
     1e0:	76 c0       	rjmp	.+236    	; 0x2ce <mdio_setPinstatus+0x23c>
     1e2:	8b 81       	ldd	r24, Y+3	; 0x03
     1e4:	28 2f       	mov	r18, r24
     1e6:	30 e0       	ldi	r19, 0x00	; 0
     1e8:	3f 83       	std	Y+7, r19	; 0x07
     1ea:	2e 83       	std	Y+6, r18	; 0x06
     1ec:	8e 81       	ldd	r24, Y+6	; 0x06
     1ee:	9f 81       	ldd	r25, Y+7	; 0x07
     1f0:	82 30       	cpi	r24, 0x02	; 2
     1f2:	91 05       	cpc	r25, r1
     1f4:	a1 f0       	breq	.+40     	; 0x21e <mdio_setPinstatus+0x18c>
     1f6:	2e 81       	ldd	r18, Y+6	; 0x06
     1f8:	3f 81       	ldd	r19, Y+7	; 0x07
     1fa:	23 30       	cpi	r18, 0x03	; 3
     1fc:	31 05       	cpc	r19, r1
     1fe:	d1 f0       	breq	.+52     	; 0x234 <mdio_setPinstatus+0x1a2>
     200:	8e 81       	ldd	r24, Y+6	; 0x06
     202:	9f 81       	ldd	r25, Y+7	; 0x07
     204:	81 30       	cpi	r24, 0x01	; 1
     206:	91 05       	cpc	r25, r1
     208:	09 f0       	breq	.+2      	; 0x20c <mdio_setPinstatus+0x17a>
     20a:	61 c0       	rjmp	.+194    	; 0x2ce <mdio_setPinstatus+0x23c>
     20c:	a4 e3       	ldi	r26, 0x34	; 52
     20e:	b0 e0       	ldi	r27, 0x00	; 0
     210:	e4 e3       	ldi	r30, 0x34	; 52
     212:	f0 e0       	ldi	r31, 0x00	; 0
     214:	90 81       	ld	r25, Z
     216:	8a 81       	ldd	r24, Y+2	; 0x02
     218:	89 2b       	or	r24, r25
     21a:	8c 93       	st	X, r24
     21c:	58 c0       	rjmp	.+176    	; 0x2ce <mdio_setPinstatus+0x23c>
     21e:	a4 e3       	ldi	r26, 0x34	; 52
     220:	b0 e0       	ldi	r27, 0x00	; 0
     222:	e4 e3       	ldi	r30, 0x34	; 52
     224:	f0 e0       	ldi	r31, 0x00	; 0
     226:	80 81       	ld	r24, Z
     228:	98 2f       	mov	r25, r24
     22a:	8a 81       	ldd	r24, Y+2	; 0x02
     22c:	80 95       	com	r24
     22e:	89 23       	and	r24, r25
     230:	8c 93       	st	X, r24
     232:	4d c0       	rjmp	.+154    	; 0x2ce <mdio_setPinstatus+0x23c>
     234:	a4 e3       	ldi	r26, 0x34	; 52
     236:	b0 e0       	ldi	r27, 0x00	; 0
     238:	e4 e3       	ldi	r30, 0x34	; 52
     23a:	f0 e0       	ldi	r31, 0x00	; 0
     23c:	80 81       	ld	r24, Z
     23e:	98 2f       	mov	r25, r24
     240:	8a 81       	ldd	r24, Y+2	; 0x02
     242:	80 95       	com	r24
     244:	89 23       	and	r24, r25
     246:	8c 93       	st	X, r24
     248:	a5 e3       	ldi	r26, 0x35	; 53
     24a:	b0 e0       	ldi	r27, 0x00	; 0
     24c:	e5 e3       	ldi	r30, 0x35	; 53
     24e:	f0 e0       	ldi	r31, 0x00	; 0
     250:	90 81       	ld	r25, Z
     252:	8a 81       	ldd	r24, Y+2	; 0x02
     254:	89 2b       	or	r24, r25
     256:	8c 93       	st	X, r24
     258:	3a c0       	rjmp	.+116    	; 0x2ce <mdio_setPinstatus+0x23c>
     25a:	8b 81       	ldd	r24, Y+3	; 0x03
     25c:	28 2f       	mov	r18, r24
     25e:	30 e0       	ldi	r19, 0x00	; 0
     260:	3d 83       	std	Y+5, r19	; 0x05
     262:	2c 83       	std	Y+4, r18	; 0x04
     264:	8c 81       	ldd	r24, Y+4	; 0x04
     266:	9d 81       	ldd	r25, Y+5	; 0x05
     268:	82 30       	cpi	r24, 0x02	; 2
     26a:	91 05       	cpc	r25, r1
     26c:	99 f0       	breq	.+38     	; 0x294 <mdio_setPinstatus+0x202>
     26e:	2c 81       	ldd	r18, Y+4	; 0x04
     270:	3d 81       	ldd	r19, Y+5	; 0x05
     272:	23 30       	cpi	r18, 0x03	; 3
     274:	31 05       	cpc	r19, r1
     276:	c9 f0       	breq	.+50     	; 0x2aa <mdio_setPinstatus+0x218>
     278:	8c 81       	ldd	r24, Y+4	; 0x04
     27a:	9d 81       	ldd	r25, Y+5	; 0x05
     27c:	81 30       	cpi	r24, 0x01	; 1
     27e:	91 05       	cpc	r25, r1
     280:	31 f5       	brne	.+76     	; 0x2ce <mdio_setPinstatus+0x23c>
     282:	a1 e3       	ldi	r26, 0x31	; 49
     284:	b0 e0       	ldi	r27, 0x00	; 0
     286:	e1 e3       	ldi	r30, 0x31	; 49
     288:	f0 e0       	ldi	r31, 0x00	; 0
     28a:	90 81       	ld	r25, Z
     28c:	8a 81       	ldd	r24, Y+2	; 0x02
     28e:	89 2b       	or	r24, r25
     290:	8c 93       	st	X, r24
     292:	1d c0       	rjmp	.+58     	; 0x2ce <mdio_setPinstatus+0x23c>
     294:	a1 e3       	ldi	r26, 0x31	; 49
     296:	b0 e0       	ldi	r27, 0x00	; 0
     298:	e1 e3       	ldi	r30, 0x31	; 49
     29a:	f0 e0       	ldi	r31, 0x00	; 0
     29c:	80 81       	ld	r24, Z
     29e:	98 2f       	mov	r25, r24
     2a0:	8a 81       	ldd	r24, Y+2	; 0x02
     2a2:	80 95       	com	r24
     2a4:	89 23       	and	r24, r25
     2a6:	8c 93       	st	X, r24
     2a8:	12 c0       	rjmp	.+36     	; 0x2ce <mdio_setPinstatus+0x23c>
     2aa:	a1 e3       	ldi	r26, 0x31	; 49
     2ac:	b0 e0       	ldi	r27, 0x00	; 0
     2ae:	e1 e3       	ldi	r30, 0x31	; 49
     2b0:	f0 e0       	ldi	r31, 0x00	; 0
     2b2:	80 81       	ld	r24, Z
     2b4:	98 2f       	mov	r25, r24
     2b6:	8a 81       	ldd	r24, Y+2	; 0x02
     2b8:	80 95       	com	r24
     2ba:	89 23       	and	r24, r25
     2bc:	8c 93       	st	X, r24
     2be:	a2 e3       	ldi	r26, 0x32	; 50
     2c0:	b0 e0       	ldi	r27, 0x00	; 0
     2c2:	e2 e3       	ldi	r30, 0x32	; 50
     2c4:	f0 e0       	ldi	r31, 0x00	; 0
     2c6:	90 81       	ld	r25, Z
     2c8:	8a 81       	ldd	r24, Y+2	; 0x02
     2ca:	89 2b       	or	r24, r25
     2cc:	8c 93       	st	X, r24
     2ce:	2d 96       	adiw	r28, 0x0d	; 13
     2d0:	0f b6       	in	r0, 0x3f	; 63
     2d2:	f8 94       	cli
     2d4:	de bf       	out	0x3e, r29	; 62
     2d6:	0f be       	out	0x3f, r0	; 63
     2d8:	cd bf       	out	0x3d, r28	; 61
     2da:	cf 91       	pop	r28
     2dc:	df 91       	pop	r29
     2de:	08 95       	ret

000002e0 <mdio_setPinValue>:
	return;
}


void mdio_setPinValue(u8_t au8_port, u8_t au8_pin, u8_t au8_Value )
{
     2e0:	df 93       	push	r29
     2e2:	cf 93       	push	r28
     2e4:	cd b7       	in	r28, 0x3d	; 61
     2e6:	de b7       	in	r29, 0x3e	; 62
     2e8:	2d 97       	sbiw	r28, 0x0d	; 13
     2ea:	0f b6       	in	r0, 0x3f	; 63
     2ec:	f8 94       	cli
     2ee:	de bf       	out	0x3e, r29	; 62
     2f0:	0f be       	out	0x3f, r0	; 63
     2f2:	cd bf       	out	0x3d, r28	; 61
     2f4:	89 83       	std	Y+1, r24	; 0x01
     2f6:	6a 83       	std	Y+2, r22	; 0x02
     2f8:	4b 83       	std	Y+3, r20	; 0x03
	/*switching over DIO Ports*/
	switch(au8_port)
     2fa:	89 81       	ldd	r24, Y+1	; 0x01
     2fc:	28 2f       	mov	r18, r24
     2fe:	30 e0       	ldi	r19, 0x00	; 0
     300:	3d 87       	std	Y+13, r19	; 0x0d
     302:	2c 87       	std	Y+12, r18	; 0x0c
     304:	8c 85       	ldd	r24, Y+12	; 0x0c
     306:	9d 85       	ldd	r25, Y+13	; 0x0d
     308:	82 30       	cpi	r24, 0x02	; 2
     30a:	91 05       	cpc	r25, r1
     30c:	d9 f1       	breq	.+118    	; 0x384 <mdio_setPinValue+0xa4>
     30e:	2c 85       	ldd	r18, Y+12	; 0x0c
     310:	3d 85       	ldd	r19, Y+13	; 0x0d
     312:	23 30       	cpi	r18, 0x03	; 3
     314:	31 05       	cpc	r19, r1
     316:	34 f4       	brge	.+12     	; 0x324 <mdio_setPinValue+0x44>
     318:	8c 85       	ldd	r24, Y+12	; 0x0c
     31a:	9d 85       	ldd	r25, Y+13	; 0x0d
     31c:	81 30       	cpi	r24, 0x01	; 1
     31e:	91 05       	cpc	r25, r1
     320:	71 f0       	breq	.+28     	; 0x33e <mdio_setPinValue+0x5e>
     322:	96 c0       	rjmp	.+300    	; 0x450 <mdio_setPinValue+0x170>
     324:	2c 85       	ldd	r18, Y+12	; 0x0c
     326:	3d 85       	ldd	r19, Y+13	; 0x0d
     328:	23 30       	cpi	r18, 0x03	; 3
     32a:	31 05       	cpc	r19, r1
     32c:	09 f4       	brne	.+2      	; 0x330 <mdio_setPinValue+0x50>
     32e:	4d c0       	rjmp	.+154    	; 0x3ca <mdio_setPinValue+0xea>
     330:	8c 85       	ldd	r24, Y+12	; 0x0c
     332:	9d 85       	ldd	r25, Y+13	; 0x0d
     334:	84 30       	cpi	r24, 0x04	; 4
     336:	91 05       	cpc	r25, r1
     338:	09 f4       	brne	.+2      	; 0x33c <mdio_setPinValue+0x5c>
     33a:	69 c0       	rjmp	.+210    	; 0x40e <mdio_setPinValue+0x12e>
     33c:	89 c0       	rjmp	.+274    	; 0x450 <mdio_setPinValue+0x170>
	{
	/*IN CASE OF CHOOSING PORT A*/
	case PORTA:
		/*switching over pin value*/
		switch(au8_Value)
     33e:	8b 81       	ldd	r24, Y+3	; 0x03
     340:	28 2f       	mov	r18, r24
     342:	30 e0       	ldi	r19, 0x00	; 0
     344:	3b 87       	std	Y+11, r19	; 0x0b
     346:	2a 87       	std	Y+10, r18	; 0x0a
     348:	8a 85       	ldd	r24, Y+10	; 0x0a
     34a:	9b 85       	ldd	r25, Y+11	; 0x0b
     34c:	00 97       	sbiw	r24, 0x00	; 0
     34e:	79 f0       	breq	.+30     	; 0x36e <mdio_setPinValue+0x8e>
     350:	2a 85       	ldd	r18, Y+10	; 0x0a
     352:	3b 85       	ldd	r19, Y+11	; 0x0b
     354:	21 30       	cpi	r18, 0x01	; 1
     356:	31 05       	cpc	r19, r1
     358:	09 f0       	breq	.+2      	; 0x35c <mdio_setPinValue+0x7c>
     35a:	7a c0       	rjmp	.+244    	; 0x450 <mdio_setPinValue+0x170>
		{
		/*in case of choosing high*/
		case HIGH:
			/*setting specific DIO Pins to high */
			MDIO_PORTA |= au8_pin;
     35c:	ab e3       	ldi	r26, 0x3B	; 59
     35e:	b0 e0       	ldi	r27, 0x00	; 0
     360:	eb e3       	ldi	r30, 0x3B	; 59
     362:	f0 e0       	ldi	r31, 0x00	; 0
     364:	90 81       	ld	r25, Z
     366:	8a 81       	ldd	r24, Y+2	; 0x02
     368:	89 2b       	or	r24, r25
     36a:	8c 93       	st	X, r24
     36c:	71 c0       	rjmp	.+226    	; 0x450 <mdio_setPinValue+0x170>
			/*break from this case*/
			break;
		/*in case of choosing low*/
		case LOW:
			/*setting specific DIO pin to low*/
			MDIO_PORTA &= ~ au8_pin;
     36e:	ab e3       	ldi	r26, 0x3B	; 59
     370:	b0 e0       	ldi	r27, 0x00	; 0
     372:	eb e3       	ldi	r30, 0x3B	; 59
     374:	f0 e0       	ldi	r31, 0x00	; 0
     376:	80 81       	ld	r24, Z
     378:	98 2f       	mov	r25, r24
     37a:	8a 81       	ldd	r24, Y+2	; 0x02
     37c:	80 95       	com	r24
     37e:	89 23       	and	r24, r25
     380:	8c 93       	st	X, r24
     382:	66 c0       	rjmp	.+204    	; 0x450 <mdio_setPinValue+0x170>
		/*break from this case*/
		break;
	/*IN CASE OF CHOOSING PORT B*/
	case PORTB:
		/*switching over pin value*/
		switch(au8_Value)
     384:	8b 81       	ldd	r24, Y+3	; 0x03
     386:	28 2f       	mov	r18, r24
     388:	30 e0       	ldi	r19, 0x00	; 0
     38a:	39 87       	std	Y+9, r19	; 0x09
     38c:	28 87       	std	Y+8, r18	; 0x08
     38e:	88 85       	ldd	r24, Y+8	; 0x08
     390:	99 85       	ldd	r25, Y+9	; 0x09
     392:	00 97       	sbiw	r24, 0x00	; 0
     394:	79 f0       	breq	.+30     	; 0x3b4 <mdio_setPinValue+0xd4>
     396:	28 85       	ldd	r18, Y+8	; 0x08
     398:	39 85       	ldd	r19, Y+9	; 0x09
     39a:	21 30       	cpi	r18, 0x01	; 1
     39c:	31 05       	cpc	r19, r1
     39e:	09 f0       	breq	.+2      	; 0x3a2 <mdio_setPinValue+0xc2>
     3a0:	57 c0       	rjmp	.+174    	; 0x450 <mdio_setPinValue+0x170>
		{
		/*in case of choosing high*/
		case HIGH:
			/*setting specific DIO Pins to high */
			MDIO_PORTB |= au8_pin;
     3a2:	a8 e3       	ldi	r26, 0x38	; 56
     3a4:	b0 e0       	ldi	r27, 0x00	; 0
     3a6:	e8 e3       	ldi	r30, 0x38	; 56
     3a8:	f0 e0       	ldi	r31, 0x00	; 0
     3aa:	90 81       	ld	r25, Z
     3ac:	8a 81       	ldd	r24, Y+2	; 0x02
     3ae:	89 2b       	or	r24, r25
     3b0:	8c 93       	st	X, r24
     3b2:	4e c0       	rjmp	.+156    	; 0x450 <mdio_setPinValue+0x170>
			/*break from this case*/
			break;
		/*in case of choosing low*/
		case LOW:
			/*setting specific DIO pin to low*/
			MDIO_PORTB &= ~ au8_pin;
     3b4:	a8 e3       	ldi	r26, 0x38	; 56
     3b6:	b0 e0       	ldi	r27, 0x00	; 0
     3b8:	e8 e3       	ldi	r30, 0x38	; 56
     3ba:	f0 e0       	ldi	r31, 0x00	; 0
     3bc:	80 81       	ld	r24, Z
     3be:	98 2f       	mov	r25, r24
     3c0:	8a 81       	ldd	r24, Y+2	; 0x02
     3c2:	80 95       	com	r24
     3c4:	89 23       	and	r24, r25
     3c6:	8c 93       	st	X, r24
     3c8:	43 c0       	rjmp	.+134    	; 0x450 <mdio_setPinValue+0x170>
		/*break from this case*/
		break;
	/*IN CASE OF CHOOSING PORT C*/
	case PORTC:
		/*switching over pin value*/
		switch(au8_Value)
     3ca:	8b 81       	ldd	r24, Y+3	; 0x03
     3cc:	28 2f       	mov	r18, r24
     3ce:	30 e0       	ldi	r19, 0x00	; 0
     3d0:	3f 83       	std	Y+7, r19	; 0x07
     3d2:	2e 83       	std	Y+6, r18	; 0x06
     3d4:	8e 81       	ldd	r24, Y+6	; 0x06
     3d6:	9f 81       	ldd	r25, Y+7	; 0x07
     3d8:	00 97       	sbiw	r24, 0x00	; 0
     3da:	71 f0       	breq	.+28     	; 0x3f8 <mdio_setPinValue+0x118>
     3dc:	2e 81       	ldd	r18, Y+6	; 0x06
     3de:	3f 81       	ldd	r19, Y+7	; 0x07
     3e0:	21 30       	cpi	r18, 0x01	; 1
     3e2:	31 05       	cpc	r19, r1
     3e4:	a9 f5       	brne	.+106    	; 0x450 <mdio_setPinValue+0x170>
		{
		/*in case of choosing high*/
		case HIGH:
			/*setting specific DIO Pins to high */
			MDIO_PORTC |= au8_pin;
     3e6:	a5 e3       	ldi	r26, 0x35	; 53
     3e8:	b0 e0       	ldi	r27, 0x00	; 0
     3ea:	e5 e3       	ldi	r30, 0x35	; 53
     3ec:	f0 e0       	ldi	r31, 0x00	; 0
     3ee:	90 81       	ld	r25, Z
     3f0:	8a 81       	ldd	r24, Y+2	; 0x02
     3f2:	89 2b       	or	r24, r25
     3f4:	8c 93       	st	X, r24
     3f6:	2c c0       	rjmp	.+88     	; 0x450 <mdio_setPinValue+0x170>
			/*break from this case*/
			break;
		/*in case of choosing low*/
		case LOW:
			/*setting specific DIO pin to low*/
			MDIO_PORTC &= ~ au8_pin;
     3f8:	a5 e3       	ldi	r26, 0x35	; 53
     3fa:	b0 e0       	ldi	r27, 0x00	; 0
     3fc:	e5 e3       	ldi	r30, 0x35	; 53
     3fe:	f0 e0       	ldi	r31, 0x00	; 0
     400:	80 81       	ld	r24, Z
     402:	98 2f       	mov	r25, r24
     404:	8a 81       	ldd	r24, Y+2	; 0x02
     406:	80 95       	com	r24
     408:	89 23       	and	r24, r25
     40a:	8c 93       	st	X, r24
     40c:	21 c0       	rjmp	.+66     	; 0x450 <mdio_setPinValue+0x170>
		/*break from this case*/
		break;
	/*IN CASE OF CHOOSING PORT D*/
	case PORTD:
		/*switching over pin value*/
		switch(au8_Value)
     40e:	8b 81       	ldd	r24, Y+3	; 0x03
     410:	28 2f       	mov	r18, r24
     412:	30 e0       	ldi	r19, 0x00	; 0
     414:	3d 83       	std	Y+5, r19	; 0x05
     416:	2c 83       	std	Y+4, r18	; 0x04
     418:	8c 81       	ldd	r24, Y+4	; 0x04
     41a:	9d 81       	ldd	r25, Y+5	; 0x05
     41c:	00 97       	sbiw	r24, 0x00	; 0
     41e:	71 f0       	breq	.+28     	; 0x43c <mdio_setPinValue+0x15c>
     420:	2c 81       	ldd	r18, Y+4	; 0x04
     422:	3d 81       	ldd	r19, Y+5	; 0x05
     424:	21 30       	cpi	r18, 0x01	; 1
     426:	31 05       	cpc	r19, r1
     428:	99 f4       	brne	.+38     	; 0x450 <mdio_setPinValue+0x170>
		{
		/*in case of choosing high*/
		case HIGH:
			/*setting specific DIO Pins to high */
			MDIO_PORTD |= au8_pin;
     42a:	a2 e3       	ldi	r26, 0x32	; 50
     42c:	b0 e0       	ldi	r27, 0x00	; 0
     42e:	e2 e3       	ldi	r30, 0x32	; 50
     430:	f0 e0       	ldi	r31, 0x00	; 0
     432:	90 81       	ld	r25, Z
     434:	8a 81       	ldd	r24, Y+2	; 0x02
     436:	89 2b       	or	r24, r25
     438:	8c 93       	st	X, r24
     43a:	0a c0       	rjmp	.+20     	; 0x450 <mdio_setPinValue+0x170>
			/*break from this case*/
			break;
		/*in case of choosing low*/
		case LOW:
			/*setting specific DIO pin to low*/
			MDIO_PORTD &= ~ au8_pin;
     43c:	a2 e3       	ldi	r26, 0x32	; 50
     43e:	b0 e0       	ldi	r27, 0x00	; 0
     440:	e2 e3       	ldi	r30, 0x32	; 50
     442:	f0 e0       	ldi	r31, 0x00	; 0
     444:	80 81       	ld	r24, Z
     446:	98 2f       	mov	r25, r24
     448:	8a 81       	ldd	r24, Y+2	; 0x02
     44a:	80 95       	com	r24
     44c:	89 23       	and	r24, r25
     44e:	8c 93       	st	X, r24
		/*break from this case*/
		break;
	}
	/*Return from this function*/
	return;
}
     450:	2d 96       	adiw	r28, 0x0d	; 13
     452:	0f b6       	in	r0, 0x3f	; 63
     454:	f8 94       	cli
     456:	de bf       	out	0x3e, r29	; 62
     458:	0f be       	out	0x3f, r0	; 63
     45a:	cd bf       	out	0x3d, r28	; 61
     45c:	cf 91       	pop	r28
     45e:	df 91       	pop	r29
     460:	08 95       	ret

00000462 <mdio_togglePinValue>:


void mdio_togglePinValue(u8_t au8_port, u8_t au8_pin )
{
     462:	df 93       	push	r29
     464:	cf 93       	push	r28
     466:	00 d0       	rcall	.+0      	; 0x468 <mdio_togglePinValue+0x6>
     468:	00 d0       	rcall	.+0      	; 0x46a <mdio_togglePinValue+0x8>
     46a:	cd b7       	in	r28, 0x3d	; 61
     46c:	de b7       	in	r29, 0x3e	; 62
     46e:	89 83       	std	Y+1, r24	; 0x01
     470:	6a 83       	std	Y+2, r22	; 0x02
	/*switching over DIO PORTS*/
	switch(au8_port)
     472:	89 81       	ldd	r24, Y+1	; 0x01
     474:	28 2f       	mov	r18, r24
     476:	30 e0       	ldi	r19, 0x00	; 0
     478:	3c 83       	std	Y+4, r19	; 0x04
     47a:	2b 83       	std	Y+3, r18	; 0x03
     47c:	8b 81       	ldd	r24, Y+3	; 0x03
     47e:	9c 81       	ldd	r25, Y+4	; 0x04
     480:	82 30       	cpi	r24, 0x02	; 2
     482:	91 05       	cpc	r25, r1
     484:	f9 f0       	breq	.+62     	; 0x4c4 <mdio_togglePinValue+0x62>
     486:	2b 81       	ldd	r18, Y+3	; 0x03
     488:	3c 81       	ldd	r19, Y+4	; 0x04
     48a:	23 30       	cpi	r18, 0x03	; 3
     48c:	31 05       	cpc	r19, r1
     48e:	34 f4       	brge	.+12     	; 0x49c <mdio_togglePinValue+0x3a>
     490:	8b 81       	ldd	r24, Y+3	; 0x03
     492:	9c 81       	ldd	r25, Y+4	; 0x04
     494:	81 30       	cpi	r24, 0x01	; 1
     496:	91 05       	cpc	r25, r1
     498:	61 f0       	breq	.+24     	; 0x4b2 <mdio_togglePinValue+0x50>
     49a:	2e c0       	rjmp	.+92     	; 0x4f8 <mdio_togglePinValue+0x96>
     49c:	2b 81       	ldd	r18, Y+3	; 0x03
     49e:	3c 81       	ldd	r19, Y+4	; 0x04
     4a0:	23 30       	cpi	r18, 0x03	; 3
     4a2:	31 05       	cpc	r19, r1
     4a4:	c1 f0       	breq	.+48     	; 0x4d6 <mdio_togglePinValue+0x74>
     4a6:	8b 81       	ldd	r24, Y+3	; 0x03
     4a8:	9c 81       	ldd	r25, Y+4	; 0x04
     4aa:	84 30       	cpi	r24, 0x04	; 4
     4ac:	91 05       	cpc	r25, r1
     4ae:	e1 f0       	breq	.+56     	; 0x4e8 <mdio_togglePinValue+0x86>
     4b0:	23 c0       	rjmp	.+70     	; 0x4f8 <mdio_togglePinValue+0x96>
	{
	/*in case of choosing PORTA*/
	case PORTA:
		/*toggling specific DIO pin*/
		MDIO_PORTA |= au8_pin;
     4b2:	ab e3       	ldi	r26, 0x3B	; 59
     4b4:	b0 e0       	ldi	r27, 0x00	; 0
     4b6:	eb e3       	ldi	r30, 0x3B	; 59
     4b8:	f0 e0       	ldi	r31, 0x00	; 0
     4ba:	90 81       	ld	r25, Z
     4bc:	8a 81       	ldd	r24, Y+2	; 0x02
     4be:	89 2b       	or	r24, r25
     4c0:	8c 93       	st	X, r24
     4c2:	1a c0       	rjmp	.+52     	; 0x4f8 <mdio_togglePinValue+0x96>
		/*break from this case*/
		break;
	/*in case of choosing PORTB*/
	case PORTB:
		/*toggling specific DIO pin*/
		MDIO_PORTB |= au8_pin;
     4c4:	a8 e3       	ldi	r26, 0x38	; 56
     4c6:	b0 e0       	ldi	r27, 0x00	; 0
     4c8:	e8 e3       	ldi	r30, 0x38	; 56
     4ca:	f0 e0       	ldi	r31, 0x00	; 0
     4cc:	90 81       	ld	r25, Z
     4ce:	8a 81       	ldd	r24, Y+2	; 0x02
     4d0:	89 2b       	or	r24, r25
     4d2:	8c 93       	st	X, r24
     4d4:	11 c0       	rjmp	.+34     	; 0x4f8 <mdio_togglePinValue+0x96>
		/*break from this case*/
		break;
	/*in case of choosing PORTB*/
	case PORTC:
		/*toggling specific DIO pin*/
		MDIO_PORTC |= au8_pin;
     4d6:	a5 e3       	ldi	r26, 0x35	; 53
     4d8:	b0 e0       	ldi	r27, 0x00	; 0
     4da:	e5 e3       	ldi	r30, 0x35	; 53
     4dc:	f0 e0       	ldi	r31, 0x00	; 0
     4de:	90 81       	ld	r25, Z
     4e0:	8a 81       	ldd	r24, Y+2	; 0x02
     4e2:	89 2b       	or	r24, r25
     4e4:	8c 93       	st	X, r24
     4e6:	08 c0       	rjmp	.+16     	; 0x4f8 <mdio_togglePinValue+0x96>
		/*break from this case*/
		break;
	/*in case of choosing PORTB*/
	case PORTD:
		/*toggling specific DIO pin*/
		MDIO_PORTD |= au8_pin;
     4e8:	a2 e3       	ldi	r26, 0x32	; 50
     4ea:	b0 e0       	ldi	r27, 0x00	; 0
     4ec:	e2 e3       	ldi	r30, 0x32	; 50
     4ee:	f0 e0       	ldi	r31, 0x00	; 0
     4f0:	90 81       	ld	r25, Z
     4f2:	8a 81       	ldd	r24, Y+2	; 0x02
     4f4:	89 2b       	or	r24, r25
     4f6:	8c 93       	st	X, r24
		/*break from default*/
		break;
	}
	/*Return from this function*/
	return;
}
     4f8:	0f 90       	pop	r0
     4fa:	0f 90       	pop	r0
     4fc:	0f 90       	pop	r0
     4fe:	0f 90       	pop	r0
     500:	cf 91       	pop	r28
     502:	df 91       	pop	r29
     504:	08 95       	ret

00000506 <mdio_getPinValue>:


u8_t mdio_getPinValue(u8_t au8_port, u8_t au8_pin )
{
     506:	df 93       	push	r29
     508:	cf 93       	push	r28
     50a:	00 d0       	rcall	.+0      	; 0x50c <mdio_getPinValue+0x6>
     50c:	00 d0       	rcall	.+0      	; 0x50e <mdio_getPinValue+0x8>
     50e:	0f 92       	push	r0
     510:	cd b7       	in	r28, 0x3d	; 61
     512:	de b7       	in	r29, 0x3e	; 62
     514:	8a 83       	std	Y+2, r24	; 0x02
     516:	6b 83       	std	Y+3, r22	; 0x03
	/*Local variable used to get a specific pin value*/
	u8_t au8_pinValue = 0;
     518:	19 82       	std	Y+1, r1	; 0x01
	/*switching over DIO ports*/
	switch(au8_port)
     51a:	8a 81       	ldd	r24, Y+2	; 0x02
     51c:	28 2f       	mov	r18, r24
     51e:	30 e0       	ldi	r19, 0x00	; 0
     520:	3d 83       	std	Y+5, r19	; 0x05
     522:	2c 83       	std	Y+4, r18	; 0x04
     524:	8c 81       	ldd	r24, Y+4	; 0x04
     526:	9d 81       	ldd	r25, Y+5	; 0x05
     528:	82 30       	cpi	r24, 0x02	; 2
     52a:	91 05       	cpc	r25, r1
     52c:	11 f1       	breq	.+68     	; 0x572 <mdio_getPinValue+0x6c>
     52e:	2c 81       	ldd	r18, Y+4	; 0x04
     530:	3d 81       	ldd	r19, Y+5	; 0x05
     532:	23 30       	cpi	r18, 0x03	; 3
     534:	31 05       	cpc	r19, r1
     536:	34 f4       	brge	.+12     	; 0x544 <mdio_getPinValue+0x3e>
     538:	8c 81       	ldd	r24, Y+4	; 0x04
     53a:	9d 81       	ldd	r25, Y+5	; 0x05
     53c:	81 30       	cpi	r24, 0x01	; 1
     53e:	91 05       	cpc	r25, r1
     540:	61 f0       	breq	.+24     	; 0x55a <mdio_getPinValue+0x54>
     542:	3a c0       	rjmp	.+116    	; 0x5b8 <mdio_getPinValue+0xb2>
     544:	2c 81       	ldd	r18, Y+4	; 0x04
     546:	3d 81       	ldd	r19, Y+5	; 0x05
     548:	23 30       	cpi	r18, 0x03	; 3
     54a:	31 05       	cpc	r19, r1
     54c:	f1 f0       	breq	.+60     	; 0x58a <mdio_getPinValue+0x84>
     54e:	8c 81       	ldd	r24, Y+4	; 0x04
     550:	9d 81       	ldd	r25, Y+5	; 0x05
     552:	84 30       	cpi	r24, 0x04	; 4
     554:	91 05       	cpc	r25, r1
     556:	29 f1       	breq	.+74     	; 0x5a2 <mdio_getPinValue+0x9c>
     558:	2f c0       	rjmp	.+94     	; 0x5b8 <mdio_getPinValue+0xb2>
	{
	/*in case of choosing PORTA*/
	case PORTA:
		/*checking a specific pin value*/
		if(MDIO_PINA & au8_pin)
     55a:	e9 e3       	ldi	r30, 0x39	; 57
     55c:	f0 e0       	ldi	r31, 0x00	; 0
     55e:	90 81       	ld	r25, Z
     560:	8b 81       	ldd	r24, Y+3	; 0x03
     562:	89 23       	and	r24, r25
     564:	88 23       	and	r24, r24
     566:	19 f0       	breq	.+6      	; 0x56e <mdio_getPinValue+0x68>
		{
			/*setting the pin value to high*/
			au8_pinValue = HIGH;
     568:	81 e0       	ldi	r24, 0x01	; 1
     56a:	89 83       	std	Y+1, r24	; 0x01
     56c:	25 c0       	rjmp	.+74     	; 0x5b8 <mdio_getPinValue+0xb2>
		}
		else
		{
			/*setting the pin value to low*/
			au8_pinValue = LOW;
     56e:	19 82       	std	Y+1, r1	; 0x01
     570:	23 c0       	rjmp	.+70     	; 0x5b8 <mdio_getPinValue+0xb2>
		/*break from this case*/
		break;
	/*in case of choosing PORTB*/
	case PORTB:
		/*checking a specific pin value*/
		if(MDIO_PINB & au8_pin)
     572:	e6 e3       	ldi	r30, 0x36	; 54
     574:	f0 e0       	ldi	r31, 0x00	; 0
     576:	90 81       	ld	r25, Z
     578:	8b 81       	ldd	r24, Y+3	; 0x03
     57a:	89 23       	and	r24, r25
     57c:	88 23       	and	r24, r24
     57e:	19 f0       	breq	.+6      	; 0x586 <mdio_getPinValue+0x80>
		{
			/*setting the pin value to high*/
			au8_pinValue = HIGH;
     580:	81 e0       	ldi	r24, 0x01	; 1
     582:	89 83       	std	Y+1, r24	; 0x01
     584:	19 c0       	rjmp	.+50     	; 0x5b8 <mdio_getPinValue+0xb2>
		}
		else
		{
			/*setting the pin value to low*/
			au8_pinValue = LOW;
     586:	19 82       	std	Y+1, r1	; 0x01
     588:	17 c0       	rjmp	.+46     	; 0x5b8 <mdio_getPinValue+0xb2>
		/*break from this case*/
		break;
	/*in case of choosing PORTC*/
	case PORTC:
		/*checking a specific pin value*/
		if(MDIO_PINC & au8_pin)
     58a:	e3 e3       	ldi	r30, 0x33	; 51
     58c:	f0 e0       	ldi	r31, 0x00	; 0
     58e:	90 81       	ld	r25, Z
     590:	8b 81       	ldd	r24, Y+3	; 0x03
     592:	89 23       	and	r24, r25
     594:	88 23       	and	r24, r24
     596:	19 f0       	breq	.+6      	; 0x59e <mdio_getPinValue+0x98>
		{
			/*setting the pin value to high*/
			au8_pinValue = HIGH;
     598:	81 e0       	ldi	r24, 0x01	; 1
     59a:	89 83       	std	Y+1, r24	; 0x01
     59c:	0d c0       	rjmp	.+26     	; 0x5b8 <mdio_getPinValue+0xb2>
		}
		else
		{
			/*setting the pin value to low*/
			au8_pinValue = LOW;
     59e:	19 82       	std	Y+1, r1	; 0x01
     5a0:	0b c0       	rjmp	.+22     	; 0x5b8 <mdio_getPinValue+0xb2>
		/*break from this case*/
		break;
	/*in case of choosing PORTD*/
	case PORTD:
		/*checking a specific pin value*/
		if(MDIO_PIND & au8_pin)
     5a2:	e0 e3       	ldi	r30, 0x30	; 48
     5a4:	f0 e0       	ldi	r31, 0x00	; 0
     5a6:	90 81       	ld	r25, Z
     5a8:	8b 81       	ldd	r24, Y+3	; 0x03
     5aa:	89 23       	and	r24, r25
     5ac:	88 23       	and	r24, r24
     5ae:	19 f0       	breq	.+6      	; 0x5b6 <mdio_getPinValue+0xb0>
		{
			/*setting the pin value to high*/
			au8_pinValue = HIGH;
     5b0:	81 e0       	ldi	r24, 0x01	; 1
     5b2:	89 83       	std	Y+1, r24	; 0x01
     5b4:	01 c0       	rjmp	.+2      	; 0x5b8 <mdio_getPinValue+0xb2>
		}
		else
		{
			/*setting the pin value to low*/
			au8_pinValue = LOW;
     5b6:	19 82       	std	Y+1, r1	; 0x01
	default:
		/*break from default*/
		break;
	}
	/*Return from this function*/
	return au8_pinValue ;
     5b8:	89 81       	ldd	r24, Y+1	; 0x01
}
     5ba:	0f 90       	pop	r0
     5bc:	0f 90       	pop	r0
     5be:	0f 90       	pop	r0
     5c0:	0f 90       	pop	r0
     5c2:	0f 90       	pop	r0
     5c4:	cf 91       	pop	r28
     5c6:	df 91       	pop	r29
     5c8:	08 95       	ret

000005ca <xEventGroupCreate>:
/*-----------------------------------------------------------*/

#if( configSUPPORT_DYNAMIC_ALLOCATION == 1 )

	EventGroupHandle_t xEventGroupCreate( void )
	{
     5ca:	df 93       	push	r29
     5cc:	cf 93       	push	r28
     5ce:	00 d0       	rcall	.+0      	; 0x5d0 <xEventGroupCreate+0x6>
     5d0:	cd b7       	in	r28, 0x3d	; 61
     5d2:	de b7       	in	r29, 0x3e	; 62
		TickType_t alignment requirements the cast is safe.  In other cases,
		where the natural word size of the architecture is less than
		sizeof( TickType_t ), the TickType_t variables will be accessed in two
		or more reads operations, and the alignment requirements is only that
		of each individual read. */
		pxEventBits = ( EventGroup_t * ) pvPortMalloc( sizeof( EventGroup_t ) ); /*lint !e9087 !e9079 see comment above. */
     5d4:	8b e0       	ldi	r24, 0x0B	; 11
     5d6:	90 e0       	ldi	r25, 0x00	; 0
     5d8:	0e 94 2a 06 	call	0xc54	; 0xc54 <pvPortMalloc>
     5dc:	9a 83       	std	Y+2, r25	; 0x02
     5de:	89 83       	std	Y+1, r24	; 0x01

		if( pxEventBits != NULL )
     5e0:	89 81       	ldd	r24, Y+1	; 0x01
     5e2:	9a 81       	ldd	r25, Y+2	; 0x02
     5e4:	00 97       	sbiw	r24, 0x00	; 0
     5e6:	49 f0       	breq	.+18     	; 0x5fa <xEventGroupCreate+0x30>
		{
			pxEventBits->uxEventBits = 0;
     5e8:	e9 81       	ldd	r30, Y+1	; 0x01
     5ea:	fa 81       	ldd	r31, Y+2	; 0x02
     5ec:	11 82       	std	Z+1, r1	; 0x01
     5ee:	10 82       	st	Z, r1
			vListInitialise( &( pxEventBits->xTasksWaitingForBits ) );
     5f0:	89 81       	ldd	r24, Y+1	; 0x01
     5f2:	9a 81       	ldd	r25, Y+2	; 0x02
     5f4:	02 96       	adiw	r24, 0x02	; 2
     5f6:	0e 94 a6 06 	call	0xd4c	; 0xd4c <vListInitialise>
		else
		{
			traceEVENT_GROUP_CREATE_FAILED(); /*lint !e9063 Else branch only exists to allow tracing and does not generate code if trace macros are not defined. */
		}

		return pxEventBits;
     5fa:	89 81       	ldd	r24, Y+1	; 0x01
     5fc:	9a 81       	ldd	r25, Y+2	; 0x02
	}
     5fe:	0f 90       	pop	r0
     600:	0f 90       	pop	r0
     602:	cf 91       	pop	r28
     604:	df 91       	pop	r29
     606:	08 95       	ret

00000608 <xEventGroupSync>:

#endif /* configSUPPORT_DYNAMIC_ALLOCATION */
/*-----------------------------------------------------------*/

EventBits_t xEventGroupSync( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToSet, const EventBits_t uxBitsToWaitFor, TickType_t xTicksToWait )
{
     608:	df 93       	push	r29
     60a:	cf 93       	push	r28
     60c:	cd b7       	in	r28, 0x3d	; 61
     60e:	de b7       	in	r29, 0x3e	; 62
     610:	60 97       	sbiw	r28, 0x10	; 16
     612:	0f b6       	in	r0, 0x3f	; 63
     614:	f8 94       	cli
     616:	de bf       	out	0x3e, r29	; 62
     618:	0f be       	out	0x3f, r0	; 63
     61a:	cd bf       	out	0x3d, r28	; 61
     61c:	9a 87       	std	Y+10, r25	; 0x0a
     61e:	89 87       	std	Y+9, r24	; 0x09
     620:	7c 87       	std	Y+12, r23	; 0x0c
     622:	6b 87       	std	Y+11, r22	; 0x0b
     624:	5e 87       	std	Y+14, r21	; 0x0e
     626:	4d 87       	std	Y+13, r20	; 0x0d
     628:	38 8b       	std	Y+16, r19	; 0x10
     62a:	2f 87       	std	Y+15, r18	; 0x0f
EventBits_t uxOriginalBitValue, uxReturn;
EventGroup_t *pxEventBits = xEventGroup;
     62c:	89 85       	ldd	r24, Y+9	; 0x09
     62e:	9a 85       	ldd	r25, Y+10	; 0x0a
     630:	9c 83       	std	Y+4, r25	; 0x04
     632:	8b 83       	std	Y+3, r24	; 0x03
BaseType_t xAlreadyYielded;
BaseType_t xTimeoutOccurred = pdFALSE;
     634:	19 82       	std	Y+1, r1	; 0x01
	{
		configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
	}
	#endif

	vTaskSuspendAll();
     636:	0e 94 44 1f 	call	0x3e88	; 0x3e88 <vTaskSuspendAll>
	{
		uxOriginalBitValue = pxEventBits->uxEventBits;
     63a:	eb 81       	ldd	r30, Y+3	; 0x03
     63c:	fc 81       	ldd	r31, Y+4	; 0x04
     63e:	80 81       	ld	r24, Z
     640:	91 81       	ldd	r25, Z+1	; 0x01
     642:	98 87       	std	Y+8, r25	; 0x08
     644:	8f 83       	std	Y+7, r24	; 0x07

		( void ) xEventGroupSetBits( xEventGroup, uxBitsToSet );
     646:	89 85       	ldd	r24, Y+9	; 0x09
     648:	9a 85       	ldd	r25, Y+10	; 0x0a
     64a:	2b 85       	ldd	r18, Y+11	; 0x0b
     64c:	3c 85       	ldd	r19, Y+12	; 0x0c
     64e:	b9 01       	movw	r22, r18
     650:	0e 94 db 04 	call	0x9b6	; 0x9b6 <xEventGroupSetBits>

		if( ( ( uxOriginalBitValue | uxBitsToSet ) & uxBitsToWaitFor ) == uxBitsToWaitFor )
     654:	2f 81       	ldd	r18, Y+7	; 0x07
     656:	38 85       	ldd	r19, Y+8	; 0x08
     658:	8b 85       	ldd	r24, Y+11	; 0x0b
     65a:	9c 85       	ldd	r25, Y+12	; 0x0c
     65c:	28 2b       	or	r18, r24
     65e:	39 2b       	or	r19, r25
     660:	8d 85       	ldd	r24, Y+13	; 0x0d
     662:	9e 85       	ldd	r25, Y+14	; 0x0e
     664:	28 23       	and	r18, r24
     666:	39 23       	and	r19, r25
     668:	8d 85       	ldd	r24, Y+13	; 0x0d
     66a:	9e 85       	ldd	r25, Y+14	; 0x0e
     66c:	28 17       	cp	r18, r24
     66e:	39 07       	cpc	r19, r25
     670:	c9 f4       	brne	.+50     	; 0x6a4 <xEventGroupSync+0x9c>
		{
			/* All the rendezvous bits are now set - no need to block. */
			uxReturn = ( uxOriginalBitValue | uxBitsToSet );
     672:	2f 81       	ldd	r18, Y+7	; 0x07
     674:	38 85       	ldd	r19, Y+8	; 0x08
     676:	8b 85       	ldd	r24, Y+11	; 0x0b
     678:	9c 85       	ldd	r25, Y+12	; 0x0c
     67a:	82 2b       	or	r24, r18
     67c:	93 2b       	or	r25, r19
     67e:	9e 83       	std	Y+6, r25	; 0x06
     680:	8d 83       	std	Y+5, r24	; 0x05

			/* Rendezvous always clear the bits.  They will have been cleared
			already unless this is the only task in the rendezvous. */
			pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
     682:	eb 81       	ldd	r30, Y+3	; 0x03
     684:	fc 81       	ldd	r31, Y+4	; 0x04
     686:	20 81       	ld	r18, Z
     688:	31 81       	ldd	r19, Z+1	; 0x01
     68a:	8d 85       	ldd	r24, Y+13	; 0x0d
     68c:	9e 85       	ldd	r25, Y+14	; 0x0e
     68e:	80 95       	com	r24
     690:	90 95       	com	r25
     692:	82 23       	and	r24, r18
     694:	93 23       	and	r25, r19
     696:	eb 81       	ldd	r30, Y+3	; 0x03
     698:	fc 81       	ldd	r31, Y+4	; 0x04
     69a:	91 83       	std	Z+1, r25	; 0x01
     69c:	80 83       	st	Z, r24

			xTicksToWait = 0;
     69e:	18 8a       	std	Y+16, r1	; 0x10
     6a0:	1f 86       	std	Y+15, r1	; 0x0f
     6a2:	1e c0       	rjmp	.+60     	; 0x6e0 <xEventGroupSync+0xd8>
		}
		else
		{
			if( xTicksToWait != ( TickType_t ) 0 )
     6a4:	8f 85       	ldd	r24, Y+15	; 0x0f
     6a6:	98 89       	ldd	r25, Y+16	; 0x10
     6a8:	00 97       	sbiw	r24, 0x00	; 0
     6aa:	91 f0       	breq	.+36     	; 0x6d0 <xEventGroupSync+0xc8>
				traceEVENT_GROUP_SYNC_BLOCK( xEventGroup, uxBitsToSet, uxBitsToWaitFor );

				/* Store the bits that the calling task is waiting for in the
				task's event list item so the kernel knows when a match is
				found.  Then enter the blocked state. */
				vTaskPlaceOnUnorderedEventList( &( pxEventBits->xTasksWaitingForBits ), ( uxBitsToWaitFor | eventCLEAR_EVENTS_ON_EXIT_BIT | eventWAIT_FOR_ALL_BITS ), xTicksToWait );
     6ac:	8b 81       	ldd	r24, Y+3	; 0x03
     6ae:	9c 81       	ldd	r25, Y+4	; 0x04
     6b0:	bc 01       	movw	r22, r24
     6b2:	6e 5f       	subi	r22, 0xFE	; 254
     6b4:	7f 4f       	sbci	r23, 0xFF	; 255
     6b6:	8d 85       	ldd	r24, Y+13	; 0x0d
     6b8:	9e 85       	ldd	r25, Y+14	; 0x0e
     6ba:	9c 01       	movw	r18, r24
     6bc:	35 60       	ori	r19, 0x05	; 5
     6be:	4f 85       	ldd	r20, Y+15	; 0x0f
     6c0:	58 89       	ldd	r21, Y+16	; 0x10
     6c2:	cb 01       	movw	r24, r22
     6c4:	b9 01       	movw	r22, r18
     6c6:	0e 94 b4 21 	call	0x4368	; 0x4368 <vTaskPlaceOnUnorderedEventList>

				/* This assignment is obsolete as uxReturn will get set after
				the task unblocks, but some compilers mistakenly generate a
				warning about uxReturn being returned without being set if the
				assignment is omitted. */
				uxReturn = 0;
     6ca:	1e 82       	std	Y+6, r1	; 0x06
     6cc:	1d 82       	std	Y+5, r1	; 0x05
     6ce:	08 c0       	rjmp	.+16     	; 0x6e0 <xEventGroupSync+0xd8>
			}
			else
			{
				/* The rendezvous bits were not set, but no block time was
				specified - just return the current event bit value. */
				uxReturn = pxEventBits->uxEventBits;
     6d0:	eb 81       	ldd	r30, Y+3	; 0x03
     6d2:	fc 81       	ldd	r31, Y+4	; 0x04
     6d4:	80 81       	ld	r24, Z
     6d6:	91 81       	ldd	r25, Z+1	; 0x01
     6d8:	9e 83       	std	Y+6, r25	; 0x06
     6da:	8d 83       	std	Y+5, r24	; 0x05
				xTimeoutOccurred = pdTRUE;
     6dc:	81 e0       	ldi	r24, 0x01	; 1
     6de:	89 83       	std	Y+1, r24	; 0x01
			}
		}
	}
	xAlreadyYielded = xTaskResumeAll();
     6e0:	0e 94 50 1f 	call	0x3ea0	; 0x3ea0 <xTaskResumeAll>
     6e4:	8a 83       	std	Y+2, r24	; 0x02

	if( xTicksToWait != ( TickType_t ) 0 )
     6e6:	8f 85       	ldd	r24, Y+15	; 0x0f
     6e8:	98 89       	ldd	r25, Y+16	; 0x10
     6ea:	00 97       	sbiw	r24, 0x00	; 0
     6ec:	09 f4       	brne	.+2      	; 0x6f0 <xEventGroupSync+0xe8>
     6ee:	3a c0       	rjmp	.+116    	; 0x764 <xEventGroupSync+0x15c>
	{
		if( xAlreadyYielded == pdFALSE )
     6f0:	8a 81       	ldd	r24, Y+2	; 0x02
     6f2:	88 23       	and	r24, r24
     6f4:	11 f4       	brne	.+4      	; 0x6fa <xEventGroupSync+0xf2>
		{
			portYIELD_WITHIN_API();
     6f6:	0e 94 3c 0a 	call	0x1478	; 0x1478 <vPortYield>

		/* The task blocked to wait for its required bits to be set - at this
		point either the required bits were set or the block time expired.  If
		the required bits were set they will have been stored in the task's
		event list item, and they should now be retrieved then cleared. */
		uxReturn = uxTaskResetEventItemValue();
     6fa:	0e 94 cc 25 	call	0x4b98	; 0x4b98 <uxTaskResetEventItemValue>
     6fe:	9e 83       	std	Y+6, r25	; 0x06
     700:	8d 83       	std	Y+5, r24	; 0x05

		if( ( uxReturn & eventUNBLOCKED_DUE_TO_BIT_SET ) == ( EventBits_t ) 0 )
     702:	8d 81       	ldd	r24, Y+5	; 0x05
     704:	9e 81       	ldd	r25, Y+6	; 0x06
     706:	80 70       	andi	r24, 0x00	; 0
     708:	92 70       	andi	r25, 0x02	; 2
     70a:	00 97       	sbiw	r24, 0x00	; 0
     70c:	31 f5       	brne	.+76     	; 0x75a <xEventGroupSync+0x152>
		{
			/* The task timed out, just return the current event bit value. */
			taskENTER_CRITICAL();
     70e:	0f b6       	in	r0, 0x3f	; 63
     710:	f8 94       	cli
     712:	0f 92       	push	r0
			{
				uxReturn = pxEventBits->uxEventBits;
     714:	eb 81       	ldd	r30, Y+3	; 0x03
     716:	fc 81       	ldd	r31, Y+4	; 0x04
     718:	80 81       	ld	r24, Z
     71a:	91 81       	ldd	r25, Z+1	; 0x01
     71c:	9e 83       	std	Y+6, r25	; 0x06
     71e:	8d 83       	std	Y+5, r24	; 0x05

				/* Although the task got here because it timed out before the
				bits it was waiting for were set, it is possible that since it
				unblocked another task has set the bits.  If this is the case
				then it needs to clear the bits before exiting. */
				if( ( uxReturn & uxBitsToWaitFor ) == uxBitsToWaitFor )
     720:	2d 81       	ldd	r18, Y+5	; 0x05
     722:	3e 81       	ldd	r19, Y+6	; 0x06
     724:	8d 85       	ldd	r24, Y+13	; 0x0d
     726:	9e 85       	ldd	r25, Y+14	; 0x0e
     728:	28 23       	and	r18, r24
     72a:	39 23       	and	r19, r25
     72c:	8d 85       	ldd	r24, Y+13	; 0x0d
     72e:	9e 85       	ldd	r25, Y+14	; 0x0e
     730:	28 17       	cp	r18, r24
     732:	39 07       	cpc	r19, r25
     734:	71 f4       	brne	.+28     	; 0x752 <xEventGroupSync+0x14a>
				{
					pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
     736:	eb 81       	ldd	r30, Y+3	; 0x03
     738:	fc 81       	ldd	r31, Y+4	; 0x04
     73a:	20 81       	ld	r18, Z
     73c:	31 81       	ldd	r19, Z+1	; 0x01
     73e:	8d 85       	ldd	r24, Y+13	; 0x0d
     740:	9e 85       	ldd	r25, Y+14	; 0x0e
     742:	80 95       	com	r24
     744:	90 95       	com	r25
     746:	82 23       	and	r24, r18
     748:	93 23       	and	r25, r19
     74a:	eb 81       	ldd	r30, Y+3	; 0x03
     74c:	fc 81       	ldd	r31, Y+4	; 0x04
     74e:	91 83       	std	Z+1, r25	; 0x01
     750:	80 83       	st	Z, r24
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}
			}
			taskEXIT_CRITICAL();
     752:	0f 90       	pop	r0
     754:	0f be       	out	0x3f, r0	; 63

			xTimeoutOccurred = pdTRUE;
     756:	81 e0       	ldi	r24, 0x01	; 1
     758:	89 83       	std	Y+1, r24	; 0x01
			/* The task unblocked because the bits were set. */
		}

		/* Control bits might be set as the task had blocked should not be
		returned. */
		uxReturn &= ~eventEVENT_BITS_CONTROL_BYTES;
     75a:	8d 81       	ldd	r24, Y+5	; 0x05
     75c:	9e 81       	ldd	r25, Y+6	; 0x06
     75e:	90 70       	andi	r25, 0x00	; 0
     760:	9e 83       	std	Y+6, r25	; 0x06
     762:	8d 83       	std	Y+5, r24	; 0x05
	traceEVENT_GROUP_SYNC_END( xEventGroup, uxBitsToSet, uxBitsToWaitFor, xTimeoutOccurred );

	/* Prevent compiler warnings when trace macros are not used. */
	( void ) xTimeoutOccurred;

	return uxReturn;
     764:	8d 81       	ldd	r24, Y+5	; 0x05
     766:	9e 81       	ldd	r25, Y+6	; 0x06
}
     768:	60 96       	adiw	r28, 0x10	; 16
     76a:	0f b6       	in	r0, 0x3f	; 63
     76c:	f8 94       	cli
     76e:	de bf       	out	0x3e, r29	; 62
     770:	0f be       	out	0x3f, r0	; 63
     772:	cd bf       	out	0x3d, r28	; 61
     774:	cf 91       	pop	r28
     776:	df 91       	pop	r29
     778:	08 95       	ret

0000077a <xEventGroupWaitBits>:
/*-----------------------------------------------------------*/

EventBits_t xEventGroupWaitBits( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToWaitFor, const BaseType_t xClearOnExit, const BaseType_t xWaitForAllBits, TickType_t xTicksToWait )
{
     77a:	0f 93       	push	r16
     77c:	1f 93       	push	r17
     77e:	df 93       	push	r29
     780:	cf 93       	push	r28
     782:	cd b7       	in	r28, 0x3d	; 61
     784:	de b7       	in	r29, 0x3e	; 62
     786:	63 97       	sbiw	r28, 0x13	; 19
     788:	0f b6       	in	r0, 0x3f	; 63
     78a:	f8 94       	cli
     78c:	de bf       	out	0x3e, r29	; 62
     78e:	0f be       	out	0x3f, r0	; 63
     790:	cd bf       	out	0x3d, r28	; 61
     792:	9d 87       	std	Y+13, r25	; 0x0d
     794:	8c 87       	std	Y+12, r24	; 0x0c
     796:	7f 87       	std	Y+15, r23	; 0x0f
     798:	6e 87       	std	Y+14, r22	; 0x0e
     79a:	48 8b       	std	Y+16, r20	; 0x10
     79c:	29 8b       	std	Y+17, r18	; 0x11
     79e:	1b 8b       	std	Y+19, r17	; 0x13
     7a0:	0a 8b       	std	Y+18, r16	; 0x12
EventGroup_t *pxEventBits = xEventGroup;
     7a2:	8c 85       	ldd	r24, Y+12	; 0x0c
     7a4:	9d 85       	ldd	r25, Y+13	; 0x0d
     7a6:	9b 87       	std	Y+11, r25	; 0x0b
     7a8:	8a 87       	std	Y+10, r24	; 0x0a
EventBits_t uxReturn, uxControlBits = 0;
     7aa:	1f 82       	std	Y+7, r1	; 0x07
     7ac:	1e 82       	std	Y+6, r1	; 0x06
BaseType_t xWaitConditionMet, xAlreadyYielded;
BaseType_t xTimeoutOccurred = pdFALSE;
     7ae:	1b 82       	std	Y+3, r1	; 0x03
	{
		configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
	}
	#endif

	vTaskSuspendAll();
     7b0:	0e 94 44 1f 	call	0x3e88	; 0x3e88 <vTaskSuspendAll>
	{
		const EventBits_t uxCurrentEventBits = pxEventBits->uxEventBits;
     7b4:	ea 85       	ldd	r30, Y+10	; 0x0a
     7b6:	fb 85       	ldd	r31, Y+11	; 0x0b
     7b8:	80 81       	ld	r24, Z
     7ba:	91 81       	ldd	r25, Z+1	; 0x01
     7bc:	9a 83       	std	Y+2, r25	; 0x02
     7be:	89 83       	std	Y+1, r24	; 0x01

		/* Check to see if the wait condition is already met or not. */
		xWaitConditionMet = prvTestWaitCondition( uxCurrentEventBits, uxBitsToWaitFor, xWaitForAllBits );
     7c0:	89 81       	ldd	r24, Y+1	; 0x01
     7c2:	9a 81       	ldd	r25, Y+2	; 0x02
     7c4:	2e 85       	ldd	r18, Y+14	; 0x0e
     7c6:	3f 85       	ldd	r19, Y+15	; 0x0f
     7c8:	b9 01       	movw	r22, r18
     7ca:	49 89       	ldd	r20, Y+17	; 0x11
     7cc:	0e 94 f8 05 	call	0xbf0	; 0xbf0 <prvTestWaitCondition>
     7d0:	8d 83       	std	Y+5, r24	; 0x05

		if( xWaitConditionMet != pdFALSE )
     7d2:	8d 81       	ldd	r24, Y+5	; 0x05
     7d4:	88 23       	and	r24, r24
     7d6:	c1 f0       	breq	.+48     	; 0x808 <xEventGroupWaitBits+0x8e>
		{
			/* The wait condition has already been met so there is no need to
			block. */
			uxReturn = uxCurrentEventBits;
     7d8:	89 81       	ldd	r24, Y+1	; 0x01
     7da:	9a 81       	ldd	r25, Y+2	; 0x02
     7dc:	99 87       	std	Y+9, r25	; 0x09
     7de:	88 87       	std	Y+8, r24	; 0x08
			xTicksToWait = ( TickType_t ) 0;
     7e0:	1b 8a       	std	Y+19, r1	; 0x13
     7e2:	1a 8a       	std	Y+18, r1	; 0x12

			/* Clear the wait bits if requested to do so. */
			if( xClearOnExit != pdFALSE )
     7e4:	88 89       	ldd	r24, Y+16	; 0x10
     7e6:	88 23       	and	r24, r24
     7e8:	e9 f1       	breq	.+122    	; 0x864 <__stack+0x5>
			{
				pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
     7ea:	ea 85       	ldd	r30, Y+10	; 0x0a
     7ec:	fb 85       	ldd	r31, Y+11	; 0x0b
     7ee:	20 81       	ld	r18, Z
     7f0:	31 81       	ldd	r19, Z+1	; 0x01
     7f2:	8e 85       	ldd	r24, Y+14	; 0x0e
     7f4:	9f 85       	ldd	r25, Y+15	; 0x0f
     7f6:	80 95       	com	r24
     7f8:	90 95       	com	r25
     7fa:	82 23       	and	r24, r18
     7fc:	93 23       	and	r25, r19
     7fe:	ea 85       	ldd	r30, Y+10	; 0x0a
     800:	fb 85       	ldd	r31, Y+11	; 0x0b
     802:	91 83       	std	Z+1, r25	; 0x01
     804:	80 83       	st	Z, r24
     806:	2e c0       	rjmp	.+92     	; 0x864 <__stack+0x5>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		else if( xTicksToWait == ( TickType_t ) 0 )
     808:	8a 89       	ldd	r24, Y+18	; 0x12
     80a:	9b 89       	ldd	r25, Y+19	; 0x13
     80c:	00 97       	sbiw	r24, 0x00	; 0
     80e:	39 f4       	brne	.+14     	; 0x81e <xEventGroupWaitBits+0xa4>
		{
			/* The wait condition has not been met, but no block time was
			specified, so just return the current value. */
			uxReturn = uxCurrentEventBits;
     810:	89 81       	ldd	r24, Y+1	; 0x01
     812:	9a 81       	ldd	r25, Y+2	; 0x02
     814:	99 87       	std	Y+9, r25	; 0x09
     816:	88 87       	std	Y+8, r24	; 0x08
			xTimeoutOccurred = pdTRUE;
     818:	81 e0       	ldi	r24, 0x01	; 1
     81a:	8b 83       	std	Y+3, r24	; 0x03
     81c:	23 c0       	rjmp	.+70     	; 0x864 <__stack+0x5>
		{
			/* The task is going to block to wait for its required bits to be
			set.  uxControlBits are used to remember the specified behaviour of
			this call to xEventGroupWaitBits() - for use when the event bits
			unblock the task. */
			if( xClearOnExit != pdFALSE )
     81e:	88 89       	ldd	r24, Y+16	; 0x10
     820:	88 23       	and	r24, r24
     822:	29 f0       	breq	.+10     	; 0x82e <xEventGroupWaitBits+0xb4>
			{
				uxControlBits |= eventCLEAR_EVENTS_ON_EXIT_BIT;
     824:	8e 81       	ldd	r24, Y+6	; 0x06
     826:	9f 81       	ldd	r25, Y+7	; 0x07
     828:	91 60       	ori	r25, 0x01	; 1
     82a:	9f 83       	std	Y+7, r25	; 0x07
     82c:	8e 83       	std	Y+6, r24	; 0x06
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}

			if( xWaitForAllBits != pdFALSE )
     82e:	89 89       	ldd	r24, Y+17	; 0x11
     830:	88 23       	and	r24, r24
     832:	29 f0       	breq	.+10     	; 0x83e <xEventGroupWaitBits+0xc4>
			{
				uxControlBits |= eventWAIT_FOR_ALL_BITS;
     834:	8e 81       	ldd	r24, Y+6	; 0x06
     836:	9f 81       	ldd	r25, Y+7	; 0x07
     838:	94 60       	ori	r25, 0x04	; 4
     83a:	9f 83       	std	Y+7, r25	; 0x07
     83c:	8e 83       	std	Y+6, r24	; 0x06
			}

			/* Store the bits that the calling task is waiting for in the
			task's event list item so the kernel knows when a match is
			found.  Then enter the blocked state. */
			vTaskPlaceOnUnorderedEventList( &( pxEventBits->xTasksWaitingForBits ), ( uxBitsToWaitFor | uxControlBits ), xTicksToWait );
     83e:	8a 85       	ldd	r24, Y+10	; 0x0a
     840:	9b 85       	ldd	r25, Y+11	; 0x0b
     842:	bc 01       	movw	r22, r24
     844:	6e 5f       	subi	r22, 0xFE	; 254
     846:	7f 4f       	sbci	r23, 0xFF	; 255
     848:	2e 85       	ldd	r18, Y+14	; 0x0e
     84a:	3f 85       	ldd	r19, Y+15	; 0x0f
     84c:	8e 81       	ldd	r24, Y+6	; 0x06
     84e:	9f 81       	ldd	r25, Y+7	; 0x07
     850:	28 2b       	or	r18, r24
     852:	39 2b       	or	r19, r25
     854:	4a 89       	ldd	r20, Y+18	; 0x12
     856:	5b 89       	ldd	r21, Y+19	; 0x13
     858:	cb 01       	movw	r24, r22
     85a:	b9 01       	movw	r22, r18
     85c:	0e 94 b4 21 	call	0x4368	; 0x4368 <vTaskPlaceOnUnorderedEventList>

			/* This is obsolete as it will get set after the task unblocks, but
			some compilers mistakenly generate a warning about the variable
			being returned without being set if it is not done. */
			uxReturn = 0;
     860:	19 86       	std	Y+9, r1	; 0x09
     862:	18 86       	std	Y+8, r1	; 0x08

			traceEVENT_GROUP_WAIT_BITS_BLOCK( xEventGroup, uxBitsToWaitFor );
		}
	}
	xAlreadyYielded = xTaskResumeAll();
     864:	0e 94 50 1f 	call	0x3ea0	; 0x3ea0 <xTaskResumeAll>
     868:	8c 83       	std	Y+4, r24	; 0x04

	if( xTicksToWait != ( TickType_t ) 0 )
     86a:	8a 89       	ldd	r24, Y+18	; 0x12
     86c:	9b 89       	ldd	r25, Y+19	; 0x13
     86e:	00 97       	sbiw	r24, 0x00	; 0
     870:	09 f4       	brne	.+2      	; 0x874 <__stack+0x15>
     872:	3c c0       	rjmp	.+120    	; 0x8ec <__stack+0x8d>
	{
		if( xAlreadyYielded == pdFALSE )
     874:	8c 81       	ldd	r24, Y+4	; 0x04
     876:	88 23       	and	r24, r24
     878:	11 f4       	brne	.+4      	; 0x87e <__stack+0x1f>
		{
			portYIELD_WITHIN_API();
     87a:	0e 94 3c 0a 	call	0x1478	; 0x1478 <vPortYield>

		/* The task blocked to wait for its required bits to be set - at this
		point either the required bits were set or the block time expired.  If
		the required bits were set they will have been stored in the task's
		event list item, and they should now be retrieved then cleared. */
		uxReturn = uxTaskResetEventItemValue();
     87e:	0e 94 cc 25 	call	0x4b98	; 0x4b98 <uxTaskResetEventItemValue>
     882:	99 87       	std	Y+9, r25	; 0x09
     884:	88 87       	std	Y+8, r24	; 0x08

		if( ( uxReturn & eventUNBLOCKED_DUE_TO_BIT_SET ) == ( EventBits_t ) 0 )
     886:	88 85       	ldd	r24, Y+8	; 0x08
     888:	99 85       	ldd	r25, Y+9	; 0x09
     88a:	80 70       	andi	r24, 0x00	; 0
     88c:	92 70       	andi	r25, 0x02	; 2
     88e:	00 97       	sbiw	r24, 0x00	; 0
     890:	41 f5       	brne	.+80     	; 0x8e2 <__stack+0x83>
		{
			taskENTER_CRITICAL();
     892:	0f b6       	in	r0, 0x3f	; 63
     894:	f8 94       	cli
     896:	0f 92       	push	r0
			{
				/* The task timed out, just return the current event bit value. */
				uxReturn = pxEventBits->uxEventBits;
     898:	ea 85       	ldd	r30, Y+10	; 0x0a
     89a:	fb 85       	ldd	r31, Y+11	; 0x0b
     89c:	80 81       	ld	r24, Z
     89e:	91 81       	ldd	r25, Z+1	; 0x01
     8a0:	99 87       	std	Y+9, r25	; 0x09
     8a2:	88 87       	std	Y+8, r24	; 0x08

				/* It is possible that the event bits were updated between this
				task leaving the Blocked state and running again. */
				if( prvTestWaitCondition( uxReturn, uxBitsToWaitFor, xWaitForAllBits ) != pdFALSE )
     8a4:	88 85       	ldd	r24, Y+8	; 0x08
     8a6:	99 85       	ldd	r25, Y+9	; 0x09
     8a8:	2e 85       	ldd	r18, Y+14	; 0x0e
     8aa:	3f 85       	ldd	r19, Y+15	; 0x0f
     8ac:	b9 01       	movw	r22, r18
     8ae:	49 89       	ldd	r20, Y+17	; 0x11
     8b0:	0e 94 f8 05 	call	0xbf0	; 0xbf0 <prvTestWaitCondition>
     8b4:	88 23       	and	r24, r24
     8b6:	89 f0       	breq	.+34     	; 0x8da <__stack+0x7b>
				{
					if( xClearOnExit != pdFALSE )
     8b8:	88 89       	ldd	r24, Y+16	; 0x10
     8ba:	88 23       	and	r24, r24
     8bc:	71 f0       	breq	.+28     	; 0x8da <__stack+0x7b>
					{
						pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
     8be:	ea 85       	ldd	r30, Y+10	; 0x0a
     8c0:	fb 85       	ldd	r31, Y+11	; 0x0b
     8c2:	20 81       	ld	r18, Z
     8c4:	31 81       	ldd	r19, Z+1	; 0x01
     8c6:	8e 85       	ldd	r24, Y+14	; 0x0e
     8c8:	9f 85       	ldd	r25, Y+15	; 0x0f
     8ca:	80 95       	com	r24
     8cc:	90 95       	com	r25
     8ce:	82 23       	and	r24, r18
     8d0:	93 23       	and	r25, r19
     8d2:	ea 85       	ldd	r30, Y+10	; 0x0a
     8d4:	fb 85       	ldd	r31, Y+11	; 0x0b
     8d6:	91 83       	std	Z+1, r25	; 0x01
     8d8:	80 83       	st	Z, r24
				}
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}
				xTimeoutOccurred = pdTRUE;
     8da:	81 e0       	ldi	r24, 0x01	; 1
     8dc:	8b 83       	std	Y+3, r24	; 0x03
			}
			taskEXIT_CRITICAL();
     8de:	0f 90       	pop	r0
     8e0:	0f be       	out	0x3f, r0	; 63
		{
			/* The task unblocked because the bits were set. */
		}

		/* The task blocked so control bits may have been set. */
		uxReturn &= ~eventEVENT_BITS_CONTROL_BYTES;
     8e2:	88 85       	ldd	r24, Y+8	; 0x08
     8e4:	99 85       	ldd	r25, Y+9	; 0x09
     8e6:	90 70       	andi	r25, 0x00	; 0
     8e8:	99 87       	std	Y+9, r25	; 0x09
     8ea:	88 87       	std	Y+8, r24	; 0x08
	traceEVENT_GROUP_WAIT_BITS_END( xEventGroup, uxBitsToWaitFor, xTimeoutOccurred );

	/* Prevent compiler warnings when trace macros are not used. */
	( void ) xTimeoutOccurred;

	return uxReturn;
     8ec:	88 85       	ldd	r24, Y+8	; 0x08
     8ee:	99 85       	ldd	r25, Y+9	; 0x09
}
     8f0:	63 96       	adiw	r28, 0x13	; 19
     8f2:	0f b6       	in	r0, 0x3f	; 63
     8f4:	f8 94       	cli
     8f6:	de bf       	out	0x3e, r29	; 62
     8f8:	0f be       	out	0x3f, r0	; 63
     8fa:	cd bf       	out	0x3d, r28	; 61
     8fc:	cf 91       	pop	r28
     8fe:	df 91       	pop	r29
     900:	1f 91       	pop	r17
     902:	0f 91       	pop	r16
     904:	08 95       	ret

00000906 <xEventGroupClearBits>:
/*-----------------------------------------------------------*/

EventBits_t xEventGroupClearBits( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToClear )
{
     906:	df 93       	push	r29
     908:	cf 93       	push	r28
     90a:	cd b7       	in	r28, 0x3d	; 61
     90c:	de b7       	in	r29, 0x3e	; 62
     90e:	28 97       	sbiw	r28, 0x08	; 8
     910:	0f b6       	in	r0, 0x3f	; 63
     912:	f8 94       	cli
     914:	de bf       	out	0x3e, r29	; 62
     916:	0f be       	out	0x3f, r0	; 63
     918:	cd bf       	out	0x3d, r28	; 61
     91a:	9e 83       	std	Y+6, r25	; 0x06
     91c:	8d 83       	std	Y+5, r24	; 0x05
     91e:	78 87       	std	Y+8, r23	; 0x08
     920:	6f 83       	std	Y+7, r22	; 0x07
EventGroup_t *pxEventBits = xEventGroup;
     922:	8d 81       	ldd	r24, Y+5	; 0x05
     924:	9e 81       	ldd	r25, Y+6	; 0x06
     926:	9c 83       	std	Y+4, r25	; 0x04
     928:	8b 83       	std	Y+3, r24	; 0x03
	/* Check the user is not attempting to clear the bits used by the kernel
	itself. */
	configASSERT( xEventGroup );
	configASSERT( ( uxBitsToClear & eventEVENT_BITS_CONTROL_BYTES ) == 0 );

	taskENTER_CRITICAL();
     92a:	0f b6       	in	r0, 0x3f	; 63
     92c:	f8 94       	cli
     92e:	0f 92       	push	r0
	{
		traceEVENT_GROUP_CLEAR_BITS( xEventGroup, uxBitsToClear );

		/* The value returned is the event group value prior to the bits being
		cleared. */
		uxReturn = pxEventBits->uxEventBits;
     930:	eb 81       	ldd	r30, Y+3	; 0x03
     932:	fc 81       	ldd	r31, Y+4	; 0x04
     934:	80 81       	ld	r24, Z
     936:	91 81       	ldd	r25, Z+1	; 0x01
     938:	9a 83       	std	Y+2, r25	; 0x02
     93a:	89 83       	std	Y+1, r24	; 0x01

		/* Clear the bits. */
		pxEventBits->uxEventBits &= ~uxBitsToClear;
     93c:	eb 81       	ldd	r30, Y+3	; 0x03
     93e:	fc 81       	ldd	r31, Y+4	; 0x04
     940:	20 81       	ld	r18, Z
     942:	31 81       	ldd	r19, Z+1	; 0x01
     944:	8f 81       	ldd	r24, Y+7	; 0x07
     946:	98 85       	ldd	r25, Y+8	; 0x08
     948:	80 95       	com	r24
     94a:	90 95       	com	r25
     94c:	82 23       	and	r24, r18
     94e:	93 23       	and	r25, r19
     950:	eb 81       	ldd	r30, Y+3	; 0x03
     952:	fc 81       	ldd	r31, Y+4	; 0x04
     954:	91 83       	std	Z+1, r25	; 0x01
     956:	80 83       	st	Z, r24
	}
	taskEXIT_CRITICAL();
     958:	0f 90       	pop	r0
     95a:	0f be       	out	0x3f, r0	; 63

	return uxReturn;
     95c:	89 81       	ldd	r24, Y+1	; 0x01
     95e:	9a 81       	ldd	r25, Y+2	; 0x02
}
     960:	28 96       	adiw	r28, 0x08	; 8
     962:	0f b6       	in	r0, 0x3f	; 63
     964:	f8 94       	cli
     966:	de bf       	out	0x3e, r29	; 62
     968:	0f be       	out	0x3f, r0	; 63
     96a:	cd bf       	out	0x3d, r28	; 61
     96c:	cf 91       	pop	r28
     96e:	df 91       	pop	r29
     970:	08 95       	ret

00000972 <xEventGroupGetBitsFromISR>:

#endif
/*-----------------------------------------------------------*/

EventBits_t xEventGroupGetBitsFromISR( EventGroupHandle_t xEventGroup )
{
     972:	df 93       	push	r29
     974:	cf 93       	push	r28
     976:	cd b7       	in	r28, 0x3d	; 61
     978:	de b7       	in	r29, 0x3e	; 62
     97a:	27 97       	sbiw	r28, 0x07	; 7
     97c:	0f b6       	in	r0, 0x3f	; 63
     97e:	f8 94       	cli
     980:	de bf       	out	0x3e, r29	; 62
     982:	0f be       	out	0x3f, r0	; 63
     984:	cd bf       	out	0x3d, r28	; 61
     986:	9f 83       	std	Y+7, r25	; 0x07
     988:	8e 83       	std	Y+6, r24	; 0x06
UBaseType_t uxSavedInterruptStatus;
EventGroup_t const * const pxEventBits = xEventGroup;
     98a:	8e 81       	ldd	r24, Y+6	; 0x06
     98c:	9f 81       	ldd	r25, Y+7	; 0x07
     98e:	9c 83       	std	Y+4, r25	; 0x04
     990:	8b 83       	std	Y+3, r24	; 0x03
EventBits_t uxReturn;

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
     992:	1d 82       	std	Y+5, r1	; 0x05
	{
		uxReturn = pxEventBits->uxEventBits;
     994:	eb 81       	ldd	r30, Y+3	; 0x03
     996:	fc 81       	ldd	r31, Y+4	; 0x04
     998:	80 81       	ld	r24, Z
     99a:	91 81       	ldd	r25, Z+1	; 0x01
     99c:	9a 83       	std	Y+2, r25	; 0x02
     99e:	89 83       	std	Y+1, r24	; 0x01
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return uxReturn;
     9a0:	89 81       	ldd	r24, Y+1	; 0x01
     9a2:	9a 81       	ldd	r25, Y+2	; 0x02
} /*lint !e818 EventGroupHandle_t is a typedef used in other functions to so can't be pointer to const. */
     9a4:	27 96       	adiw	r28, 0x07	; 7
     9a6:	0f b6       	in	r0, 0x3f	; 63
     9a8:	f8 94       	cli
     9aa:	de bf       	out	0x3e, r29	; 62
     9ac:	0f be       	out	0x3f, r0	; 63
     9ae:	cd bf       	out	0x3d, r28	; 61
     9b0:	cf 91       	pop	r28
     9b2:	df 91       	pop	r29
     9b4:	08 95       	ret

000009b6 <xEventGroupSetBits>:
/*-----------------------------------------------------------*/

EventBits_t xEventGroupSetBits( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToSet )
{
     9b6:	df 93       	push	r29
     9b8:	cf 93       	push	r28
     9ba:	cd b7       	in	r28, 0x3d	; 61
     9bc:	de b7       	in	r29, 0x3e	; 62
     9be:	65 97       	sbiw	r28, 0x15	; 21
     9c0:	0f b6       	in	r0, 0x3f	; 63
     9c2:	f8 94       	cli
     9c4:	de bf       	out	0x3e, r29	; 62
     9c6:	0f be       	out	0x3f, r0	; 63
     9c8:	cd bf       	out	0x3d, r28	; 61
     9ca:	9b 8b       	std	Y+19, r25	; 0x13
     9cc:	8a 8b       	std	Y+18, r24	; 0x12
     9ce:	7d 8b       	std	Y+21, r23	; 0x15
     9d0:	6c 8b       	std	Y+20, r22	; 0x14
ListItem_t *pxListItem, *pxNext;
ListItem_t const *pxListEnd;
List_t const * pxList;
EventBits_t uxBitsToClear = 0, uxBitsWaitedFor, uxControlBits;
     9d2:	19 86       	std	Y+9, r1	; 0x09
     9d4:	18 86       	std	Y+8, r1	; 0x08
EventGroup_t *pxEventBits = xEventGroup;
     9d6:	8a 89       	ldd	r24, Y+18	; 0x12
     9d8:	9b 89       	ldd	r25, Y+19	; 0x13
     9da:	9b 83       	std	Y+3, r25	; 0x03
     9dc:	8a 83       	std	Y+2, r24	; 0x02
BaseType_t xMatchFound = pdFALSE;
     9de:	19 82       	std	Y+1, r1	; 0x01
	/* Check the user is not attempting to set the bits used by the kernel
	itself. */
	configASSERT( xEventGroup );
	configASSERT( ( uxBitsToSet & eventEVENT_BITS_CONTROL_BYTES ) == 0 );

	pxList = &( pxEventBits->xTasksWaitingForBits );
     9e0:	8a 81       	ldd	r24, Y+2	; 0x02
     9e2:	9b 81       	ldd	r25, Y+3	; 0x03
     9e4:	02 96       	adiw	r24, 0x02	; 2
     9e6:	9b 87       	std	Y+11, r25	; 0x0b
     9e8:	8a 87       	std	Y+10, r24	; 0x0a
	pxListEnd = listGET_END_MARKER( pxList ); /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     9ea:	8a 85       	ldd	r24, Y+10	; 0x0a
     9ec:	9b 85       	ldd	r25, Y+11	; 0x0b
     9ee:	03 96       	adiw	r24, 0x03	; 3
     9f0:	9d 87       	std	Y+13, r25	; 0x0d
     9f2:	8c 87       	std	Y+12, r24	; 0x0c
	vTaskSuspendAll();
     9f4:	0e 94 44 1f 	call	0x3e88	; 0x3e88 <vTaskSuspendAll>
	{
		traceEVENT_GROUP_SET_BITS( xEventGroup, uxBitsToSet );

		pxListItem = listGET_HEAD_ENTRY( pxList );
     9f8:	ea 85       	ldd	r30, Y+10	; 0x0a
     9fa:	fb 85       	ldd	r31, Y+11	; 0x0b
     9fc:	85 81       	ldd	r24, Z+5	; 0x05
     9fe:	96 81       	ldd	r25, Z+6	; 0x06
     a00:	99 8b       	std	Y+17, r25	; 0x11
     a02:	88 8b       	std	Y+16, r24	; 0x10

		/* Set the bits. */
		pxEventBits->uxEventBits |= uxBitsToSet;
     a04:	ea 81       	ldd	r30, Y+2	; 0x02
     a06:	fb 81       	ldd	r31, Y+3	; 0x03
     a08:	20 81       	ld	r18, Z
     a0a:	31 81       	ldd	r19, Z+1	; 0x01
     a0c:	8c 89       	ldd	r24, Y+20	; 0x14
     a0e:	9d 89       	ldd	r25, Y+21	; 0x15
     a10:	82 2b       	or	r24, r18
     a12:	93 2b       	or	r25, r19
     a14:	ea 81       	ldd	r30, Y+2	; 0x02
     a16:	fb 81       	ldd	r31, Y+3	; 0x03
     a18:	91 83       	std	Z+1, r25	; 0x01
     a1a:	80 83       	st	Z, r24
     a1c:	59 c0       	rjmp	.+178    	; 0xad0 <xEventGroupSetBits+0x11a>

		/* See if the new bit value should unblock any tasks. */
		while( pxListItem != pxListEnd )
		{
			pxNext = listGET_NEXT( pxListItem );
     a1e:	e8 89       	ldd	r30, Y+16	; 0x10
     a20:	f9 89       	ldd	r31, Y+17	; 0x11
     a22:	82 81       	ldd	r24, Z+2	; 0x02
     a24:	93 81       	ldd	r25, Z+3	; 0x03
     a26:	9f 87       	std	Y+15, r25	; 0x0f
     a28:	8e 87       	std	Y+14, r24	; 0x0e
			uxBitsWaitedFor = listGET_LIST_ITEM_VALUE( pxListItem );
     a2a:	e8 89       	ldd	r30, Y+16	; 0x10
     a2c:	f9 89       	ldd	r31, Y+17	; 0x11
     a2e:	80 81       	ld	r24, Z
     a30:	91 81       	ldd	r25, Z+1	; 0x01
     a32:	9f 83       	std	Y+7, r25	; 0x07
     a34:	8e 83       	std	Y+6, r24	; 0x06
			xMatchFound = pdFALSE;
     a36:	19 82       	std	Y+1, r1	; 0x01

			/* Split the bits waited for from the control bits. */
			uxControlBits = uxBitsWaitedFor & eventEVENT_BITS_CONTROL_BYTES;
     a38:	8e 81       	ldd	r24, Y+6	; 0x06
     a3a:	9f 81       	ldd	r25, Y+7	; 0x07
     a3c:	80 70       	andi	r24, 0x00	; 0
     a3e:	9d 83       	std	Y+5, r25	; 0x05
     a40:	8c 83       	std	Y+4, r24	; 0x04
			uxBitsWaitedFor &= ~eventEVENT_BITS_CONTROL_BYTES;
     a42:	8e 81       	ldd	r24, Y+6	; 0x06
     a44:	9f 81       	ldd	r25, Y+7	; 0x07
     a46:	90 70       	andi	r25, 0x00	; 0
     a48:	9f 83       	std	Y+7, r25	; 0x07
     a4a:	8e 83       	std	Y+6, r24	; 0x06

			if( ( uxControlBits & eventWAIT_FOR_ALL_BITS ) == ( EventBits_t ) 0 )
     a4c:	8c 81       	ldd	r24, Y+4	; 0x04
     a4e:	9d 81       	ldd	r25, Y+5	; 0x05
     a50:	80 70       	andi	r24, 0x00	; 0
     a52:	94 70       	andi	r25, 0x04	; 4
     a54:	00 97       	sbiw	r24, 0x00	; 0
     a56:	69 f4       	brne	.+26     	; 0xa72 <xEventGroupSetBits+0xbc>
			{
				/* Just looking for single bit being set. */
				if( ( uxBitsWaitedFor & pxEventBits->uxEventBits ) != ( EventBits_t ) 0 )
     a58:	ea 81       	ldd	r30, Y+2	; 0x02
     a5a:	fb 81       	ldd	r31, Y+3	; 0x03
     a5c:	20 81       	ld	r18, Z
     a5e:	31 81       	ldd	r19, Z+1	; 0x01
     a60:	8e 81       	ldd	r24, Y+6	; 0x06
     a62:	9f 81       	ldd	r25, Y+7	; 0x07
     a64:	82 23       	and	r24, r18
     a66:	93 23       	and	r25, r19
     a68:	00 97       	sbiw	r24, 0x00	; 0
     a6a:	91 f0       	breq	.+36     	; 0xa90 <xEventGroupSetBits+0xda>
				{
					xMatchFound = pdTRUE;
     a6c:	81 e0       	ldi	r24, 0x01	; 1
     a6e:	89 83       	std	Y+1, r24	; 0x01
     a70:	0f c0       	rjmp	.+30     	; 0xa90 <xEventGroupSetBits+0xda>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}
			}
			else if( ( uxBitsWaitedFor & pxEventBits->uxEventBits ) == uxBitsWaitedFor )
     a72:	ea 81       	ldd	r30, Y+2	; 0x02
     a74:	fb 81       	ldd	r31, Y+3	; 0x03
     a76:	20 81       	ld	r18, Z
     a78:	31 81       	ldd	r19, Z+1	; 0x01
     a7a:	8e 81       	ldd	r24, Y+6	; 0x06
     a7c:	9f 81       	ldd	r25, Y+7	; 0x07
     a7e:	28 23       	and	r18, r24
     a80:	39 23       	and	r19, r25
     a82:	8e 81       	ldd	r24, Y+6	; 0x06
     a84:	9f 81       	ldd	r25, Y+7	; 0x07
     a86:	28 17       	cp	r18, r24
     a88:	39 07       	cpc	r19, r25
     a8a:	11 f4       	brne	.+4      	; 0xa90 <xEventGroupSetBits+0xda>
			{
				/* All bits are set. */
				xMatchFound = pdTRUE;
     a8c:	81 e0       	ldi	r24, 0x01	; 1
     a8e:	89 83       	std	Y+1, r24	; 0x01
			else
			{
				/* Need all bits to be set, but not all the bits were set. */
			}

			if( xMatchFound != pdFALSE )
     a90:	89 81       	ldd	r24, Y+1	; 0x01
     a92:	88 23       	and	r24, r24
     a94:	c9 f0       	breq	.+50     	; 0xac8 <xEventGroupSetBits+0x112>
			{
				/* The bits match.  Should the bits be cleared on exit? */
				if( ( uxControlBits & eventCLEAR_EVENTS_ON_EXIT_BIT ) != ( EventBits_t ) 0 )
     a96:	8c 81       	ldd	r24, Y+4	; 0x04
     a98:	9d 81       	ldd	r25, Y+5	; 0x05
     a9a:	80 70       	andi	r24, 0x00	; 0
     a9c:	91 70       	andi	r25, 0x01	; 1
     a9e:	00 97       	sbiw	r24, 0x00	; 0
     aa0:	41 f0       	breq	.+16     	; 0xab2 <xEventGroupSetBits+0xfc>
				{
					uxBitsToClear |= uxBitsWaitedFor;
     aa2:	88 85       	ldd	r24, Y+8	; 0x08
     aa4:	99 85       	ldd	r25, Y+9	; 0x09
     aa6:	2e 81       	ldd	r18, Y+6	; 0x06
     aa8:	3f 81       	ldd	r19, Y+7	; 0x07
     aaa:	82 2b       	or	r24, r18
     aac:	93 2b       	or	r25, r19
     aae:	99 87       	std	Y+9, r25	; 0x09
     ab0:	88 87       	std	Y+8, r24	; 0x08
				/* Store the actual event flag value in the task's event list
				item before removing the task from the event list.  The
				eventUNBLOCKED_DUE_TO_BIT_SET bit is set so the task knows
				that is was unblocked due to its required bits matching, rather
				than because it timed out. */
				vTaskRemoveFromUnorderedEventList( pxListItem, pxEventBits->uxEventBits | eventUNBLOCKED_DUE_TO_BIT_SET );
     ab2:	ea 81       	ldd	r30, Y+2	; 0x02
     ab4:	fb 81       	ldd	r31, Y+3	; 0x03
     ab6:	80 81       	ld	r24, Z
     ab8:	91 81       	ldd	r25, Z+1	; 0x01
     aba:	9c 01       	movw	r18, r24
     abc:	32 60       	ori	r19, 0x02	; 2
     abe:	88 89       	ldd	r24, Y+16	; 0x10
     ac0:	99 89       	ldd	r25, Y+17	; 0x11
     ac2:	b9 01       	movw	r22, r18
     ac4:	0e 94 4f 22 	call	0x449e	; 0x449e <vTaskRemoveFromUnorderedEventList>
			}

			/* Move onto the next list item.  Note pxListItem->pxNext is not
			used here as the list item may have been removed from the event list
			and inserted into the ready/pending reading list. */
			pxListItem = pxNext;
     ac8:	8e 85       	ldd	r24, Y+14	; 0x0e
     aca:	9f 85       	ldd	r25, Y+15	; 0x0f
     acc:	99 8b       	std	Y+17, r25	; 0x11
     ace:	88 8b       	std	Y+16, r24	; 0x10

		/* Set the bits. */
		pxEventBits->uxEventBits |= uxBitsToSet;

		/* See if the new bit value should unblock any tasks. */
		while( pxListItem != pxListEnd )
     ad0:	28 89       	ldd	r18, Y+16	; 0x10
     ad2:	39 89       	ldd	r19, Y+17	; 0x11
     ad4:	8c 85       	ldd	r24, Y+12	; 0x0c
     ad6:	9d 85       	ldd	r25, Y+13	; 0x0d
     ad8:	28 17       	cp	r18, r24
     ada:	39 07       	cpc	r19, r25
     adc:	09 f0       	breq	.+2      	; 0xae0 <xEventGroupSetBits+0x12a>
     ade:	9f cf       	rjmp	.-194    	; 0xa1e <xEventGroupSetBits+0x68>
			pxListItem = pxNext;
		}

		/* Clear any bits that matched when the eventCLEAR_EVENTS_ON_EXIT_BIT
		bit was set in the control word. */
		pxEventBits->uxEventBits &= ~uxBitsToClear;
     ae0:	ea 81       	ldd	r30, Y+2	; 0x02
     ae2:	fb 81       	ldd	r31, Y+3	; 0x03
     ae4:	20 81       	ld	r18, Z
     ae6:	31 81       	ldd	r19, Z+1	; 0x01
     ae8:	88 85       	ldd	r24, Y+8	; 0x08
     aea:	99 85       	ldd	r25, Y+9	; 0x09
     aec:	80 95       	com	r24
     aee:	90 95       	com	r25
     af0:	82 23       	and	r24, r18
     af2:	93 23       	and	r25, r19
     af4:	ea 81       	ldd	r30, Y+2	; 0x02
     af6:	fb 81       	ldd	r31, Y+3	; 0x03
     af8:	91 83       	std	Z+1, r25	; 0x01
     afa:	80 83       	st	Z, r24
	}
	( void ) xTaskResumeAll();
     afc:	0e 94 50 1f 	call	0x3ea0	; 0x3ea0 <xTaskResumeAll>

	return pxEventBits->uxEventBits;
     b00:	ea 81       	ldd	r30, Y+2	; 0x02
     b02:	fb 81       	ldd	r31, Y+3	; 0x03
     b04:	80 81       	ld	r24, Z
     b06:	91 81       	ldd	r25, Z+1	; 0x01
}
     b08:	65 96       	adiw	r28, 0x15	; 21
     b0a:	0f b6       	in	r0, 0x3f	; 63
     b0c:	f8 94       	cli
     b0e:	de bf       	out	0x3e, r29	; 62
     b10:	0f be       	out	0x3f, r0	; 63
     b12:	cd bf       	out	0x3d, r28	; 61
     b14:	cf 91       	pop	r28
     b16:	df 91       	pop	r29
     b18:	08 95       	ret

00000b1a <vEventGroupDelete>:
/*-----------------------------------------------------------*/

void vEventGroupDelete( EventGroupHandle_t xEventGroup )
{
     b1a:	df 93       	push	r29
     b1c:	cf 93       	push	r28
     b1e:	00 d0       	rcall	.+0      	; 0xb20 <vEventGroupDelete+0x6>
     b20:	00 d0       	rcall	.+0      	; 0xb22 <vEventGroupDelete+0x8>
     b22:	00 d0       	rcall	.+0      	; 0xb24 <vEventGroupDelete+0xa>
     b24:	cd b7       	in	r28, 0x3d	; 61
     b26:	de b7       	in	r29, 0x3e	; 62
     b28:	9e 83       	std	Y+6, r25	; 0x06
     b2a:	8d 83       	std	Y+5, r24	; 0x05
EventGroup_t *pxEventBits = xEventGroup;
     b2c:	8d 81       	ldd	r24, Y+5	; 0x05
     b2e:	9e 81       	ldd	r25, Y+6	; 0x06
     b30:	9c 83       	std	Y+4, r25	; 0x04
     b32:	8b 83       	std	Y+3, r24	; 0x03
const List_t *pxTasksWaitingForBits = &( pxEventBits->xTasksWaitingForBits );
     b34:	8b 81       	ldd	r24, Y+3	; 0x03
     b36:	9c 81       	ldd	r25, Y+4	; 0x04
     b38:	02 96       	adiw	r24, 0x02	; 2
     b3a:	9a 83       	std	Y+2, r25	; 0x02
     b3c:	89 83       	std	Y+1, r24	; 0x01

	vTaskSuspendAll();
     b3e:	0e 94 44 1f 	call	0x3e88	; 0x3e88 <vTaskSuspendAll>
     b42:	08 c0       	rjmp	.+16     	; 0xb54 <vEventGroupDelete+0x3a>
		while( listCURRENT_LIST_LENGTH( pxTasksWaitingForBits ) > ( UBaseType_t ) 0 )
		{
			/* Unblock the task, returning 0 as the event list is being deleted
			and cannot therefore have any bits set. */
			configASSERT( pxTasksWaitingForBits->xListEnd.pxNext != ( const ListItem_t * ) &( pxTasksWaitingForBits->xListEnd ) );
			vTaskRemoveFromUnorderedEventList( pxTasksWaitingForBits->xListEnd.pxNext, eventUNBLOCKED_DUE_TO_BIT_SET );
     b44:	e9 81       	ldd	r30, Y+1	; 0x01
     b46:	fa 81       	ldd	r31, Y+2	; 0x02
     b48:	85 81       	ldd	r24, Z+5	; 0x05
     b4a:	96 81       	ldd	r25, Z+6	; 0x06
     b4c:	60 e0       	ldi	r22, 0x00	; 0
     b4e:	72 e0       	ldi	r23, 0x02	; 2
     b50:	0e 94 4f 22 	call	0x449e	; 0x449e <vTaskRemoveFromUnorderedEventList>

	vTaskSuspendAll();
	{
		traceEVENT_GROUP_DELETE( xEventGroup );

		while( listCURRENT_LIST_LENGTH( pxTasksWaitingForBits ) > ( UBaseType_t ) 0 )
     b54:	e9 81       	ldd	r30, Y+1	; 0x01
     b56:	fa 81       	ldd	r31, Y+2	; 0x02
     b58:	80 81       	ld	r24, Z
     b5a:	88 23       	and	r24, r24
     b5c:	99 f7       	brne	.-26     	; 0xb44 <vEventGroupDelete+0x2a>

		#if( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) )
		{
			/* The event group can only have been allocated dynamically - free
			it again. */
			vPortFree( pxEventBits );
     b5e:	8b 81       	ldd	r24, Y+3	; 0x03
     b60:	9c 81       	ldd	r25, Y+4	; 0x04
     b62:	0e 94 80 06 	call	0xd00	; 0xd00 <vPortFree>
				mtCOVERAGE_TEST_MARKER();
			}
		}
		#endif /* configSUPPORT_DYNAMIC_ALLOCATION */
	}
	( void ) xTaskResumeAll();
     b66:	0e 94 50 1f 	call	0x3ea0	; 0x3ea0 <xTaskResumeAll>
}
     b6a:	26 96       	adiw	r28, 0x06	; 6
     b6c:	0f b6       	in	r0, 0x3f	; 63
     b6e:	f8 94       	cli
     b70:	de bf       	out	0x3e, r29	; 62
     b72:	0f be       	out	0x3f, r0	; 63
     b74:	cd bf       	out	0x3d, r28	; 61
     b76:	cf 91       	pop	r28
     b78:	df 91       	pop	r29
     b7a:	08 95       	ret

00000b7c <vEventGroupSetBitsCallback>:
/*-----------------------------------------------------------*/

/* For internal use only - execute a 'set bits' command that was pended from
an interrupt. */
void vEventGroupSetBitsCallback( void *pvEventGroup, const uint32_t ulBitsToSet )
{
     b7c:	df 93       	push	r29
     b7e:	cf 93       	push	r28
     b80:	00 d0       	rcall	.+0      	; 0xb82 <vEventGroupSetBitsCallback+0x6>
     b82:	00 d0       	rcall	.+0      	; 0xb84 <vEventGroupSetBitsCallback+0x8>
     b84:	00 d0       	rcall	.+0      	; 0xb86 <vEventGroupSetBitsCallback+0xa>
     b86:	cd b7       	in	r28, 0x3d	; 61
     b88:	de b7       	in	r29, 0x3e	; 62
     b8a:	9a 83       	std	Y+2, r25	; 0x02
     b8c:	89 83       	std	Y+1, r24	; 0x01
     b8e:	4b 83       	std	Y+3, r20	; 0x03
     b90:	5c 83       	std	Y+4, r21	; 0x04
     b92:	6d 83       	std	Y+5, r22	; 0x05
     b94:	7e 83       	std	Y+6, r23	; 0x06
	( void ) xEventGroupSetBits( pvEventGroup, ( EventBits_t ) ulBitsToSet ); /*lint !e9079 Can't avoid cast to void* as a generic timer callback prototype. Callback casts back to original type so safe. */
     b96:	89 81       	ldd	r24, Y+1	; 0x01
     b98:	9a 81       	ldd	r25, Y+2	; 0x02
     b9a:	2b 81       	ldd	r18, Y+3	; 0x03
     b9c:	3c 81       	ldd	r19, Y+4	; 0x04
     b9e:	b9 01       	movw	r22, r18
     ba0:	0e 94 db 04 	call	0x9b6	; 0x9b6 <xEventGroupSetBits>
}
     ba4:	26 96       	adiw	r28, 0x06	; 6
     ba6:	0f b6       	in	r0, 0x3f	; 63
     ba8:	f8 94       	cli
     baa:	de bf       	out	0x3e, r29	; 62
     bac:	0f be       	out	0x3f, r0	; 63
     bae:	cd bf       	out	0x3d, r28	; 61
     bb0:	cf 91       	pop	r28
     bb2:	df 91       	pop	r29
     bb4:	08 95       	ret

00000bb6 <vEventGroupClearBitsCallback>:
/*-----------------------------------------------------------*/

/* For internal use only - execute a 'clear bits' command that was pended from
an interrupt. */
void vEventGroupClearBitsCallback( void *pvEventGroup, const uint32_t ulBitsToClear )
{
     bb6:	df 93       	push	r29
     bb8:	cf 93       	push	r28
     bba:	00 d0       	rcall	.+0      	; 0xbbc <vEventGroupClearBitsCallback+0x6>
     bbc:	00 d0       	rcall	.+0      	; 0xbbe <vEventGroupClearBitsCallback+0x8>
     bbe:	00 d0       	rcall	.+0      	; 0xbc0 <vEventGroupClearBitsCallback+0xa>
     bc0:	cd b7       	in	r28, 0x3d	; 61
     bc2:	de b7       	in	r29, 0x3e	; 62
     bc4:	9a 83       	std	Y+2, r25	; 0x02
     bc6:	89 83       	std	Y+1, r24	; 0x01
     bc8:	4b 83       	std	Y+3, r20	; 0x03
     bca:	5c 83       	std	Y+4, r21	; 0x04
     bcc:	6d 83       	std	Y+5, r22	; 0x05
     bce:	7e 83       	std	Y+6, r23	; 0x06
	( void ) xEventGroupClearBits( pvEventGroup, ( EventBits_t ) ulBitsToClear ); /*lint !e9079 Can't avoid cast to void* as a generic timer callback prototype. Callback casts back to original type so safe. */
     bd0:	89 81       	ldd	r24, Y+1	; 0x01
     bd2:	9a 81       	ldd	r25, Y+2	; 0x02
     bd4:	2b 81       	ldd	r18, Y+3	; 0x03
     bd6:	3c 81       	ldd	r19, Y+4	; 0x04
     bd8:	b9 01       	movw	r22, r18
     bda:	0e 94 83 04 	call	0x906	; 0x906 <xEventGroupClearBits>
}
     bde:	26 96       	adiw	r28, 0x06	; 6
     be0:	0f b6       	in	r0, 0x3f	; 63
     be2:	f8 94       	cli
     be4:	de bf       	out	0x3e, r29	; 62
     be6:	0f be       	out	0x3f, r0	; 63
     be8:	cd bf       	out	0x3d, r28	; 61
     bea:	cf 91       	pop	r28
     bec:	df 91       	pop	r29
     bee:	08 95       	ret

00000bf0 <prvTestWaitCondition>:
/*-----------------------------------------------------------*/

static BaseType_t prvTestWaitCondition( const EventBits_t uxCurrentEventBits, const EventBits_t uxBitsToWaitFor, const BaseType_t xWaitForAllBits )
{
     bf0:	df 93       	push	r29
     bf2:	cf 93       	push	r28
     bf4:	00 d0       	rcall	.+0      	; 0xbf6 <prvTestWaitCondition+0x6>
     bf6:	00 d0       	rcall	.+0      	; 0xbf8 <prvTestWaitCondition+0x8>
     bf8:	00 d0       	rcall	.+0      	; 0xbfa <prvTestWaitCondition+0xa>
     bfa:	cd b7       	in	r28, 0x3d	; 61
     bfc:	de b7       	in	r29, 0x3e	; 62
     bfe:	9b 83       	std	Y+3, r25	; 0x03
     c00:	8a 83       	std	Y+2, r24	; 0x02
     c02:	7d 83       	std	Y+5, r23	; 0x05
     c04:	6c 83       	std	Y+4, r22	; 0x04
     c06:	4e 83       	std	Y+6, r20	; 0x06
BaseType_t xWaitConditionMet = pdFALSE;
     c08:	19 82       	std	Y+1, r1	; 0x01

	if( xWaitForAllBits == pdFALSE )
     c0a:	8e 81       	ldd	r24, Y+6	; 0x06
     c0c:	88 23       	and	r24, r24
     c0e:	59 f4       	brne	.+22     	; 0xc26 <prvTestWaitCondition+0x36>
	{
		/* Task only has to wait for one bit within uxBitsToWaitFor to be
		set.  Is one already set? */
		if( ( uxCurrentEventBits & uxBitsToWaitFor ) != ( EventBits_t ) 0 )
     c10:	8a 81       	ldd	r24, Y+2	; 0x02
     c12:	9b 81       	ldd	r25, Y+3	; 0x03
     c14:	2c 81       	ldd	r18, Y+4	; 0x04
     c16:	3d 81       	ldd	r19, Y+5	; 0x05
     c18:	82 23       	and	r24, r18
     c1a:	93 23       	and	r25, r19
     c1c:	00 97       	sbiw	r24, 0x00	; 0
     c1e:	81 f0       	breq	.+32     	; 0xc40 <prvTestWaitCondition+0x50>
		{
			xWaitConditionMet = pdTRUE;
     c20:	81 e0       	ldi	r24, 0x01	; 1
     c22:	89 83       	std	Y+1, r24	; 0x01
     c24:	0d c0       	rjmp	.+26     	; 0xc40 <prvTestWaitCondition+0x50>
	}
	else
	{
		/* Task has to wait for all the bits in uxBitsToWaitFor to be set.
		Are they set already? */
		if( ( uxCurrentEventBits & uxBitsToWaitFor ) == uxBitsToWaitFor )
     c26:	2a 81       	ldd	r18, Y+2	; 0x02
     c28:	3b 81       	ldd	r19, Y+3	; 0x03
     c2a:	8c 81       	ldd	r24, Y+4	; 0x04
     c2c:	9d 81       	ldd	r25, Y+5	; 0x05
     c2e:	28 23       	and	r18, r24
     c30:	39 23       	and	r19, r25
     c32:	8c 81       	ldd	r24, Y+4	; 0x04
     c34:	9d 81       	ldd	r25, Y+5	; 0x05
     c36:	28 17       	cp	r18, r24
     c38:	39 07       	cpc	r19, r25
     c3a:	11 f4       	brne	.+4      	; 0xc40 <prvTestWaitCondition+0x50>
		{
			xWaitConditionMet = pdTRUE;
     c3c:	81 e0       	ldi	r24, 0x01	; 1
     c3e:	89 83       	std	Y+1, r24	; 0x01
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}

	return xWaitConditionMet;
     c40:	89 81       	ldd	r24, Y+1	; 0x01
}
     c42:	26 96       	adiw	r28, 0x06	; 6
     c44:	0f b6       	in	r0, 0x3f	; 63
     c46:	f8 94       	cli
     c48:	de bf       	out	0x3e, r29	; 62
     c4a:	0f be       	out	0x3f, r0	; 63
     c4c:	cd bf       	out	0x3d, r28	; 61
     c4e:	cf 91       	pop	r28
     c50:	df 91       	pop	r29
     c52:	08 95       	ret

00000c54 <pvPortMalloc>:
static size_t xNextFreeByte = ( size_t ) 0;

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
     c54:	df 93       	push	r29
     c56:	cf 93       	push	r28
     c58:	00 d0       	rcall	.+0      	; 0xc5a <pvPortMalloc+0x6>
     c5a:	00 d0       	rcall	.+0      	; 0xc5c <pvPortMalloc+0x8>
     c5c:	cd b7       	in	r28, 0x3d	; 61
     c5e:	de b7       	in	r29, 0x3e	; 62
     c60:	9c 83       	std	Y+4, r25	; 0x04
     c62:	8b 83       	std	Y+3, r24	; 0x03
void *pvReturn = NULL;
     c64:	1a 82       	std	Y+2, r1	; 0x02
     c66:	19 82       	std	Y+1, r1	; 0x01
			xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
		}
	}
	#endif

	vTaskSuspendAll();
     c68:	0e 94 44 1f 	call	0x3e88	; 0x3e88 <vTaskSuspendAll>
	{
		if( pucAlignedHeap == NULL )
     c6c:	80 91 68 00 	lds	r24, 0x0068
     c70:	90 91 69 00 	lds	r25, 0x0069
     c74:	00 97       	sbiw	r24, 0x00	; 0
     c76:	31 f4       	brne	.+12     	; 0xc84 <pvPortMalloc+0x30>
		{
			/* Ensure the heap starts on a correctly aligned boundary. */
			pucAlignedHeap = ( uint8_t * ) ( ( ( portPOINTER_SIZE_TYPE ) &ucHeap[ portBYTE_ALIGNMENT ] ) & ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) );
     c78:	8b e6       	ldi	r24, 0x6B	; 107
     c7a:	90 e0       	ldi	r25, 0x00	; 0
     c7c:	90 93 69 00 	sts	0x0069, r25
     c80:	80 93 68 00 	sts	0x0068, r24
		}

		/* Check there is enough room left for the allocation. */
		if( ( ( xNextFreeByte + xWantedSize ) < configADJUSTED_HEAP_SIZE ) &&
     c84:	80 91 66 00 	lds	r24, 0x0066
     c88:	90 91 67 00 	lds	r25, 0x0067
     c8c:	2b 81       	ldd	r18, Y+3	; 0x03
     c8e:	3c 81       	ldd	r19, Y+4	; 0x04
     c90:	82 0f       	add	r24, r18
     c92:	93 1f       	adc	r25, r19
     c94:	25 e0       	ldi	r18, 0x05	; 5
     c96:	8b 3d       	cpi	r24, 0xDB	; 219
     c98:	92 07       	cpc	r25, r18
     c9a:	38 f5       	brcc	.+78     	; 0xcea <pvPortMalloc+0x96>
     c9c:	20 91 66 00 	lds	r18, 0x0066
     ca0:	30 91 67 00 	lds	r19, 0x0067
     ca4:	8b 81       	ldd	r24, Y+3	; 0x03
     ca6:	9c 81       	ldd	r25, Y+4	; 0x04
     ca8:	28 0f       	add	r18, r24
     caa:	39 1f       	adc	r19, r25
     cac:	80 91 66 00 	lds	r24, 0x0066
     cb0:	90 91 67 00 	lds	r25, 0x0067
     cb4:	82 17       	cp	r24, r18
     cb6:	93 07       	cpc	r25, r19
     cb8:	c0 f4       	brcc	.+48     	; 0xcea <pvPortMalloc+0x96>
			( ( xNextFreeByte + xWantedSize ) > xNextFreeByte )	)/* Check for overflow. */
		{
			/* Return the next free byte then increment the index past this
			block. */
			pvReturn = pucAlignedHeap + xNextFreeByte;
     cba:	20 91 68 00 	lds	r18, 0x0068
     cbe:	30 91 69 00 	lds	r19, 0x0069
     cc2:	80 91 66 00 	lds	r24, 0x0066
     cc6:	90 91 67 00 	lds	r25, 0x0067
     cca:	82 0f       	add	r24, r18
     ccc:	93 1f       	adc	r25, r19
     cce:	9a 83       	std	Y+2, r25	; 0x02
     cd0:	89 83       	std	Y+1, r24	; 0x01
			xNextFreeByte += xWantedSize;
     cd2:	20 91 66 00 	lds	r18, 0x0066
     cd6:	30 91 67 00 	lds	r19, 0x0067
     cda:	8b 81       	ldd	r24, Y+3	; 0x03
     cdc:	9c 81       	ldd	r25, Y+4	; 0x04
     cde:	82 0f       	add	r24, r18
     ce0:	93 1f       	adc	r25, r19
     ce2:	90 93 67 00 	sts	0x0067, r25
     ce6:	80 93 66 00 	sts	0x0066, r24
		}

		traceMALLOC( pvReturn, xWantedSize );
	}
	( void ) xTaskResumeAll();
     cea:	0e 94 50 1f 	call	0x3ea0	; 0x3ea0 <xTaskResumeAll>
			vApplicationMallocFailedHook();
		}
	}
	#endif

	return pvReturn;
     cee:	89 81       	ldd	r24, Y+1	; 0x01
     cf0:	9a 81       	ldd	r25, Y+2	; 0x02
}
     cf2:	0f 90       	pop	r0
     cf4:	0f 90       	pop	r0
     cf6:	0f 90       	pop	r0
     cf8:	0f 90       	pop	r0
     cfa:	cf 91       	pop	r28
     cfc:	df 91       	pop	r29
     cfe:	08 95       	ret

00000d00 <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
     d00:	df 93       	push	r29
     d02:	cf 93       	push	r28
     d04:	00 d0       	rcall	.+0      	; 0xd06 <vPortFree+0x6>
     d06:	cd b7       	in	r28, 0x3d	; 61
     d08:	de b7       	in	r29, 0x3e	; 62
     d0a:	9a 83       	std	Y+2, r25	; 0x02
     d0c:	89 83       	std	Y+1, r24	; 0x01
	http://www.FreeRTOS.org for more information. */
	( void ) pv;

	/* Force an assert as it is invalid to call this function. */
	configASSERT( pv == NULL );
}
     d0e:	0f 90       	pop	r0
     d10:	0f 90       	pop	r0
     d12:	cf 91       	pop	r28
     d14:	df 91       	pop	r29
     d16:	08 95       	ret

00000d18 <vPortInitialiseBlocks>:
/*-----------------------------------------------------------*/

void vPortInitialiseBlocks( void )
{
     d18:	df 93       	push	r29
     d1a:	cf 93       	push	r28
     d1c:	cd b7       	in	r28, 0x3d	; 61
     d1e:	de b7       	in	r29, 0x3e	; 62
	/* Only required when static memory is not cleared. */
	xNextFreeByte = ( size_t ) 0;
     d20:	10 92 67 00 	sts	0x0067, r1
     d24:	10 92 66 00 	sts	0x0066, r1
}
     d28:	cf 91       	pop	r28
     d2a:	df 91       	pop	r29
     d2c:	08 95       	ret

00000d2e <xPortGetFreeHeapSize>:
/*-----------------------------------------------------------*/

size_t xPortGetFreeHeapSize( void )
{
     d2e:	df 93       	push	r29
     d30:	cf 93       	push	r28
     d32:	cd b7       	in	r28, 0x3d	; 61
     d34:	de b7       	in	r29, 0x3e	; 62
	return ( configADJUSTED_HEAP_SIZE - xNextFreeByte );
     d36:	20 91 66 00 	lds	r18, 0x0066
     d3a:	30 91 67 00 	lds	r19, 0x0067
     d3e:	8b ed       	ldi	r24, 0xDB	; 219
     d40:	95 e0       	ldi	r25, 0x05	; 5
     d42:	82 1b       	sub	r24, r18
     d44:	93 0b       	sbc	r25, r19
}
     d46:	cf 91       	pop	r28
     d48:	df 91       	pop	r29
     d4a:	08 95       	ret

00000d4c <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( List_t * const pxList )
{
     d4c:	df 93       	push	r29
     d4e:	cf 93       	push	r28
     d50:	00 d0       	rcall	.+0      	; 0xd52 <vListInitialise+0x6>
     d52:	cd b7       	in	r28, 0x3d	; 61
     d54:	de b7       	in	r29, 0x3e	; 62
     d56:	9a 83       	std	Y+2, r25	; 0x02
     d58:	89 83       	std	Y+1, r24	; 0x01
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );			/*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     d5a:	89 81       	ldd	r24, Y+1	; 0x01
     d5c:	9a 81       	ldd	r25, Y+2	; 0x02
     d5e:	03 96       	adiw	r24, 0x03	; 3
     d60:	e9 81       	ldd	r30, Y+1	; 0x01
     d62:	fa 81       	ldd	r31, Y+2	; 0x02
     d64:	92 83       	std	Z+2, r25	; 0x02
     d66:	81 83       	std	Z+1, r24	; 0x01

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
     d68:	e9 81       	ldd	r30, Y+1	; 0x01
     d6a:	fa 81       	ldd	r31, Y+2	; 0x02
     d6c:	8f ef       	ldi	r24, 0xFF	; 255
     d6e:	9f ef       	ldi	r25, 0xFF	; 255
     d70:	94 83       	std	Z+4, r25	; 0x04
     d72:	83 83       	std	Z+3, r24	; 0x03

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );	/*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     d74:	89 81       	ldd	r24, Y+1	; 0x01
     d76:	9a 81       	ldd	r25, Y+2	; 0x02
     d78:	03 96       	adiw	r24, 0x03	; 3
     d7a:	e9 81       	ldd	r30, Y+1	; 0x01
     d7c:	fa 81       	ldd	r31, Y+2	; 0x02
     d7e:	96 83       	std	Z+6, r25	; 0x06
     d80:	85 83       	std	Z+5, r24	; 0x05
	pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     d82:	89 81       	ldd	r24, Y+1	; 0x01
     d84:	9a 81       	ldd	r25, Y+2	; 0x02
     d86:	03 96       	adiw	r24, 0x03	; 3
     d88:	e9 81       	ldd	r30, Y+1	; 0x01
     d8a:	fa 81       	ldd	r31, Y+2	; 0x02
     d8c:	90 87       	std	Z+8, r25	; 0x08
     d8e:	87 83       	std	Z+7, r24	; 0x07

	pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
     d90:	e9 81       	ldd	r30, Y+1	; 0x01
     d92:	fa 81       	ldd	r31, Y+2	; 0x02
     d94:	10 82       	st	Z, r1

	/* Write known values into the list if
	configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
	listSET_LIST_INTEGRITY_CHECK_1_VALUE( pxList );
	listSET_LIST_INTEGRITY_CHECK_2_VALUE( pxList );
}
     d96:	0f 90       	pop	r0
     d98:	0f 90       	pop	r0
     d9a:	cf 91       	pop	r28
     d9c:	df 91       	pop	r29
     d9e:	08 95       	ret

00000da0 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
     da0:	df 93       	push	r29
     da2:	cf 93       	push	r28
     da4:	00 d0       	rcall	.+0      	; 0xda6 <vListInitialiseItem+0x6>
     da6:	cd b7       	in	r28, 0x3d	; 61
     da8:	de b7       	in	r29, 0x3e	; 62
     daa:	9a 83       	std	Y+2, r25	; 0x02
     dac:	89 83       	std	Y+1, r24	; 0x01
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pxContainer = NULL;
     dae:	e9 81       	ldd	r30, Y+1	; 0x01
     db0:	fa 81       	ldd	r31, Y+2	; 0x02
     db2:	11 86       	std	Z+9, r1	; 0x09
     db4:	10 86       	std	Z+8, r1	; 0x08

	/* Write known values into the list item if
	configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
	listSET_FIRST_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
	listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
}
     db6:	0f 90       	pop	r0
     db8:	0f 90       	pop	r0
     dba:	cf 91       	pop	r28
     dbc:	df 91       	pop	r29
     dbe:	08 95       	ret

00000dc0 <vListInsertEnd>:
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem )
{
     dc0:	df 93       	push	r29
     dc2:	cf 93       	push	r28
     dc4:	00 d0       	rcall	.+0      	; 0xdc6 <vListInsertEnd+0x6>
     dc6:	00 d0       	rcall	.+0      	; 0xdc8 <vListInsertEnd+0x8>
     dc8:	00 d0       	rcall	.+0      	; 0xdca <vListInsertEnd+0xa>
     dca:	cd b7       	in	r28, 0x3d	; 61
     dcc:	de b7       	in	r29, 0x3e	; 62
     dce:	9c 83       	std	Y+4, r25	; 0x04
     dd0:	8b 83       	std	Y+3, r24	; 0x03
     dd2:	7e 83       	std	Y+6, r23	; 0x06
     dd4:	6d 83       	std	Y+5, r22	; 0x05
ListItem_t * const pxIndex = pxList->pxIndex;
     dd6:	eb 81       	ldd	r30, Y+3	; 0x03
     dd8:	fc 81       	ldd	r31, Y+4	; 0x04
     dda:	81 81       	ldd	r24, Z+1	; 0x01
     ddc:	92 81       	ldd	r25, Z+2	; 0x02
     dde:	9a 83       	std	Y+2, r25	; 0x02
     de0:	89 83       	std	Y+1, r24	; 0x01
	listTEST_LIST_ITEM_INTEGRITY( pxNewListItem );

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	listGET_OWNER_OF_NEXT_ENTRY(). */
	pxNewListItem->pxNext = pxIndex;
     de2:	ed 81       	ldd	r30, Y+5	; 0x05
     de4:	fe 81       	ldd	r31, Y+6	; 0x06
     de6:	89 81       	ldd	r24, Y+1	; 0x01
     de8:	9a 81       	ldd	r25, Y+2	; 0x02
     dea:	93 83       	std	Z+3, r25	; 0x03
     dec:	82 83       	std	Z+2, r24	; 0x02
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
     dee:	e9 81       	ldd	r30, Y+1	; 0x01
     df0:	fa 81       	ldd	r31, Y+2	; 0x02
     df2:	84 81       	ldd	r24, Z+4	; 0x04
     df4:	95 81       	ldd	r25, Z+5	; 0x05
     df6:	ed 81       	ldd	r30, Y+5	; 0x05
     df8:	fe 81       	ldd	r31, Y+6	; 0x06
     dfa:	95 83       	std	Z+5, r25	; 0x05
     dfc:	84 83       	std	Z+4, r24	; 0x04

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	pxIndex->pxPrevious->pxNext = pxNewListItem;
     dfe:	e9 81       	ldd	r30, Y+1	; 0x01
     e00:	fa 81       	ldd	r31, Y+2	; 0x02
     e02:	04 80       	ldd	r0, Z+4	; 0x04
     e04:	f5 81       	ldd	r31, Z+5	; 0x05
     e06:	e0 2d       	mov	r30, r0
     e08:	8d 81       	ldd	r24, Y+5	; 0x05
     e0a:	9e 81       	ldd	r25, Y+6	; 0x06
     e0c:	93 83       	std	Z+3, r25	; 0x03
     e0e:	82 83       	std	Z+2, r24	; 0x02
	pxIndex->pxPrevious = pxNewListItem;
     e10:	e9 81       	ldd	r30, Y+1	; 0x01
     e12:	fa 81       	ldd	r31, Y+2	; 0x02
     e14:	8d 81       	ldd	r24, Y+5	; 0x05
     e16:	9e 81       	ldd	r25, Y+6	; 0x06
     e18:	95 83       	std	Z+5, r25	; 0x05
     e1a:	84 83       	std	Z+4, r24	; 0x04

	/* Remember which list the item is in. */
	pxNewListItem->pxContainer = pxList;
     e1c:	ed 81       	ldd	r30, Y+5	; 0x05
     e1e:	fe 81       	ldd	r31, Y+6	; 0x06
     e20:	8b 81       	ldd	r24, Y+3	; 0x03
     e22:	9c 81       	ldd	r25, Y+4	; 0x04
     e24:	91 87       	std	Z+9, r25	; 0x09
     e26:	80 87       	std	Z+8, r24	; 0x08

	( pxList->uxNumberOfItems )++;
     e28:	eb 81       	ldd	r30, Y+3	; 0x03
     e2a:	fc 81       	ldd	r31, Y+4	; 0x04
     e2c:	80 81       	ld	r24, Z
     e2e:	8f 5f       	subi	r24, 0xFF	; 255
     e30:	eb 81       	ldd	r30, Y+3	; 0x03
     e32:	fc 81       	ldd	r31, Y+4	; 0x04
     e34:	80 83       	st	Z, r24
}
     e36:	26 96       	adiw	r28, 0x06	; 6
     e38:	0f b6       	in	r0, 0x3f	; 63
     e3a:	f8 94       	cli
     e3c:	de bf       	out	0x3e, r29	; 62
     e3e:	0f be       	out	0x3f, r0	; 63
     e40:	cd bf       	out	0x3d, r28	; 61
     e42:	cf 91       	pop	r28
     e44:	df 91       	pop	r29
     e46:	08 95       	ret

00000e48 <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem )
{
     e48:	df 93       	push	r29
     e4a:	cf 93       	push	r28
     e4c:	cd b7       	in	r28, 0x3d	; 61
     e4e:	de b7       	in	r29, 0x3e	; 62
     e50:	28 97       	sbiw	r28, 0x08	; 8
     e52:	0f b6       	in	r0, 0x3f	; 63
     e54:	f8 94       	cli
     e56:	de bf       	out	0x3e, r29	; 62
     e58:	0f be       	out	0x3f, r0	; 63
     e5a:	cd bf       	out	0x3d, r28	; 61
     e5c:	9e 83       	std	Y+6, r25	; 0x06
     e5e:	8d 83       	std	Y+5, r24	; 0x05
     e60:	78 87       	std	Y+8, r23	; 0x08
     e62:	6f 83       	std	Y+7, r22	; 0x07
ListItem_t *pxIterator;
const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
     e64:	ef 81       	ldd	r30, Y+7	; 0x07
     e66:	f8 85       	ldd	r31, Y+8	; 0x08
     e68:	80 81       	ld	r24, Z
     e6a:	91 81       	ldd	r25, Z+1	; 0x01
     e6c:	9a 83       	std	Y+2, r25	; 0x02
     e6e:	89 83       	std	Y+1, r24	; 0x01
	new list item should be placed after it.  This ensures that TCBs which are
	stored in ready lists (all of which have the same xItemValue value) get a
	share of the CPU.  However, if the xItemValue is the same as the back marker
	the iteration loop below will not end.  Therefore the value is checked
	first, and the algorithm slightly modified if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
     e70:	89 81       	ldd	r24, Y+1	; 0x01
     e72:	9a 81       	ldd	r25, Y+2	; 0x02
     e74:	2f ef       	ldi	r18, 0xFF	; 255
     e76:	8f 3f       	cpi	r24, 0xFF	; 255
     e78:	92 07       	cpc	r25, r18
     e7a:	39 f4       	brne	.+14     	; 0xe8a <vListInsert+0x42>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
     e7c:	ed 81       	ldd	r30, Y+5	; 0x05
     e7e:	fe 81       	ldd	r31, Y+6	; 0x06
     e80:	87 81       	ldd	r24, Z+7	; 0x07
     e82:	90 85       	ldd	r25, Z+8	; 0x08
     e84:	9c 83       	std	Y+4, r25	; 0x04
     e86:	8b 83       	std	Y+3, r24	; 0x03
     e88:	18 c0       	rjmp	.+48     	; 0xeba <vListInsert+0x72>
			4) Using a queue or semaphore before it has been initialised or
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		**********************************************************************/

		for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. *//*lint !e440 The iterator moves to a different value, not xValueOfInsertion. */
     e8a:	8d 81       	ldd	r24, Y+5	; 0x05
     e8c:	9e 81       	ldd	r25, Y+6	; 0x06
     e8e:	03 96       	adiw	r24, 0x03	; 3
     e90:	9c 83       	std	Y+4, r25	; 0x04
     e92:	8b 83       	std	Y+3, r24	; 0x03
     e94:	06 c0       	rjmp	.+12     	; 0xea2 <vListInsert+0x5a>
     e96:	eb 81       	ldd	r30, Y+3	; 0x03
     e98:	fc 81       	ldd	r31, Y+4	; 0x04
     e9a:	82 81       	ldd	r24, Z+2	; 0x02
     e9c:	93 81       	ldd	r25, Z+3	; 0x03
     e9e:	9c 83       	std	Y+4, r25	; 0x04
     ea0:	8b 83       	std	Y+3, r24	; 0x03
     ea2:	eb 81       	ldd	r30, Y+3	; 0x03
     ea4:	fc 81       	ldd	r31, Y+4	; 0x04
     ea6:	02 80       	ldd	r0, Z+2	; 0x02
     ea8:	f3 81       	ldd	r31, Z+3	; 0x03
     eaa:	e0 2d       	mov	r30, r0
     eac:	20 81       	ld	r18, Z
     eae:	31 81       	ldd	r19, Z+1	; 0x01
     eb0:	89 81       	ldd	r24, Y+1	; 0x01
     eb2:	9a 81       	ldd	r25, Y+2	; 0x02
     eb4:	82 17       	cp	r24, r18
     eb6:	93 07       	cpc	r25, r19
     eb8:	70 f7       	brcc	.-36     	; 0xe96 <vListInsert+0x4e>
			/* There is nothing to do here, just iterating to the wanted
			insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
     eba:	eb 81       	ldd	r30, Y+3	; 0x03
     ebc:	fc 81       	ldd	r31, Y+4	; 0x04
     ebe:	82 81       	ldd	r24, Z+2	; 0x02
     ec0:	93 81       	ldd	r25, Z+3	; 0x03
     ec2:	ef 81       	ldd	r30, Y+7	; 0x07
     ec4:	f8 85       	ldd	r31, Y+8	; 0x08
     ec6:	93 83       	std	Z+3, r25	; 0x03
     ec8:	82 83       	std	Z+2, r24	; 0x02
	pxNewListItem->pxNext->pxPrevious = pxNewListItem;
     eca:	ef 81       	ldd	r30, Y+7	; 0x07
     ecc:	f8 85       	ldd	r31, Y+8	; 0x08
     ece:	02 80       	ldd	r0, Z+2	; 0x02
     ed0:	f3 81       	ldd	r31, Z+3	; 0x03
     ed2:	e0 2d       	mov	r30, r0
     ed4:	8f 81       	ldd	r24, Y+7	; 0x07
     ed6:	98 85       	ldd	r25, Y+8	; 0x08
     ed8:	95 83       	std	Z+5, r25	; 0x05
     eda:	84 83       	std	Z+4, r24	; 0x04
	pxNewListItem->pxPrevious = pxIterator;
     edc:	ef 81       	ldd	r30, Y+7	; 0x07
     ede:	f8 85       	ldd	r31, Y+8	; 0x08
     ee0:	8b 81       	ldd	r24, Y+3	; 0x03
     ee2:	9c 81       	ldd	r25, Y+4	; 0x04
     ee4:	95 83       	std	Z+5, r25	; 0x05
     ee6:	84 83       	std	Z+4, r24	; 0x04
	pxIterator->pxNext = pxNewListItem;
     ee8:	eb 81       	ldd	r30, Y+3	; 0x03
     eea:	fc 81       	ldd	r31, Y+4	; 0x04
     eec:	8f 81       	ldd	r24, Y+7	; 0x07
     eee:	98 85       	ldd	r25, Y+8	; 0x08
     ef0:	93 83       	std	Z+3, r25	; 0x03
     ef2:	82 83       	std	Z+2, r24	; 0x02

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pxContainer = pxList;
     ef4:	ef 81       	ldd	r30, Y+7	; 0x07
     ef6:	f8 85       	ldd	r31, Y+8	; 0x08
     ef8:	8d 81       	ldd	r24, Y+5	; 0x05
     efa:	9e 81       	ldd	r25, Y+6	; 0x06
     efc:	91 87       	std	Z+9, r25	; 0x09
     efe:	80 87       	std	Z+8, r24	; 0x08

	( pxList->uxNumberOfItems )++;
     f00:	ed 81       	ldd	r30, Y+5	; 0x05
     f02:	fe 81       	ldd	r31, Y+6	; 0x06
     f04:	80 81       	ld	r24, Z
     f06:	8f 5f       	subi	r24, 0xFF	; 255
     f08:	ed 81       	ldd	r30, Y+5	; 0x05
     f0a:	fe 81       	ldd	r31, Y+6	; 0x06
     f0c:	80 83       	st	Z, r24
}
     f0e:	28 96       	adiw	r28, 0x08	; 8
     f10:	0f b6       	in	r0, 0x3f	; 63
     f12:	f8 94       	cli
     f14:	de bf       	out	0x3e, r29	; 62
     f16:	0f be       	out	0x3f, r0	; 63
     f18:	cd bf       	out	0x3d, r28	; 61
     f1a:	cf 91       	pop	r28
     f1c:	df 91       	pop	r29
     f1e:	08 95       	ret

00000f20 <uxListRemove>:
/*-----------------------------------------------------------*/

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
     f20:	df 93       	push	r29
     f22:	cf 93       	push	r28
     f24:	00 d0       	rcall	.+0      	; 0xf26 <uxListRemove+0x6>
     f26:	00 d0       	rcall	.+0      	; 0xf28 <uxListRemove+0x8>
     f28:	cd b7       	in	r28, 0x3d	; 61
     f2a:	de b7       	in	r29, 0x3e	; 62
     f2c:	9c 83       	std	Y+4, r25	; 0x04
     f2e:	8b 83       	std	Y+3, r24	; 0x03
/* The list item knows which list it is in.  Obtain the list from the list
item. */
List_t * const pxList = pxItemToRemove->pxContainer;
     f30:	eb 81       	ldd	r30, Y+3	; 0x03
     f32:	fc 81       	ldd	r31, Y+4	; 0x04
     f34:	80 85       	ldd	r24, Z+8	; 0x08
     f36:	91 85       	ldd	r25, Z+9	; 0x09
     f38:	9a 83       	std	Y+2, r25	; 0x02
     f3a:	89 83       	std	Y+1, r24	; 0x01

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
     f3c:	eb 81       	ldd	r30, Y+3	; 0x03
     f3e:	fc 81       	ldd	r31, Y+4	; 0x04
     f40:	a2 81       	ldd	r26, Z+2	; 0x02
     f42:	b3 81       	ldd	r27, Z+3	; 0x03
     f44:	eb 81       	ldd	r30, Y+3	; 0x03
     f46:	fc 81       	ldd	r31, Y+4	; 0x04
     f48:	84 81       	ldd	r24, Z+4	; 0x04
     f4a:	95 81       	ldd	r25, Z+5	; 0x05
     f4c:	15 96       	adiw	r26, 0x05	; 5
     f4e:	9c 93       	st	X, r25
     f50:	8e 93       	st	-X, r24
     f52:	14 97       	sbiw	r26, 0x04	; 4
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
     f54:	eb 81       	ldd	r30, Y+3	; 0x03
     f56:	fc 81       	ldd	r31, Y+4	; 0x04
     f58:	a4 81       	ldd	r26, Z+4	; 0x04
     f5a:	b5 81       	ldd	r27, Z+5	; 0x05
     f5c:	eb 81       	ldd	r30, Y+3	; 0x03
     f5e:	fc 81       	ldd	r31, Y+4	; 0x04
     f60:	82 81       	ldd	r24, Z+2	; 0x02
     f62:	93 81       	ldd	r25, Z+3	; 0x03
     f64:	13 96       	adiw	r26, 0x03	; 3
     f66:	9c 93       	st	X, r25
     f68:	8e 93       	st	-X, r24
     f6a:	12 97       	sbiw	r26, 0x02	; 2

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
     f6c:	e9 81       	ldd	r30, Y+1	; 0x01
     f6e:	fa 81       	ldd	r31, Y+2	; 0x02
     f70:	21 81       	ldd	r18, Z+1	; 0x01
     f72:	32 81       	ldd	r19, Z+2	; 0x02
     f74:	8b 81       	ldd	r24, Y+3	; 0x03
     f76:	9c 81       	ldd	r25, Y+4	; 0x04
     f78:	28 17       	cp	r18, r24
     f7a:	39 07       	cpc	r19, r25
     f7c:	41 f4       	brne	.+16     	; 0xf8e <uxListRemove+0x6e>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
     f7e:	eb 81       	ldd	r30, Y+3	; 0x03
     f80:	fc 81       	ldd	r31, Y+4	; 0x04
     f82:	84 81       	ldd	r24, Z+4	; 0x04
     f84:	95 81       	ldd	r25, Z+5	; 0x05
     f86:	e9 81       	ldd	r30, Y+1	; 0x01
     f88:	fa 81       	ldd	r31, Y+2	; 0x02
     f8a:	92 83       	std	Z+2, r25	; 0x02
     f8c:	81 83       	std	Z+1, r24	; 0x01
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxItemToRemove->pxContainer = NULL;
     f8e:	eb 81       	ldd	r30, Y+3	; 0x03
     f90:	fc 81       	ldd	r31, Y+4	; 0x04
     f92:	11 86       	std	Z+9, r1	; 0x09
     f94:	10 86       	std	Z+8, r1	; 0x08
	( pxList->uxNumberOfItems )--;
     f96:	e9 81       	ldd	r30, Y+1	; 0x01
     f98:	fa 81       	ldd	r31, Y+2	; 0x02
     f9a:	80 81       	ld	r24, Z
     f9c:	81 50       	subi	r24, 0x01	; 1
     f9e:	e9 81       	ldd	r30, Y+1	; 0x01
     fa0:	fa 81       	ldd	r31, Y+2	; 0x02
     fa2:	80 83       	st	Z, r24

	return pxList->uxNumberOfItems;
     fa4:	e9 81       	ldd	r30, Y+1	; 0x01
     fa6:	fa 81       	ldd	r31, Y+2	; 0x02
     fa8:	80 81       	ld	r24, Z
}
     faa:	0f 90       	pop	r0
     fac:	0f 90       	pop	r0
     fae:	0f 90       	pop	r0
     fb0:	0f 90       	pop	r0
     fb2:	cf 91       	pop	r28
     fb4:	df 91       	pop	r29
     fb6:	08 95       	ret

00000fb8 <task_1>:
#elif mode == semaphor

xSemaphoreHandle task_sem;

void task_1(void *pv)
{
     fb8:	df 93       	push	r29
     fba:	cf 93       	push	r28
     fbc:	00 d0       	rcall	.+0      	; 0xfbe <task_1+0x6>
     fbe:	0f 92       	push	r0
     fc0:	cd b7       	in	r28, 0x3d	; 61
     fc2:	de b7       	in	r29, 0x3e	; 62
     fc4:	9b 83       	std	Y+3, r25	; 0x03
     fc6:	8a 83       	std	Y+2, r24	; 0x02
	static u8_t au8_state =0;

	u8_t au8_semaphorstate = 0;
     fc8:	19 82       	std	Y+1, r1	; 0x01

	while(1)
	{
		/*ask for semaphore*/
		 au8_semaphorstate = xSemaphoreTake(task_sem, 0);
     fca:	80 91 ae 06 	lds	r24, 0x06AE
     fce:	90 91 af 06 	lds	r25, 0x06AF
     fd2:	60 e0       	ldi	r22, 0x00	; 0
     fd4:	70 e0       	ldi	r23, 0x00	; 0
     fd6:	0e 94 48 0f 	call	0x1e90	; 0x1e90 <xQueueSemaphoreTake>
     fda:	89 83       	std	Y+1, r24	; 0x01

		if(au8_semaphorstate == pdPASS)
     fdc:	89 81       	ldd	r24, Y+1	; 0x01
     fde:	81 30       	cpi	r24, 0x01	; 1
     fe0:	c1 f4       	brne	.+48     	; 0x1012 <task_1+0x5a>
		{
			TOGGLE_BIT(au8_state,0);
     fe2:	90 91 46 06 	lds	r25, 0x0646
     fe6:	81 e0       	ldi	r24, 0x01	; 1
     fe8:	89 27       	eor	r24, r25
     fea:	80 93 46 06 	sts	0x0646, r24
			mdio_setPinValue(PORTA,PIN0,au8_state);
     fee:	90 91 46 06 	lds	r25, 0x0646
     ff2:	81 e0       	ldi	r24, 0x01	; 1
     ff4:	61 e0       	ldi	r22, 0x01	; 1
     ff6:	49 2f       	mov	r20, r25
     ff8:	0e 94 70 01 	call	0x2e0	; 0x2e0 <mdio_setPinValue>
			xSemaphoreGive(task_sem) ;
     ffc:	80 91 ae 06 	lds	r24, 0x06AE
    1000:	90 91 af 06 	lds	r25, 0x06AF
    1004:	60 e0       	ldi	r22, 0x00	; 0
    1006:	70 e0       	ldi	r23, 0x00	; 0
    1008:	40 e0       	ldi	r20, 0x00	; 0
    100a:	50 e0       	ldi	r21, 0x00	; 0
    100c:	20 e0       	ldi	r18, 0x00	; 0
    100e:	0e 94 48 0d 	call	0x1a90	; 0x1a90 <xQueueGenericSend>
		}

		vTaskDelay(1000);
    1012:	88 ee       	ldi	r24, 0xE8	; 232
    1014:	93 e0       	ldi	r25, 0x03	; 3
    1016:	0e 94 77 1d 	call	0x3aee	; 0x3aee <vTaskDelay>
    101a:	d7 cf       	rjmp	.-82     	; 0xfca <task_1+0x12>

0000101c <task_2>:
	}
}

void task_2(void *pv)
{
    101c:	df 93       	push	r29
    101e:	cf 93       	push	r28
    1020:	00 d0       	rcall	.+0      	; 0x1022 <task_2+0x6>
    1022:	0f 92       	push	r0
    1024:	cd b7       	in	r28, 0x3d	; 61
    1026:	de b7       	in	r29, 0x3e	; 62
    1028:	9b 83       	std	Y+3, r25	; 0x03
    102a:	8a 83       	std	Y+2, r24	; 0x02
	static u8_t au8_state =0;
	u8_t au8_semaphorstate = 0;
    102c:	19 82       	std	Y+1, r1	; 0x01

	while(1)
	{
		/*ask for semaphore*/
		au8_semaphorstate = xSemaphoreTake(task_sem, 0);
    102e:	80 91 ae 06 	lds	r24, 0x06AE
    1032:	90 91 af 06 	lds	r25, 0x06AF
    1036:	60 e0       	ldi	r22, 0x00	; 0
    1038:	70 e0       	ldi	r23, 0x00	; 0
    103a:	0e 94 48 0f 	call	0x1e90	; 0x1e90 <xQueueSemaphoreTake>
    103e:	89 83       	std	Y+1, r24	; 0x01

		if(au8_semaphorstate == pdPASS)
    1040:	89 81       	ldd	r24, Y+1	; 0x01
    1042:	81 30       	cpi	r24, 0x01	; 1
    1044:	c1 f4       	brne	.+48     	; 0x1076 <task_2+0x5a>
		{
			TOGGLE_BIT(au8_state,0);
    1046:	90 91 47 06 	lds	r25, 0x0647
    104a:	81 e0       	ldi	r24, 0x01	; 1
    104c:	89 27       	eor	r24, r25
    104e:	80 93 47 06 	sts	0x0647, r24
			mdio_setPinValue(PORTA,PIN1,au8_state);
    1052:	90 91 47 06 	lds	r25, 0x0647
    1056:	81 e0       	ldi	r24, 0x01	; 1
    1058:	62 e0       	ldi	r22, 0x02	; 2
    105a:	49 2f       	mov	r20, r25
    105c:	0e 94 70 01 	call	0x2e0	; 0x2e0 <mdio_setPinValue>
			xSemaphoreGive(task_sem);
    1060:	80 91 ae 06 	lds	r24, 0x06AE
    1064:	90 91 af 06 	lds	r25, 0x06AF
    1068:	60 e0       	ldi	r22, 0x00	; 0
    106a:	70 e0       	ldi	r23, 0x00	; 0
    106c:	40 e0       	ldi	r20, 0x00	; 0
    106e:	50 e0       	ldi	r21, 0x00	; 0
    1070:	20 e0       	ldi	r18, 0x00	; 0
    1072:	0e 94 48 0d 	call	0x1a90	; 0x1a90 <xQueueGenericSend>
		}

		vTaskDelay(500);
    1076:	84 ef       	ldi	r24, 0xF4	; 244
    1078:	91 e0       	ldi	r25, 0x01	; 1
    107a:	0e 94 77 1d 	call	0x3aee	; 0x3aee <vTaskDelay>
    107e:	d7 cf       	rjmp	.-82     	; 0x102e <task_2+0x12>

00001080 <main>:
	}
}

int main(void)
{
    1080:	ef 92       	push	r14
    1082:	ff 92       	push	r15
    1084:	0f 93       	push	r16
    1086:	df 93       	push	r29
    1088:	cf 93       	push	r28
    108a:	cd b7       	in	r28, 0x3d	; 61
    108c:	de b7       	in	r29, 0x3e	; 62
	mdio_setPinstatus(PORTA,PIN0,OUTPUT);
    108e:	81 e0       	ldi	r24, 0x01	; 1
    1090:	61 e0       	ldi	r22, 0x01	; 1
    1092:	41 e0       	ldi	r20, 0x01	; 1
    1094:	0e 94 49 00 	call	0x92	; 0x92 <mdio_setPinstatus>
	mdio_setPinstatus(PORTA,PIN1,OUTPUT);
    1098:	81 e0       	ldi	r24, 0x01	; 1
    109a:	62 e0       	ldi	r22, 0x02	; 2
    109c:	41 e0       	ldi	r20, 0x01	; 1
    109e:	0e 94 49 00 	call	0x92	; 0x92 <mdio_setPinstatus>
	//mdio_setPinstatus(PORTA,PIN2,OUTPUT);


	task_sem = xSemaphoreCreateCounting(1,1);
    10a2:	81 e0       	ldi	r24, 0x01	; 1
    10a4:	61 e0       	ldi	r22, 0x01	; 1
    10a6:	0e 94 28 0d 	call	0x1a50	; 0x1a50 <xQueueCreateCountingSemaphore>
    10aa:	90 93 af 06 	sts	0x06AF, r25
    10ae:	80 93 ae 06 	sts	0x06AE, r24
	xTaskCreate(task_1, NULL, 200, NULL, 1, NULL);
    10b2:	8c ed       	ldi	r24, 0xDC	; 220
    10b4:	97 e0       	ldi	r25, 0x07	; 7
    10b6:	60 e0       	ldi	r22, 0x00	; 0
    10b8:	70 e0       	ldi	r23, 0x00	; 0
    10ba:	48 ec       	ldi	r20, 0xC8	; 200
    10bc:	50 e0       	ldi	r21, 0x00	; 0
    10be:	20 e0       	ldi	r18, 0x00	; 0
    10c0:	30 e0       	ldi	r19, 0x00	; 0
    10c2:	01 e0       	ldi	r16, 0x01	; 1
    10c4:	ee 24       	eor	r14, r14
    10c6:	ff 24       	eor	r15, r15
    10c8:	0e 94 52 1b 	call	0x36a4	; 0x36a4 <xTaskCreate>
	xTaskCreate(task_2, NULL, 200, NULL, 2, NULL);
    10cc:	8e e0       	ldi	r24, 0x0E	; 14
    10ce:	98 e0       	ldi	r25, 0x08	; 8
    10d0:	60 e0       	ldi	r22, 0x00	; 0
    10d2:	70 e0       	ldi	r23, 0x00	; 0
    10d4:	48 ec       	ldi	r20, 0xC8	; 200
    10d6:	50 e0       	ldi	r21, 0x00	; 0
    10d8:	20 e0       	ldi	r18, 0x00	; 0
    10da:	30 e0       	ldi	r19, 0x00	; 0
    10dc:	02 e0       	ldi	r16, 0x02	; 2
    10de:	ee 24       	eor	r14, r14
    10e0:	ff 24       	eor	r15, r15
    10e2:	0e 94 52 1b 	call	0x36a4	; 0x36a4 <xTaskCreate>
	//xTaskCreate(task_3, NULL, 200, NULL, 3, NULL);
	vTaskStartScheduler();
    10e6:	0e 94 06 1f 	call	0x3e0c	; 0x3e0c <vTaskStartScheduler>
	return 0;
    10ea:	80 e0       	ldi	r24, 0x00	; 0
    10ec:	90 e0       	ldi	r25, 0x00	; 0
}
    10ee:	cf 91       	pop	r28
    10f0:	df 91       	pop	r29
    10f2:	0f 91       	pop	r16
    10f4:	ff 90       	pop	r15
    10f6:	ef 90       	pop	r14
    10f8:	08 95       	ret

000010fa <pxPortInitialiseStack>:

/* 
 * See header file for description. 
 */
StackType_t *pxPortInitialiseStack( StackType_t *pxTopOfStack, TaskFunction_t pxCode, void *pvParameters )
{
    10fa:	df 93       	push	r29
    10fc:	cf 93       	push	r28
    10fe:	cd b7       	in	r28, 0x3d	; 61
    1100:	de b7       	in	r29, 0x3e	; 62
    1102:	28 97       	sbiw	r28, 0x08	; 8
    1104:	0f b6       	in	r0, 0x3f	; 63
    1106:	f8 94       	cli
    1108:	de bf       	out	0x3e, r29	; 62
    110a:	0f be       	out	0x3f, r0	; 63
    110c:	cd bf       	out	0x3d, r28	; 61
    110e:	9c 83       	std	Y+4, r25	; 0x04
    1110:	8b 83       	std	Y+3, r24	; 0x03
    1112:	7e 83       	std	Y+6, r23	; 0x06
    1114:	6d 83       	std	Y+5, r22	; 0x05
    1116:	58 87       	std	Y+8, r21	; 0x08
    1118:	4f 83       	std	Y+7, r20	; 0x07
uint16_t usAddress;

	/* Place a few bytes of known values on the bottom of the stack. 
	This is just useful for debugging. */

	*pxTopOfStack = 0x11;
    111a:	eb 81       	ldd	r30, Y+3	; 0x03
    111c:	fc 81       	ldd	r31, Y+4	; 0x04
    111e:	81 e1       	ldi	r24, 0x11	; 17
    1120:	80 83       	st	Z, r24
	pxTopOfStack--;
    1122:	8b 81       	ldd	r24, Y+3	; 0x03
    1124:	9c 81       	ldd	r25, Y+4	; 0x04
    1126:	01 97       	sbiw	r24, 0x01	; 1
    1128:	9c 83       	std	Y+4, r25	; 0x04
    112a:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = 0x22;
    112c:	eb 81       	ldd	r30, Y+3	; 0x03
    112e:	fc 81       	ldd	r31, Y+4	; 0x04
    1130:	82 e2       	ldi	r24, 0x22	; 34
    1132:	80 83       	st	Z, r24
	pxTopOfStack--;
    1134:	8b 81       	ldd	r24, Y+3	; 0x03
    1136:	9c 81       	ldd	r25, Y+4	; 0x04
    1138:	01 97       	sbiw	r24, 0x01	; 1
    113a:	9c 83       	std	Y+4, r25	; 0x04
    113c:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = 0x33;
    113e:	eb 81       	ldd	r30, Y+3	; 0x03
    1140:	fc 81       	ldd	r31, Y+4	; 0x04
    1142:	83 e3       	ldi	r24, 0x33	; 51
    1144:	80 83       	st	Z, r24
	pxTopOfStack--;
    1146:	8b 81       	ldd	r24, Y+3	; 0x03
    1148:	9c 81       	ldd	r25, Y+4	; 0x04
    114a:	01 97       	sbiw	r24, 0x01	; 1
    114c:	9c 83       	std	Y+4, r25	; 0x04
    114e:	8b 83       	std	Y+3, r24	; 0x03

	/*lint -e950 -e611 -e923 Lint doesn't like this much - but nothing I can do about it. */

	/* The start of the task code will be popped off the stack last, so place
	it on first. */
	usAddress = ( uint16_t ) pxCode;
    1150:	8d 81       	ldd	r24, Y+5	; 0x05
    1152:	9e 81       	ldd	r25, Y+6	; 0x06
    1154:	9a 83       	std	Y+2, r25	; 0x02
    1156:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
    1158:	89 81       	ldd	r24, Y+1	; 0x01
    115a:	eb 81       	ldd	r30, Y+3	; 0x03
    115c:	fc 81       	ldd	r31, Y+4	; 0x04
    115e:	80 83       	st	Z, r24
	pxTopOfStack--;
    1160:	8b 81       	ldd	r24, Y+3	; 0x03
    1162:	9c 81       	ldd	r25, Y+4	; 0x04
    1164:	01 97       	sbiw	r24, 0x01	; 1
    1166:	9c 83       	std	Y+4, r25	; 0x04
    1168:	8b 83       	std	Y+3, r24	; 0x03

	usAddress >>= 8;
    116a:	89 81       	ldd	r24, Y+1	; 0x01
    116c:	9a 81       	ldd	r25, Y+2	; 0x02
    116e:	89 2f       	mov	r24, r25
    1170:	99 27       	eor	r25, r25
    1172:	9a 83       	std	Y+2, r25	; 0x02
    1174:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
    1176:	89 81       	ldd	r24, Y+1	; 0x01
    1178:	eb 81       	ldd	r30, Y+3	; 0x03
    117a:	fc 81       	ldd	r31, Y+4	; 0x04
    117c:	80 83       	st	Z, r24
	pxTopOfStack--;
    117e:	8b 81       	ldd	r24, Y+3	; 0x03
    1180:	9c 81       	ldd	r25, Y+4	; 0x04
    1182:	01 97       	sbiw	r24, 0x01	; 1
    1184:	9c 83       	std	Y+4, r25	; 0x04
    1186:	8b 83       	std	Y+3, r24	; 0x03

	/* Next simulate the stack as if after a call to portSAVE_CONTEXT().  
	portSAVE_CONTEXT places the flags on the stack immediately after r0
	to ensure the interrupts get disabled as soon as possible, and so ensuring
	the stack use is minimal should a context switch interrupt occur. */
	*pxTopOfStack = ( StackType_t ) 0x00;	/* R0 */
    1188:	eb 81       	ldd	r30, Y+3	; 0x03
    118a:	fc 81       	ldd	r31, Y+4	; 0x04
    118c:	10 82       	st	Z, r1
	pxTopOfStack--;
    118e:	8b 81       	ldd	r24, Y+3	; 0x03
    1190:	9c 81       	ldd	r25, Y+4	; 0x04
    1192:	01 97       	sbiw	r24, 0x01	; 1
    1194:	9c 83       	std	Y+4, r25	; 0x04
    1196:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = portFLAGS_INT_ENABLED;
    1198:	eb 81       	ldd	r30, Y+3	; 0x03
    119a:	fc 81       	ldd	r31, Y+4	; 0x04
    119c:	80 e8       	ldi	r24, 0x80	; 128
    119e:	80 83       	st	Z, r24
	pxTopOfStack--;
    11a0:	8b 81       	ldd	r24, Y+3	; 0x03
    11a2:	9c 81       	ldd	r25, Y+4	; 0x04
    11a4:	01 97       	sbiw	r24, 0x01	; 1
    11a6:	9c 83       	std	Y+4, r25	; 0x04
    11a8:	8b 83       	std	Y+3, r24	; 0x03


	/* Now the remaining registers.   The compiler expects R1 to be 0. */
	*pxTopOfStack = ( StackType_t ) 0x00;	/* R1 */
    11aa:	eb 81       	ldd	r30, Y+3	; 0x03
    11ac:	fc 81       	ldd	r31, Y+4	; 0x04
    11ae:	10 82       	st	Z, r1
	pxTopOfStack--;
    11b0:	8b 81       	ldd	r24, Y+3	; 0x03
    11b2:	9c 81       	ldd	r25, Y+4	; 0x04
    11b4:	01 97       	sbiw	r24, 0x01	; 1
    11b6:	9c 83       	std	Y+4, r25	; 0x04
    11b8:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x02;	/* R2 */
    11ba:	eb 81       	ldd	r30, Y+3	; 0x03
    11bc:	fc 81       	ldd	r31, Y+4	; 0x04
    11be:	82 e0       	ldi	r24, 0x02	; 2
    11c0:	80 83       	st	Z, r24
	pxTopOfStack--;
    11c2:	8b 81       	ldd	r24, Y+3	; 0x03
    11c4:	9c 81       	ldd	r25, Y+4	; 0x04
    11c6:	01 97       	sbiw	r24, 0x01	; 1
    11c8:	9c 83       	std	Y+4, r25	; 0x04
    11ca:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x03;	/* R3 */
    11cc:	eb 81       	ldd	r30, Y+3	; 0x03
    11ce:	fc 81       	ldd	r31, Y+4	; 0x04
    11d0:	83 e0       	ldi	r24, 0x03	; 3
    11d2:	80 83       	st	Z, r24
	pxTopOfStack--;
    11d4:	8b 81       	ldd	r24, Y+3	; 0x03
    11d6:	9c 81       	ldd	r25, Y+4	; 0x04
    11d8:	01 97       	sbiw	r24, 0x01	; 1
    11da:	9c 83       	std	Y+4, r25	; 0x04
    11dc:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x04;	/* R4 */
    11de:	eb 81       	ldd	r30, Y+3	; 0x03
    11e0:	fc 81       	ldd	r31, Y+4	; 0x04
    11e2:	84 e0       	ldi	r24, 0x04	; 4
    11e4:	80 83       	st	Z, r24
	pxTopOfStack--;
    11e6:	8b 81       	ldd	r24, Y+3	; 0x03
    11e8:	9c 81       	ldd	r25, Y+4	; 0x04
    11ea:	01 97       	sbiw	r24, 0x01	; 1
    11ec:	9c 83       	std	Y+4, r25	; 0x04
    11ee:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x05;	/* R5 */
    11f0:	eb 81       	ldd	r30, Y+3	; 0x03
    11f2:	fc 81       	ldd	r31, Y+4	; 0x04
    11f4:	85 e0       	ldi	r24, 0x05	; 5
    11f6:	80 83       	st	Z, r24
	pxTopOfStack--;
    11f8:	8b 81       	ldd	r24, Y+3	; 0x03
    11fa:	9c 81       	ldd	r25, Y+4	; 0x04
    11fc:	01 97       	sbiw	r24, 0x01	; 1
    11fe:	9c 83       	std	Y+4, r25	; 0x04
    1200:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x06;	/* R6 */
    1202:	eb 81       	ldd	r30, Y+3	; 0x03
    1204:	fc 81       	ldd	r31, Y+4	; 0x04
    1206:	86 e0       	ldi	r24, 0x06	; 6
    1208:	80 83       	st	Z, r24
	pxTopOfStack--;
    120a:	8b 81       	ldd	r24, Y+3	; 0x03
    120c:	9c 81       	ldd	r25, Y+4	; 0x04
    120e:	01 97       	sbiw	r24, 0x01	; 1
    1210:	9c 83       	std	Y+4, r25	; 0x04
    1212:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x07;	/* R7 */
    1214:	eb 81       	ldd	r30, Y+3	; 0x03
    1216:	fc 81       	ldd	r31, Y+4	; 0x04
    1218:	87 e0       	ldi	r24, 0x07	; 7
    121a:	80 83       	st	Z, r24
	pxTopOfStack--;
    121c:	8b 81       	ldd	r24, Y+3	; 0x03
    121e:	9c 81       	ldd	r25, Y+4	; 0x04
    1220:	01 97       	sbiw	r24, 0x01	; 1
    1222:	9c 83       	std	Y+4, r25	; 0x04
    1224:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x08;	/* R8 */
    1226:	eb 81       	ldd	r30, Y+3	; 0x03
    1228:	fc 81       	ldd	r31, Y+4	; 0x04
    122a:	88 e0       	ldi	r24, 0x08	; 8
    122c:	80 83       	st	Z, r24
	pxTopOfStack--;
    122e:	8b 81       	ldd	r24, Y+3	; 0x03
    1230:	9c 81       	ldd	r25, Y+4	; 0x04
    1232:	01 97       	sbiw	r24, 0x01	; 1
    1234:	9c 83       	std	Y+4, r25	; 0x04
    1236:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x09;	/* R9 */
    1238:	eb 81       	ldd	r30, Y+3	; 0x03
    123a:	fc 81       	ldd	r31, Y+4	; 0x04
    123c:	89 e0       	ldi	r24, 0x09	; 9
    123e:	80 83       	st	Z, r24
	pxTopOfStack--;
    1240:	8b 81       	ldd	r24, Y+3	; 0x03
    1242:	9c 81       	ldd	r25, Y+4	; 0x04
    1244:	01 97       	sbiw	r24, 0x01	; 1
    1246:	9c 83       	std	Y+4, r25	; 0x04
    1248:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x10;	/* R10 */
    124a:	eb 81       	ldd	r30, Y+3	; 0x03
    124c:	fc 81       	ldd	r31, Y+4	; 0x04
    124e:	80 e1       	ldi	r24, 0x10	; 16
    1250:	80 83       	st	Z, r24
	pxTopOfStack--;
    1252:	8b 81       	ldd	r24, Y+3	; 0x03
    1254:	9c 81       	ldd	r25, Y+4	; 0x04
    1256:	01 97       	sbiw	r24, 0x01	; 1
    1258:	9c 83       	std	Y+4, r25	; 0x04
    125a:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x11;	/* R11 */
    125c:	eb 81       	ldd	r30, Y+3	; 0x03
    125e:	fc 81       	ldd	r31, Y+4	; 0x04
    1260:	81 e1       	ldi	r24, 0x11	; 17
    1262:	80 83       	st	Z, r24
	pxTopOfStack--;
    1264:	8b 81       	ldd	r24, Y+3	; 0x03
    1266:	9c 81       	ldd	r25, Y+4	; 0x04
    1268:	01 97       	sbiw	r24, 0x01	; 1
    126a:	9c 83       	std	Y+4, r25	; 0x04
    126c:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x12;	/* R12 */
    126e:	eb 81       	ldd	r30, Y+3	; 0x03
    1270:	fc 81       	ldd	r31, Y+4	; 0x04
    1272:	82 e1       	ldi	r24, 0x12	; 18
    1274:	80 83       	st	Z, r24
	pxTopOfStack--;
    1276:	8b 81       	ldd	r24, Y+3	; 0x03
    1278:	9c 81       	ldd	r25, Y+4	; 0x04
    127a:	01 97       	sbiw	r24, 0x01	; 1
    127c:	9c 83       	std	Y+4, r25	; 0x04
    127e:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x13;	/* R13 */
    1280:	eb 81       	ldd	r30, Y+3	; 0x03
    1282:	fc 81       	ldd	r31, Y+4	; 0x04
    1284:	83 e1       	ldi	r24, 0x13	; 19
    1286:	80 83       	st	Z, r24
	pxTopOfStack--;
    1288:	8b 81       	ldd	r24, Y+3	; 0x03
    128a:	9c 81       	ldd	r25, Y+4	; 0x04
    128c:	01 97       	sbiw	r24, 0x01	; 1
    128e:	9c 83       	std	Y+4, r25	; 0x04
    1290:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x14;	/* R14 */
    1292:	eb 81       	ldd	r30, Y+3	; 0x03
    1294:	fc 81       	ldd	r31, Y+4	; 0x04
    1296:	84 e1       	ldi	r24, 0x14	; 20
    1298:	80 83       	st	Z, r24
	pxTopOfStack--;
    129a:	8b 81       	ldd	r24, Y+3	; 0x03
    129c:	9c 81       	ldd	r25, Y+4	; 0x04
    129e:	01 97       	sbiw	r24, 0x01	; 1
    12a0:	9c 83       	std	Y+4, r25	; 0x04
    12a2:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x15;	/* R15 */
    12a4:	eb 81       	ldd	r30, Y+3	; 0x03
    12a6:	fc 81       	ldd	r31, Y+4	; 0x04
    12a8:	85 e1       	ldi	r24, 0x15	; 21
    12aa:	80 83       	st	Z, r24
	pxTopOfStack--;
    12ac:	8b 81       	ldd	r24, Y+3	; 0x03
    12ae:	9c 81       	ldd	r25, Y+4	; 0x04
    12b0:	01 97       	sbiw	r24, 0x01	; 1
    12b2:	9c 83       	std	Y+4, r25	; 0x04
    12b4:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x16;	/* R16 */
    12b6:	eb 81       	ldd	r30, Y+3	; 0x03
    12b8:	fc 81       	ldd	r31, Y+4	; 0x04
    12ba:	86 e1       	ldi	r24, 0x16	; 22
    12bc:	80 83       	st	Z, r24
	pxTopOfStack--;
    12be:	8b 81       	ldd	r24, Y+3	; 0x03
    12c0:	9c 81       	ldd	r25, Y+4	; 0x04
    12c2:	01 97       	sbiw	r24, 0x01	; 1
    12c4:	9c 83       	std	Y+4, r25	; 0x04
    12c6:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x17;	/* R17 */
    12c8:	eb 81       	ldd	r30, Y+3	; 0x03
    12ca:	fc 81       	ldd	r31, Y+4	; 0x04
    12cc:	87 e1       	ldi	r24, 0x17	; 23
    12ce:	80 83       	st	Z, r24
	pxTopOfStack--;
    12d0:	8b 81       	ldd	r24, Y+3	; 0x03
    12d2:	9c 81       	ldd	r25, Y+4	; 0x04
    12d4:	01 97       	sbiw	r24, 0x01	; 1
    12d6:	9c 83       	std	Y+4, r25	; 0x04
    12d8:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x18;	/* R18 */
    12da:	eb 81       	ldd	r30, Y+3	; 0x03
    12dc:	fc 81       	ldd	r31, Y+4	; 0x04
    12de:	88 e1       	ldi	r24, 0x18	; 24
    12e0:	80 83       	st	Z, r24
	pxTopOfStack--;
    12e2:	8b 81       	ldd	r24, Y+3	; 0x03
    12e4:	9c 81       	ldd	r25, Y+4	; 0x04
    12e6:	01 97       	sbiw	r24, 0x01	; 1
    12e8:	9c 83       	std	Y+4, r25	; 0x04
    12ea:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x19;	/* R19 */
    12ec:	eb 81       	ldd	r30, Y+3	; 0x03
    12ee:	fc 81       	ldd	r31, Y+4	; 0x04
    12f0:	89 e1       	ldi	r24, 0x19	; 25
    12f2:	80 83       	st	Z, r24
	pxTopOfStack--;
    12f4:	8b 81       	ldd	r24, Y+3	; 0x03
    12f6:	9c 81       	ldd	r25, Y+4	; 0x04
    12f8:	01 97       	sbiw	r24, 0x01	; 1
    12fa:	9c 83       	std	Y+4, r25	; 0x04
    12fc:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x20;	/* R20 */
    12fe:	eb 81       	ldd	r30, Y+3	; 0x03
    1300:	fc 81       	ldd	r31, Y+4	; 0x04
    1302:	80 e2       	ldi	r24, 0x20	; 32
    1304:	80 83       	st	Z, r24
	pxTopOfStack--;
    1306:	8b 81       	ldd	r24, Y+3	; 0x03
    1308:	9c 81       	ldd	r25, Y+4	; 0x04
    130a:	01 97       	sbiw	r24, 0x01	; 1
    130c:	9c 83       	std	Y+4, r25	; 0x04
    130e:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x21;	/* R21 */
    1310:	eb 81       	ldd	r30, Y+3	; 0x03
    1312:	fc 81       	ldd	r31, Y+4	; 0x04
    1314:	81 e2       	ldi	r24, 0x21	; 33
    1316:	80 83       	st	Z, r24
	pxTopOfStack--;
    1318:	8b 81       	ldd	r24, Y+3	; 0x03
    131a:	9c 81       	ldd	r25, Y+4	; 0x04
    131c:	01 97       	sbiw	r24, 0x01	; 1
    131e:	9c 83       	std	Y+4, r25	; 0x04
    1320:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x22;	/* R22 */
    1322:	eb 81       	ldd	r30, Y+3	; 0x03
    1324:	fc 81       	ldd	r31, Y+4	; 0x04
    1326:	82 e2       	ldi	r24, 0x22	; 34
    1328:	80 83       	st	Z, r24
	pxTopOfStack--;
    132a:	8b 81       	ldd	r24, Y+3	; 0x03
    132c:	9c 81       	ldd	r25, Y+4	; 0x04
    132e:	01 97       	sbiw	r24, 0x01	; 1
    1330:	9c 83       	std	Y+4, r25	; 0x04
    1332:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x23;	/* R23 */
    1334:	eb 81       	ldd	r30, Y+3	; 0x03
    1336:	fc 81       	ldd	r31, Y+4	; 0x04
    1338:	83 e2       	ldi	r24, 0x23	; 35
    133a:	80 83       	st	Z, r24
	pxTopOfStack--;
    133c:	8b 81       	ldd	r24, Y+3	; 0x03
    133e:	9c 81       	ldd	r25, Y+4	; 0x04
    1340:	01 97       	sbiw	r24, 0x01	; 1
    1342:	9c 83       	std	Y+4, r25	; 0x04
    1344:	8b 83       	std	Y+3, r24	; 0x03

	/* Place the parameter on the stack in the expected location. */
	usAddress = ( uint16_t ) pvParameters;
    1346:	8f 81       	ldd	r24, Y+7	; 0x07
    1348:	98 85       	ldd	r25, Y+8	; 0x08
    134a:	9a 83       	std	Y+2, r25	; 0x02
    134c:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
    134e:	89 81       	ldd	r24, Y+1	; 0x01
    1350:	eb 81       	ldd	r30, Y+3	; 0x03
    1352:	fc 81       	ldd	r31, Y+4	; 0x04
    1354:	80 83       	st	Z, r24
	pxTopOfStack--;
    1356:	8b 81       	ldd	r24, Y+3	; 0x03
    1358:	9c 81       	ldd	r25, Y+4	; 0x04
    135a:	01 97       	sbiw	r24, 0x01	; 1
    135c:	9c 83       	std	Y+4, r25	; 0x04
    135e:	8b 83       	std	Y+3, r24	; 0x03

	usAddress >>= 8;
    1360:	89 81       	ldd	r24, Y+1	; 0x01
    1362:	9a 81       	ldd	r25, Y+2	; 0x02
    1364:	89 2f       	mov	r24, r25
    1366:	99 27       	eor	r25, r25
    1368:	9a 83       	std	Y+2, r25	; 0x02
    136a:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
    136c:	89 81       	ldd	r24, Y+1	; 0x01
    136e:	eb 81       	ldd	r30, Y+3	; 0x03
    1370:	fc 81       	ldd	r31, Y+4	; 0x04
    1372:	80 83       	st	Z, r24
	pxTopOfStack--;
    1374:	8b 81       	ldd	r24, Y+3	; 0x03
    1376:	9c 81       	ldd	r25, Y+4	; 0x04
    1378:	01 97       	sbiw	r24, 0x01	; 1
    137a:	9c 83       	std	Y+4, r25	; 0x04
    137c:	8b 83       	std	Y+3, r24	; 0x03

	*pxTopOfStack = ( StackType_t ) 0x26;	/* R26 X */
    137e:	eb 81       	ldd	r30, Y+3	; 0x03
    1380:	fc 81       	ldd	r31, Y+4	; 0x04
    1382:	86 e2       	ldi	r24, 0x26	; 38
    1384:	80 83       	st	Z, r24
	pxTopOfStack--;
    1386:	8b 81       	ldd	r24, Y+3	; 0x03
    1388:	9c 81       	ldd	r25, Y+4	; 0x04
    138a:	01 97       	sbiw	r24, 0x01	; 1
    138c:	9c 83       	std	Y+4, r25	; 0x04
    138e:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x27;	/* R27 */
    1390:	eb 81       	ldd	r30, Y+3	; 0x03
    1392:	fc 81       	ldd	r31, Y+4	; 0x04
    1394:	87 e2       	ldi	r24, 0x27	; 39
    1396:	80 83       	st	Z, r24
	pxTopOfStack--;
    1398:	8b 81       	ldd	r24, Y+3	; 0x03
    139a:	9c 81       	ldd	r25, Y+4	; 0x04
    139c:	01 97       	sbiw	r24, 0x01	; 1
    139e:	9c 83       	std	Y+4, r25	; 0x04
    13a0:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x28;	/* R28 Y */
    13a2:	eb 81       	ldd	r30, Y+3	; 0x03
    13a4:	fc 81       	ldd	r31, Y+4	; 0x04
    13a6:	88 e2       	ldi	r24, 0x28	; 40
    13a8:	80 83       	st	Z, r24
	pxTopOfStack--;
    13aa:	8b 81       	ldd	r24, Y+3	; 0x03
    13ac:	9c 81       	ldd	r25, Y+4	; 0x04
    13ae:	01 97       	sbiw	r24, 0x01	; 1
    13b0:	9c 83       	std	Y+4, r25	; 0x04
    13b2:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x29;	/* R29 */
    13b4:	eb 81       	ldd	r30, Y+3	; 0x03
    13b6:	fc 81       	ldd	r31, Y+4	; 0x04
    13b8:	89 e2       	ldi	r24, 0x29	; 41
    13ba:	80 83       	st	Z, r24
	pxTopOfStack--;
    13bc:	8b 81       	ldd	r24, Y+3	; 0x03
    13be:	9c 81       	ldd	r25, Y+4	; 0x04
    13c0:	01 97       	sbiw	r24, 0x01	; 1
    13c2:	9c 83       	std	Y+4, r25	; 0x04
    13c4:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x30;	/* R30 Z */
    13c6:	eb 81       	ldd	r30, Y+3	; 0x03
    13c8:	fc 81       	ldd	r31, Y+4	; 0x04
    13ca:	80 e3       	ldi	r24, 0x30	; 48
    13cc:	80 83       	st	Z, r24
	pxTopOfStack--;
    13ce:	8b 81       	ldd	r24, Y+3	; 0x03
    13d0:	9c 81       	ldd	r25, Y+4	; 0x04
    13d2:	01 97       	sbiw	r24, 0x01	; 1
    13d4:	9c 83       	std	Y+4, r25	; 0x04
    13d6:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x031;	/* R31 */
    13d8:	eb 81       	ldd	r30, Y+3	; 0x03
    13da:	fc 81       	ldd	r31, Y+4	; 0x04
    13dc:	81 e3       	ldi	r24, 0x31	; 49
    13de:	80 83       	st	Z, r24
	pxTopOfStack--;
    13e0:	8b 81       	ldd	r24, Y+3	; 0x03
    13e2:	9c 81       	ldd	r25, Y+4	; 0x04
    13e4:	01 97       	sbiw	r24, 0x01	; 1
    13e6:	9c 83       	std	Y+4, r25	; 0x04
    13e8:	8b 83       	std	Y+3, r24	; 0x03

	/*lint +e950 +e611 +e923 */

	return pxTopOfStack;
    13ea:	8b 81       	ldd	r24, Y+3	; 0x03
    13ec:	9c 81       	ldd	r25, Y+4	; 0x04
}
    13ee:	28 96       	adiw	r28, 0x08	; 8
    13f0:	0f b6       	in	r0, 0x3f	; 63
    13f2:	f8 94       	cli
    13f4:	de bf       	out	0x3e, r29	; 62
    13f6:	0f be       	out	0x3f, r0	; 63
    13f8:	cd bf       	out	0x3d, r28	; 61
    13fa:	cf 91       	pop	r28
    13fc:	df 91       	pop	r29
    13fe:	08 95       	ret

00001400 <xPortStartScheduler>:
/*-----------------------------------------------------------*/

BaseType_t xPortStartScheduler( void )
{
    1400:	df 93       	push	r29
    1402:	cf 93       	push	r28
    1404:	cd b7       	in	r28, 0x3d	; 61
    1406:	de b7       	in	r29, 0x3e	; 62
	/* Setup the hardware to generate the tick. */
	prvSetupTimerInterrupt();
    1408:	0e 94 f2 0a 	call	0x15e4	; 0x15e4 <prvSetupTimerInterrupt>

	/* Restore the context of the first task that is going to run. */
	portRESTORE_CONTEXT();
    140c:	a0 91 48 06 	lds	r26, 0x0648
    1410:	b0 91 49 06 	lds	r27, 0x0649
    1414:	cd 91       	ld	r28, X+
    1416:	cd bf       	out	0x3d, r28	; 61
    1418:	dd 91       	ld	r29, X+
    141a:	de bf       	out	0x3e, r29	; 62
    141c:	ff 91       	pop	r31
    141e:	ef 91       	pop	r30
    1420:	df 91       	pop	r29
    1422:	cf 91       	pop	r28
    1424:	bf 91       	pop	r27
    1426:	af 91       	pop	r26
    1428:	9f 91       	pop	r25
    142a:	8f 91       	pop	r24
    142c:	7f 91       	pop	r23
    142e:	6f 91       	pop	r22
    1430:	5f 91       	pop	r21
    1432:	4f 91       	pop	r20
    1434:	3f 91       	pop	r19
    1436:	2f 91       	pop	r18
    1438:	1f 91       	pop	r17
    143a:	0f 91       	pop	r16
    143c:	ff 90       	pop	r15
    143e:	ef 90       	pop	r14
    1440:	df 90       	pop	r13
    1442:	cf 90       	pop	r12
    1444:	bf 90       	pop	r11
    1446:	af 90       	pop	r10
    1448:	9f 90       	pop	r9
    144a:	8f 90       	pop	r8
    144c:	7f 90       	pop	r7
    144e:	6f 90       	pop	r6
    1450:	5f 90       	pop	r5
    1452:	4f 90       	pop	r4
    1454:	3f 90       	pop	r3
    1456:	2f 90       	pop	r2
    1458:	1f 90       	pop	r1
    145a:	0f 90       	pop	r0
    145c:	0f be       	out	0x3f, r0	; 63
    145e:	0f 90       	pop	r0

	/* Simulate a function call end as generated by the compiler.  We will now
	jump to the start of the task the context of which we have just restored. */
	asm volatile ( "ret" );
    1460:	08 95       	ret

	/* Should not get here. */
	return pdTRUE;
    1462:	81 e0       	ldi	r24, 0x01	; 1
}
    1464:	cf 91       	pop	r28
    1466:	df 91       	pop	r29
    1468:	08 95       	ret

0000146a <vPortEndScheduler>:
/*-----------------------------------------------------------*/

void vPortEndScheduler( void )
{
    146a:	df 93       	push	r29
    146c:	cf 93       	push	r28
    146e:	cd b7       	in	r28, 0x3d	; 61
    1470:	de b7       	in	r29, 0x3e	; 62
	/* It is unlikely that the AVR port will get stopped.  If required simply
	disable the tick interrupt here. */
}
    1472:	cf 91       	pop	r28
    1474:	df 91       	pop	r29
    1476:	08 95       	ret

00001478 <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
    1478:	0f 92       	push	r0
    147a:	0f b6       	in	r0, 0x3f	; 63
    147c:	f8 94       	cli
    147e:	0f 92       	push	r0
    1480:	1f 92       	push	r1
    1482:	11 24       	eor	r1, r1
    1484:	2f 92       	push	r2
    1486:	3f 92       	push	r3
    1488:	4f 92       	push	r4
    148a:	5f 92       	push	r5
    148c:	6f 92       	push	r6
    148e:	7f 92       	push	r7
    1490:	8f 92       	push	r8
    1492:	9f 92       	push	r9
    1494:	af 92       	push	r10
    1496:	bf 92       	push	r11
    1498:	cf 92       	push	r12
    149a:	df 92       	push	r13
    149c:	ef 92       	push	r14
    149e:	ff 92       	push	r15
    14a0:	0f 93       	push	r16
    14a2:	1f 93       	push	r17
    14a4:	2f 93       	push	r18
    14a6:	3f 93       	push	r19
    14a8:	4f 93       	push	r20
    14aa:	5f 93       	push	r21
    14ac:	6f 93       	push	r22
    14ae:	7f 93       	push	r23
    14b0:	8f 93       	push	r24
    14b2:	9f 93       	push	r25
    14b4:	af 93       	push	r26
    14b6:	bf 93       	push	r27
    14b8:	cf 93       	push	r28
    14ba:	df 93       	push	r29
    14bc:	ef 93       	push	r30
    14be:	ff 93       	push	r31
    14c0:	a0 91 48 06 	lds	r26, 0x0648
    14c4:	b0 91 49 06 	lds	r27, 0x0649
    14c8:	0d b6       	in	r0, 0x3d	; 61
    14ca:	0d 92       	st	X+, r0
    14cc:	0e b6       	in	r0, 0x3e	; 62
    14ce:	0d 92       	st	X+, r0
	vTaskSwitchContext();
    14d0:	0e 94 25 21 	call	0x424a	; 0x424a <vTaskSwitchContext>
	portRESTORE_CONTEXT();
    14d4:	a0 91 48 06 	lds	r26, 0x0648
    14d8:	b0 91 49 06 	lds	r27, 0x0649
    14dc:	cd 91       	ld	r28, X+
    14de:	cd bf       	out	0x3d, r28	; 61
    14e0:	dd 91       	ld	r29, X+
    14e2:	de bf       	out	0x3e, r29	; 62
    14e4:	ff 91       	pop	r31
    14e6:	ef 91       	pop	r30
    14e8:	df 91       	pop	r29
    14ea:	cf 91       	pop	r28
    14ec:	bf 91       	pop	r27
    14ee:	af 91       	pop	r26
    14f0:	9f 91       	pop	r25
    14f2:	8f 91       	pop	r24
    14f4:	7f 91       	pop	r23
    14f6:	6f 91       	pop	r22
    14f8:	5f 91       	pop	r21
    14fa:	4f 91       	pop	r20
    14fc:	3f 91       	pop	r19
    14fe:	2f 91       	pop	r18
    1500:	1f 91       	pop	r17
    1502:	0f 91       	pop	r16
    1504:	ff 90       	pop	r15
    1506:	ef 90       	pop	r14
    1508:	df 90       	pop	r13
    150a:	cf 90       	pop	r12
    150c:	bf 90       	pop	r11
    150e:	af 90       	pop	r10
    1510:	9f 90       	pop	r9
    1512:	8f 90       	pop	r8
    1514:	7f 90       	pop	r7
    1516:	6f 90       	pop	r6
    1518:	5f 90       	pop	r5
    151a:	4f 90       	pop	r4
    151c:	3f 90       	pop	r3
    151e:	2f 90       	pop	r2
    1520:	1f 90       	pop	r1
    1522:	0f 90       	pop	r0
    1524:	0f be       	out	0x3f, r0	; 63
    1526:	0f 90       	pop	r0

	asm volatile ( "ret" );
    1528:	08 95       	ret

0000152a <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
    152a:	0f 92       	push	r0
    152c:	0f b6       	in	r0, 0x3f	; 63
    152e:	f8 94       	cli
    1530:	0f 92       	push	r0
    1532:	1f 92       	push	r1
    1534:	11 24       	eor	r1, r1
    1536:	2f 92       	push	r2
    1538:	3f 92       	push	r3
    153a:	4f 92       	push	r4
    153c:	5f 92       	push	r5
    153e:	6f 92       	push	r6
    1540:	7f 92       	push	r7
    1542:	8f 92       	push	r8
    1544:	9f 92       	push	r9
    1546:	af 92       	push	r10
    1548:	bf 92       	push	r11
    154a:	cf 92       	push	r12
    154c:	df 92       	push	r13
    154e:	ef 92       	push	r14
    1550:	ff 92       	push	r15
    1552:	0f 93       	push	r16
    1554:	1f 93       	push	r17
    1556:	2f 93       	push	r18
    1558:	3f 93       	push	r19
    155a:	4f 93       	push	r20
    155c:	5f 93       	push	r21
    155e:	6f 93       	push	r22
    1560:	7f 93       	push	r23
    1562:	8f 93       	push	r24
    1564:	9f 93       	push	r25
    1566:	af 93       	push	r26
    1568:	bf 93       	push	r27
    156a:	cf 93       	push	r28
    156c:	df 93       	push	r29
    156e:	ef 93       	push	r30
    1570:	ff 93       	push	r31
    1572:	a0 91 48 06 	lds	r26, 0x0648
    1576:	b0 91 49 06 	lds	r27, 0x0649
    157a:	0d b6       	in	r0, 0x3d	; 61
    157c:	0d 92       	st	X+, r0
    157e:	0e b6       	in	r0, 0x3e	; 62
    1580:	0d 92       	st	X+, r0
	if( xTaskIncrementTick() != pdFALSE )
    1582:	0e 94 40 20 	call	0x4080	; 0x4080 <xTaskIncrementTick>
    1586:	88 23       	and	r24, r24
    1588:	11 f0       	breq	.+4      	; 0x158e <vPortYieldFromTick+0x64>
	{
		vTaskSwitchContext();
    158a:	0e 94 25 21 	call	0x424a	; 0x424a <vTaskSwitchContext>
	}
	portRESTORE_CONTEXT();
    158e:	a0 91 48 06 	lds	r26, 0x0648
    1592:	b0 91 49 06 	lds	r27, 0x0649
    1596:	cd 91       	ld	r28, X+
    1598:	cd bf       	out	0x3d, r28	; 61
    159a:	dd 91       	ld	r29, X+
    159c:	de bf       	out	0x3e, r29	; 62
    159e:	ff 91       	pop	r31
    15a0:	ef 91       	pop	r30
    15a2:	df 91       	pop	r29
    15a4:	cf 91       	pop	r28
    15a6:	bf 91       	pop	r27
    15a8:	af 91       	pop	r26
    15aa:	9f 91       	pop	r25
    15ac:	8f 91       	pop	r24
    15ae:	7f 91       	pop	r23
    15b0:	6f 91       	pop	r22
    15b2:	5f 91       	pop	r21
    15b4:	4f 91       	pop	r20
    15b6:	3f 91       	pop	r19
    15b8:	2f 91       	pop	r18
    15ba:	1f 91       	pop	r17
    15bc:	0f 91       	pop	r16
    15be:	ff 90       	pop	r15
    15c0:	ef 90       	pop	r14
    15c2:	df 90       	pop	r13
    15c4:	cf 90       	pop	r12
    15c6:	bf 90       	pop	r11
    15c8:	af 90       	pop	r10
    15ca:	9f 90       	pop	r9
    15cc:	8f 90       	pop	r8
    15ce:	7f 90       	pop	r7
    15d0:	6f 90       	pop	r6
    15d2:	5f 90       	pop	r5
    15d4:	4f 90       	pop	r4
    15d6:	3f 90       	pop	r3
    15d8:	2f 90       	pop	r2
    15da:	1f 90       	pop	r1
    15dc:	0f 90       	pop	r0
    15de:	0f be       	out	0x3f, r0	; 63
    15e0:	0f 90       	pop	r0

	asm volatile ( "ret" );
    15e2:	08 95       	ret

000015e4 <prvSetupTimerInterrupt>:

/*
 * Setup timer 1 compare match A to generate a tick interrupt.
 */
static void prvSetupTimerInterrupt( void )
{
    15e4:	df 93       	push	r29
    15e6:	cf 93       	push	r28
    15e8:	00 d0       	rcall	.+0      	; 0x15ea <prvSetupTimerInterrupt+0x6>
    15ea:	00 d0       	rcall	.+0      	; 0x15ec <prvSetupTimerInterrupt+0x8>
    15ec:	00 d0       	rcall	.+0      	; 0x15ee <prvSetupTimerInterrupt+0xa>
    15ee:	cd b7       	in	r28, 0x3d	; 61
    15f0:	de b7       	in	r29, 0x3e	; 62
uint8_t ucHighByte, ucLowByte;

	/* Using 16bit timer 1 to generate the tick.  Correct fuses must be
	selected for the configCPU_CLOCK_HZ clock. */

	ulCompareMatch = configCPU_CLOCK_HZ / configTICK_RATE_HZ;
    15f2:	80 e4       	ldi	r24, 0x40	; 64
    15f4:	9f e1       	ldi	r25, 0x1F	; 31
    15f6:	a0 e0       	ldi	r26, 0x00	; 0
    15f8:	b0 e0       	ldi	r27, 0x00	; 0
    15fa:	8b 83       	std	Y+3, r24	; 0x03
    15fc:	9c 83       	std	Y+4, r25	; 0x04
    15fe:	ad 83       	std	Y+5, r26	; 0x05
    1600:	be 83       	std	Y+6, r27	; 0x06

	/* We only have 16 bits so have to scale to get our required tick rate. */
	ulCompareMatch /= portCLOCK_PRESCALER;
    1602:	8b 81       	ldd	r24, Y+3	; 0x03
    1604:	9c 81       	ldd	r25, Y+4	; 0x04
    1606:	ad 81       	ldd	r26, Y+5	; 0x05
    1608:	be 81       	ldd	r27, Y+6	; 0x06
    160a:	68 94       	set
    160c:	15 f8       	bld	r1, 5
    160e:	b6 95       	lsr	r27
    1610:	a7 95       	ror	r26
    1612:	97 95       	ror	r25
    1614:	87 95       	ror	r24
    1616:	16 94       	lsr	r1
    1618:	d1 f7       	brne	.-12     	; 0x160e <prvSetupTimerInterrupt+0x2a>
    161a:	8b 83       	std	Y+3, r24	; 0x03
    161c:	9c 83       	std	Y+4, r25	; 0x04
    161e:	ad 83       	std	Y+5, r26	; 0x05
    1620:	be 83       	std	Y+6, r27	; 0x06

	/* Adjust for correct value. */
	ulCompareMatch -= ( uint32_t ) 1;
    1622:	8b 81       	ldd	r24, Y+3	; 0x03
    1624:	9c 81       	ldd	r25, Y+4	; 0x04
    1626:	ad 81       	ldd	r26, Y+5	; 0x05
    1628:	be 81       	ldd	r27, Y+6	; 0x06
    162a:	01 97       	sbiw	r24, 0x01	; 1
    162c:	a1 09       	sbc	r26, r1
    162e:	b1 09       	sbc	r27, r1
    1630:	8b 83       	std	Y+3, r24	; 0x03
    1632:	9c 83       	std	Y+4, r25	; 0x04
    1634:	ad 83       	std	Y+5, r26	; 0x05
    1636:	be 83       	std	Y+6, r27	; 0x06

	/* Setup compare match value for compare match A.  Interrupts are disabled 
	before this is called so we need not worry here. */
	ucLowByte = ( uint8_t ) ( ulCompareMatch & ( uint32_t ) 0xff );
    1638:	8b 81       	ldd	r24, Y+3	; 0x03
    163a:	89 83       	std	Y+1, r24	; 0x01
	ulCompareMatch >>= 8;
    163c:	8b 81       	ldd	r24, Y+3	; 0x03
    163e:	9c 81       	ldd	r25, Y+4	; 0x04
    1640:	ad 81       	ldd	r26, Y+5	; 0x05
    1642:	be 81       	ldd	r27, Y+6	; 0x06
    1644:	89 2f       	mov	r24, r25
    1646:	9a 2f       	mov	r25, r26
    1648:	ab 2f       	mov	r26, r27
    164a:	bb 27       	eor	r27, r27
    164c:	8b 83       	std	Y+3, r24	; 0x03
    164e:	9c 83       	std	Y+4, r25	; 0x04
    1650:	ad 83       	std	Y+5, r26	; 0x05
    1652:	be 83       	std	Y+6, r27	; 0x06
	ucHighByte = ( uint8_t ) ( ulCompareMatch & ( uint32_t ) 0xff );
    1654:	8b 81       	ldd	r24, Y+3	; 0x03
    1656:	8a 83       	std	Y+2, r24	; 0x02
	OCR1AH = ucHighByte;
    1658:	eb e4       	ldi	r30, 0x4B	; 75
    165a:	f0 e0       	ldi	r31, 0x00	; 0
    165c:	8a 81       	ldd	r24, Y+2	; 0x02
    165e:	80 83       	st	Z, r24
	OCR1AL = ucLowByte;
    1660:	ea e4       	ldi	r30, 0x4A	; 74
    1662:	f0 e0       	ldi	r31, 0x00	; 0
    1664:	89 81       	ldd	r24, Y+1	; 0x01
    1666:	80 83       	st	Z, r24

	/* Setup clock source and compare match behaviour. */
	ucLowByte = portCLEAR_COUNTER_ON_MATCH | portPRESCALE_64;
    1668:	8b e0       	ldi	r24, 0x0B	; 11
    166a:	89 83       	std	Y+1, r24	; 0x01
	TCCR1B = ucLowByte;
    166c:	ee e4       	ldi	r30, 0x4E	; 78
    166e:	f0 e0       	ldi	r31, 0x00	; 0
    1670:	89 81       	ldd	r24, Y+1	; 0x01
    1672:	80 83       	st	Z, r24

	/* Enable the interrupt - this is okay as interrupt are currently globally
	disabled. */
	ucLowByte = TIMSK;
    1674:	e9 e5       	ldi	r30, 0x59	; 89
    1676:	f0 e0       	ldi	r31, 0x00	; 0
    1678:	80 81       	ld	r24, Z
    167a:	89 83       	std	Y+1, r24	; 0x01
	ucLowByte |= portCOMPARE_MATCH_A_INTERRUPT_ENABLE;
    167c:	89 81       	ldd	r24, Y+1	; 0x01
    167e:	80 61       	ori	r24, 0x10	; 16
    1680:	89 83       	std	Y+1, r24	; 0x01
	TIMSK = ucLowByte;
    1682:	e9 e5       	ldi	r30, 0x59	; 89
    1684:	f0 e0       	ldi	r31, 0x00	; 0
    1686:	89 81       	ldd	r24, Y+1	; 0x01
    1688:	80 83       	st	Z, r24
}
    168a:	26 96       	adiw	r28, 0x06	; 6
    168c:	0f b6       	in	r0, 0x3f	; 63
    168e:	f8 94       	cli
    1690:	de bf       	out	0x3e, r29	; 62
    1692:	0f be       	out	0x3f, r0	; 63
    1694:	cd bf       	out	0x3d, r28	; 61
    1696:	cf 91       	pop	r28
    1698:	df 91       	pop	r29
    169a:	08 95       	ret

0000169c <__vector_7>:
	 * count is incremented after the context is saved.
	 */
	void TIMER1_COMPA_vect( void ) __attribute__ ( ( signal, naked ) );
	void TIMER1_COMPA_vect( void )
	{
		vPortYieldFromTick();
    169c:	0e 94 95 0a 	call	0x152a	; 0x152a <vPortYieldFromTick>
		asm volatile ( "reti" );
    16a0:	18 95       	reti

000016a2 <xQueueGenericReset>:
	}														\
	taskEXIT_CRITICAL()
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericReset( QueueHandle_t xQueue, BaseType_t xNewQueue )
{
    16a2:	df 93       	push	r29
    16a4:	cf 93       	push	r28
    16a6:	00 d0       	rcall	.+0      	; 0x16a8 <xQueueGenericReset+0x6>
    16a8:	00 d0       	rcall	.+0      	; 0x16aa <xQueueGenericReset+0x8>
    16aa:	0f 92       	push	r0
    16ac:	cd b7       	in	r28, 0x3d	; 61
    16ae:	de b7       	in	r29, 0x3e	; 62
    16b0:	9c 83       	std	Y+4, r25	; 0x04
    16b2:	8b 83       	std	Y+3, r24	; 0x03
    16b4:	6d 83       	std	Y+5, r22	; 0x05
Queue_t * const pxQueue = xQueue;
    16b6:	8b 81       	ldd	r24, Y+3	; 0x03
    16b8:	9c 81       	ldd	r25, Y+4	; 0x04
    16ba:	9a 83       	std	Y+2, r25	; 0x02
    16bc:	89 83       	std	Y+1, r24	; 0x01

	configASSERT( pxQueue );

	taskENTER_CRITICAL();
    16be:	0f b6       	in	r0, 0x3f	; 63
    16c0:	f8 94       	cli
    16c2:	0f 92       	push	r0
	{
		pxQueue->u.xQueue.pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
    16c4:	e9 81       	ldd	r30, Y+1	; 0x01
    16c6:	fa 81       	ldd	r31, Y+2	; 0x02
    16c8:	40 81       	ld	r20, Z
    16ca:	51 81       	ldd	r21, Z+1	; 0x01
    16cc:	e9 81       	ldd	r30, Y+1	; 0x01
    16ce:	fa 81       	ldd	r31, Y+2	; 0x02
    16d0:	83 8d       	ldd	r24, Z+27	; 0x1b
    16d2:	28 2f       	mov	r18, r24
    16d4:	30 e0       	ldi	r19, 0x00	; 0
    16d6:	e9 81       	ldd	r30, Y+1	; 0x01
    16d8:	fa 81       	ldd	r31, Y+2	; 0x02
    16da:	84 8d       	ldd	r24, Z+28	; 0x1c
    16dc:	88 2f       	mov	r24, r24
    16de:	90 e0       	ldi	r25, 0x00	; 0
    16e0:	bc 01       	movw	r22, r24
    16e2:	26 9f       	mul	r18, r22
    16e4:	c0 01       	movw	r24, r0
    16e6:	27 9f       	mul	r18, r23
    16e8:	90 0d       	add	r25, r0
    16ea:	36 9f       	mul	r19, r22
    16ec:	90 0d       	add	r25, r0
    16ee:	11 24       	eor	r1, r1
    16f0:	84 0f       	add	r24, r20
    16f2:	95 1f       	adc	r25, r21
    16f4:	e9 81       	ldd	r30, Y+1	; 0x01
    16f6:	fa 81       	ldd	r31, Y+2	; 0x02
    16f8:	95 83       	std	Z+5, r25	; 0x05
    16fa:	84 83       	std	Z+4, r24	; 0x04
		pxQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
    16fc:	e9 81       	ldd	r30, Y+1	; 0x01
    16fe:	fa 81       	ldd	r31, Y+2	; 0x02
    1700:	12 8e       	std	Z+26, r1	; 0x1a
		pxQueue->pcWriteTo = pxQueue->pcHead;
    1702:	e9 81       	ldd	r30, Y+1	; 0x01
    1704:	fa 81       	ldd	r31, Y+2	; 0x02
    1706:	80 81       	ld	r24, Z
    1708:	91 81       	ldd	r25, Z+1	; 0x01
    170a:	e9 81       	ldd	r30, Y+1	; 0x01
    170c:	fa 81       	ldd	r31, Y+2	; 0x02
    170e:	93 83       	std	Z+3, r25	; 0x03
    1710:	82 83       	std	Z+2, r24	; 0x02
		pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - 1U ) * pxQueue->uxItemSize ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
    1712:	e9 81       	ldd	r30, Y+1	; 0x01
    1714:	fa 81       	ldd	r31, Y+2	; 0x02
    1716:	40 81       	ld	r20, Z
    1718:	51 81       	ldd	r21, Z+1	; 0x01
    171a:	e9 81       	ldd	r30, Y+1	; 0x01
    171c:	fa 81       	ldd	r31, Y+2	; 0x02
    171e:	83 8d       	ldd	r24, Z+27	; 0x1b
    1720:	88 2f       	mov	r24, r24
    1722:	90 e0       	ldi	r25, 0x00	; 0
    1724:	9c 01       	movw	r18, r24
    1726:	21 50       	subi	r18, 0x01	; 1
    1728:	30 40       	sbci	r19, 0x00	; 0
    172a:	e9 81       	ldd	r30, Y+1	; 0x01
    172c:	fa 81       	ldd	r31, Y+2	; 0x02
    172e:	84 8d       	ldd	r24, Z+28	; 0x1c
    1730:	88 2f       	mov	r24, r24
    1732:	90 e0       	ldi	r25, 0x00	; 0
    1734:	bc 01       	movw	r22, r24
    1736:	26 9f       	mul	r18, r22
    1738:	c0 01       	movw	r24, r0
    173a:	27 9f       	mul	r18, r23
    173c:	90 0d       	add	r25, r0
    173e:	36 9f       	mul	r19, r22
    1740:	90 0d       	add	r25, r0
    1742:	11 24       	eor	r1, r1
    1744:	84 0f       	add	r24, r20
    1746:	95 1f       	adc	r25, r21
    1748:	e9 81       	ldd	r30, Y+1	; 0x01
    174a:	fa 81       	ldd	r31, Y+2	; 0x02
    174c:	97 83       	std	Z+7, r25	; 0x07
    174e:	86 83       	std	Z+6, r24	; 0x06
		pxQueue->cRxLock = queueUNLOCKED;
    1750:	e9 81       	ldd	r30, Y+1	; 0x01
    1752:	fa 81       	ldd	r31, Y+2	; 0x02
    1754:	8f ef       	ldi	r24, 0xFF	; 255
    1756:	85 8f       	std	Z+29, r24	; 0x1d
		pxQueue->cTxLock = queueUNLOCKED;
    1758:	e9 81       	ldd	r30, Y+1	; 0x01
    175a:	fa 81       	ldd	r31, Y+2	; 0x02
    175c:	8f ef       	ldi	r24, 0xFF	; 255
    175e:	86 8f       	std	Z+30, r24	; 0x1e

		if( xNewQueue == pdFALSE )
    1760:	8d 81       	ldd	r24, Y+5	; 0x05
    1762:	88 23       	and	r24, r24
    1764:	79 f4       	brne	.+30     	; 0x1784 <xQueueGenericReset+0xe2>
			/* If there are tasks blocked waiting to read from the queue, then
			the tasks will remain blocked as after this function exits the queue
			will still be empty.  If there are tasks blocked waiting to write to
			the queue, then one should be unblocked as after this function exits
			it will be possible to write to it. */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    1766:	e9 81       	ldd	r30, Y+1	; 0x01
    1768:	fa 81       	ldd	r31, Y+2	; 0x02
    176a:	80 85       	ldd	r24, Z+8	; 0x08
    176c:	88 23       	and	r24, r24
    176e:	a1 f0       	breq	.+40     	; 0x1798 <xQueueGenericReset+0xf6>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    1770:	89 81       	ldd	r24, Y+1	; 0x01
    1772:	9a 81       	ldd	r25, Y+2	; 0x02
    1774:	08 96       	adiw	r24, 0x08	; 8
    1776:	0e 94 e4 21 	call	0x43c8	; 0x43c8 <xTaskRemoveFromEventList>
    177a:	88 23       	and	r24, r24
    177c:	69 f0       	breq	.+26     	; 0x1798 <xQueueGenericReset+0xf6>
				{
					queueYIELD_IF_USING_PREEMPTION();
    177e:	0e 94 3c 0a 	call	0x1478	; 0x1478 <vPortYield>
    1782:	0a c0       	rjmp	.+20     	; 0x1798 <xQueueGenericReset+0xf6>
			}
		}
		else
		{
			/* Ensure the event queues start in the correct state. */
			vListInitialise( &( pxQueue->xTasksWaitingToSend ) );
    1784:	89 81       	ldd	r24, Y+1	; 0x01
    1786:	9a 81       	ldd	r25, Y+2	; 0x02
    1788:	08 96       	adiw	r24, 0x08	; 8
    178a:	0e 94 a6 06 	call	0xd4c	; 0xd4c <vListInitialise>
			vListInitialise( &( pxQueue->xTasksWaitingToReceive ) );
    178e:	89 81       	ldd	r24, Y+1	; 0x01
    1790:	9a 81       	ldd	r25, Y+2	; 0x02
    1792:	41 96       	adiw	r24, 0x11	; 17
    1794:	0e 94 a6 06 	call	0xd4c	; 0xd4c <vListInitialise>
		}
	}
	taskEXIT_CRITICAL();
    1798:	0f 90       	pop	r0
    179a:	0f be       	out	0x3f, r0	; 63

	/* A value is returned for calling semantic consistency with previous
	versions. */
	return pdPASS;
    179c:	81 e0       	ldi	r24, 0x01	; 1
}
    179e:	0f 90       	pop	r0
    17a0:	0f 90       	pop	r0
    17a2:	0f 90       	pop	r0
    17a4:	0f 90       	pop	r0
    17a6:	0f 90       	pop	r0
    17a8:	cf 91       	pop	r28
    17aa:	df 91       	pop	r29
    17ac:	08 95       	ret

000017ae <xQueueGenericCreate>:
/*-----------------------------------------------------------*/

#if( configSUPPORT_DYNAMIC_ALLOCATION == 1 )

	QueueHandle_t xQueueGenericCreate( const UBaseType_t uxQueueLength, const UBaseType_t uxItemSize, const uint8_t ucQueueType )
	{
    17ae:	0f 93       	push	r16
    17b0:	1f 93       	push	r17
    17b2:	df 93       	push	r29
    17b4:	cf 93       	push	r28
    17b6:	cd b7       	in	r28, 0x3d	; 61
    17b8:	de b7       	in	r29, 0x3e	; 62
    17ba:	29 97       	sbiw	r28, 0x09	; 9
    17bc:	0f b6       	in	r0, 0x3f	; 63
    17be:	f8 94       	cli
    17c0:	de bf       	out	0x3e, r29	; 62
    17c2:	0f be       	out	0x3f, r0	; 63
    17c4:	cd bf       	out	0x3d, r28	; 61
    17c6:	8f 83       	std	Y+7, r24	; 0x07
    17c8:	68 87       	std	Y+8, r22	; 0x08
    17ca:	49 87       	std	Y+9, r20	; 0x09
	size_t xQueueSizeInBytes;
	uint8_t *pucQueueStorage;

		configASSERT( uxQueueLength > ( UBaseType_t ) 0 );

		if( uxItemSize == ( UBaseType_t ) 0 )
    17cc:	88 85       	ldd	r24, Y+8	; 0x08
    17ce:	88 23       	and	r24, r24
    17d0:	19 f4       	brne	.+6      	; 0x17d8 <xQueueGenericCreate+0x2a>
		{
			/* There is not going to be a queue storage area. */
			xQueueSizeInBytes = ( size_t ) 0;
    17d2:	1c 82       	std	Y+4, r1	; 0x04
    17d4:	1b 82       	std	Y+3, r1	; 0x03
    17d6:	10 c0       	rjmp	.+32     	; 0x17f8 <xQueueGenericCreate+0x4a>
		}
		else
		{
			/* Allocate enough space to hold the maximum number of items that
			can be in the queue at any time. */
			xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    17d8:	8f 81       	ldd	r24, Y+7	; 0x07
    17da:	28 2f       	mov	r18, r24
    17dc:	30 e0       	ldi	r19, 0x00	; 0
    17de:	88 85       	ldd	r24, Y+8	; 0x08
    17e0:	88 2f       	mov	r24, r24
    17e2:	90 e0       	ldi	r25, 0x00	; 0
    17e4:	ac 01       	movw	r20, r24
    17e6:	24 9f       	mul	r18, r20
    17e8:	c0 01       	movw	r24, r0
    17ea:	25 9f       	mul	r18, r21
    17ec:	90 0d       	add	r25, r0
    17ee:	34 9f       	mul	r19, r20
    17f0:	90 0d       	add	r25, r0
    17f2:	11 24       	eor	r1, r1
    17f4:	9c 83       	std	Y+4, r25	; 0x04
    17f6:	8b 83       	std	Y+3, r24	; 0x03
		alignment requirements of the Queue_t structure - which in this case
		is an int8_t *.  Therefore, whenever the stack alignment requirements
		are greater than or equal to the pointer to char requirements the cast
		is safe.  In other cases alignment requirements are not strict (one or
		two bytes). */
		pxNewQueue = ( Queue_t * ) pvPortMalloc( sizeof( Queue_t ) + xQueueSizeInBytes ); /*lint !e9087 !e9079 see comment above. */
    17f8:	8b 81       	ldd	r24, Y+3	; 0x03
    17fa:	9c 81       	ldd	r25, Y+4	; 0x04
    17fc:	4f 96       	adiw	r24, 0x1f	; 31
    17fe:	0e 94 2a 06 	call	0xc54	; 0xc54 <pvPortMalloc>
    1802:	9e 83       	std	Y+6, r25	; 0x06
    1804:	8d 83       	std	Y+5, r24	; 0x05

		if( pxNewQueue != NULL )
    1806:	8d 81       	ldd	r24, Y+5	; 0x05
    1808:	9e 81       	ldd	r25, Y+6	; 0x06
    180a:	00 97       	sbiw	r24, 0x00	; 0
    180c:	a1 f0       	breq	.+40     	; 0x1836 <xQueueGenericCreate+0x88>
		{
			/* Jump past the queue structure to find the location of the queue
			storage area. */
			pucQueueStorage = ( uint8_t * ) pxNewQueue;
    180e:	8d 81       	ldd	r24, Y+5	; 0x05
    1810:	9e 81       	ldd	r25, Y+6	; 0x06
    1812:	9a 83       	std	Y+2, r25	; 0x02
    1814:	89 83       	std	Y+1, r24	; 0x01
			pucQueueStorage += sizeof( Queue_t ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
    1816:	89 81       	ldd	r24, Y+1	; 0x01
    1818:	9a 81       	ldd	r25, Y+2	; 0x02
    181a:	4f 96       	adiw	r24, 0x1f	; 31
    181c:	9a 83       	std	Y+2, r25	; 0x02
    181e:	89 83       	std	Y+1, r24	; 0x01
				deleted. */
				pxNewQueue->ucStaticallyAllocated = pdFALSE;
			}
			#endif /* configSUPPORT_STATIC_ALLOCATION */

			prvInitialiseNewQueue( uxQueueLength, uxItemSize, pucQueueStorage, ucQueueType, pxNewQueue );
    1820:	29 81       	ldd	r18, Y+1	; 0x01
    1822:	3a 81       	ldd	r19, Y+2	; 0x02
    1824:	ed 81       	ldd	r30, Y+5	; 0x05
    1826:	fe 81       	ldd	r31, Y+6	; 0x06
    1828:	8f 81       	ldd	r24, Y+7	; 0x07
    182a:	68 85       	ldd	r22, Y+8	; 0x08
    182c:	a9 01       	movw	r20, r18
    182e:	29 85       	ldd	r18, Y+9	; 0x09
    1830:	8f 01       	movw	r16, r30
    1832:	0e 94 28 0c 	call	0x1850	; 0x1850 <prvInitialiseNewQueue>
		{
			traceQUEUE_CREATE_FAILED( ucQueueType );
			mtCOVERAGE_TEST_MARKER();
		}

		return pxNewQueue;
    1836:	8d 81       	ldd	r24, Y+5	; 0x05
    1838:	9e 81       	ldd	r25, Y+6	; 0x06
	}
    183a:	29 96       	adiw	r28, 0x09	; 9
    183c:	0f b6       	in	r0, 0x3f	; 63
    183e:	f8 94       	cli
    1840:	de bf       	out	0x3e, r29	; 62
    1842:	0f be       	out	0x3f, r0	; 63
    1844:	cd bf       	out	0x3d, r28	; 61
    1846:	cf 91       	pop	r28
    1848:	df 91       	pop	r29
    184a:	1f 91       	pop	r17
    184c:	0f 91       	pop	r16
    184e:	08 95       	ret

00001850 <prvInitialiseNewQueue>:

#endif /* configSUPPORT_STATIC_ALLOCATION */
/*-----------------------------------------------------------*/

static void prvInitialiseNewQueue( const UBaseType_t uxQueueLength, const UBaseType_t uxItemSize, uint8_t *pucQueueStorage, const uint8_t ucQueueType, Queue_t *pxNewQueue )
{
    1850:	0f 93       	push	r16
    1852:	1f 93       	push	r17
    1854:	df 93       	push	r29
    1856:	cf 93       	push	r28
    1858:	cd b7       	in	r28, 0x3d	; 61
    185a:	de b7       	in	r29, 0x3e	; 62
    185c:	27 97       	sbiw	r28, 0x07	; 7
    185e:	0f b6       	in	r0, 0x3f	; 63
    1860:	f8 94       	cli
    1862:	de bf       	out	0x3e, r29	; 62
    1864:	0f be       	out	0x3f, r0	; 63
    1866:	cd bf       	out	0x3d, r28	; 61
    1868:	89 83       	std	Y+1, r24	; 0x01
    186a:	6a 83       	std	Y+2, r22	; 0x02
    186c:	5c 83       	std	Y+4, r21	; 0x04
    186e:	4b 83       	std	Y+3, r20	; 0x03
    1870:	2d 83       	std	Y+5, r18	; 0x05
    1872:	1f 83       	std	Y+7, r17	; 0x07
    1874:	0e 83       	std	Y+6, r16	; 0x06
	/* Remove compiler warnings about unused parameters should
	configUSE_TRACE_FACILITY not be set to 1. */
	( void ) ucQueueType;

	if( uxItemSize == ( UBaseType_t ) 0 )
    1876:	8a 81       	ldd	r24, Y+2	; 0x02
    1878:	88 23       	and	r24, r24
    187a:	39 f4       	brne	.+14     	; 0x188a <prvInitialiseNewQueue+0x3a>
	{
		/* No RAM was allocated for the queue storage area, but PC head cannot
		be set to NULL because NULL is used as a key to say the queue is used as
		a mutex.  Therefore just set pcHead to point to the queue as a benign
		value that is known to be within the memory map. */
		pxNewQueue->pcHead = ( int8_t * ) pxNewQueue;
    187c:	8e 81       	ldd	r24, Y+6	; 0x06
    187e:	9f 81       	ldd	r25, Y+7	; 0x07
    1880:	ee 81       	ldd	r30, Y+6	; 0x06
    1882:	ff 81       	ldd	r31, Y+7	; 0x07
    1884:	91 83       	std	Z+1, r25	; 0x01
    1886:	80 83       	st	Z, r24
    1888:	06 c0       	rjmp	.+12     	; 0x1896 <prvInitialiseNewQueue+0x46>
	}
	else
	{
		/* Set the head to the start of the queue storage area. */
		pxNewQueue->pcHead = ( int8_t * ) pucQueueStorage;
    188a:	8b 81       	ldd	r24, Y+3	; 0x03
    188c:	9c 81       	ldd	r25, Y+4	; 0x04
    188e:	ee 81       	ldd	r30, Y+6	; 0x06
    1890:	ff 81       	ldd	r31, Y+7	; 0x07
    1892:	91 83       	std	Z+1, r25	; 0x01
    1894:	80 83       	st	Z, r24
	}

	/* Initialise the queue members as described where the queue type is
	defined. */
	pxNewQueue->uxLength = uxQueueLength;
    1896:	ee 81       	ldd	r30, Y+6	; 0x06
    1898:	ff 81       	ldd	r31, Y+7	; 0x07
    189a:	89 81       	ldd	r24, Y+1	; 0x01
    189c:	83 8f       	std	Z+27, r24	; 0x1b
	pxNewQueue->uxItemSize = uxItemSize;
    189e:	ee 81       	ldd	r30, Y+6	; 0x06
    18a0:	ff 81       	ldd	r31, Y+7	; 0x07
    18a2:	8a 81       	ldd	r24, Y+2	; 0x02
    18a4:	84 8f       	std	Z+28, r24	; 0x1c
	( void ) xQueueGenericReset( pxNewQueue, pdTRUE );
    18a6:	8e 81       	ldd	r24, Y+6	; 0x06
    18a8:	9f 81       	ldd	r25, Y+7	; 0x07
    18aa:	61 e0       	ldi	r22, 0x01	; 1
    18ac:	0e 94 51 0b 	call	0x16a2	; 0x16a2 <xQueueGenericReset>
		pxNewQueue->pxQueueSetContainer = NULL;
	}
	#endif /* configUSE_QUEUE_SETS */

	traceQUEUE_CREATE( pxNewQueue );
}
    18b0:	27 96       	adiw	r28, 0x07	; 7
    18b2:	0f b6       	in	r0, 0x3f	; 63
    18b4:	f8 94       	cli
    18b6:	de bf       	out	0x3e, r29	; 62
    18b8:	0f be       	out	0x3f, r0	; 63
    18ba:	cd bf       	out	0x3d, r28	; 61
    18bc:	cf 91       	pop	r28
    18be:	df 91       	pop	r29
    18c0:	1f 91       	pop	r17
    18c2:	0f 91       	pop	r16
    18c4:	08 95       	ret

000018c6 <prvInitialiseMutex>:
/*-----------------------------------------------------------*/

#if( configUSE_MUTEXES == 1 )

	static void prvInitialiseMutex( Queue_t *pxNewQueue )
	{
    18c6:	df 93       	push	r29
    18c8:	cf 93       	push	r28
    18ca:	00 d0       	rcall	.+0      	; 0x18cc <prvInitialiseMutex+0x6>
    18cc:	cd b7       	in	r28, 0x3d	; 61
    18ce:	de b7       	in	r29, 0x3e	; 62
    18d0:	9a 83       	std	Y+2, r25	; 0x02
    18d2:	89 83       	std	Y+1, r24	; 0x01
		if( pxNewQueue != NULL )
    18d4:	89 81       	ldd	r24, Y+1	; 0x01
    18d6:	9a 81       	ldd	r25, Y+2	; 0x02
    18d8:	00 97       	sbiw	r24, 0x00	; 0
    18da:	a1 f0       	breq	.+40     	; 0x1904 <prvInitialiseMutex+0x3e>
		{
			/* The queue create function will set all the queue structure members
			correctly for a generic queue, but this function is creating a
			mutex.  Overwrite those members that need to be set differently -
			in particular the information required for priority inheritance. */
			pxNewQueue->u.xSemaphore.xMutexHolder = NULL;
    18dc:	e9 81       	ldd	r30, Y+1	; 0x01
    18de:	fa 81       	ldd	r31, Y+2	; 0x02
    18e0:	15 82       	std	Z+5, r1	; 0x05
    18e2:	14 82       	std	Z+4, r1	; 0x04
			pxNewQueue->uxQueueType = queueQUEUE_IS_MUTEX;
    18e4:	e9 81       	ldd	r30, Y+1	; 0x01
    18e6:	fa 81       	ldd	r31, Y+2	; 0x02
    18e8:	11 82       	std	Z+1, r1	; 0x01
    18ea:	10 82       	st	Z, r1

			/* In case this is a recursive mutex. */
			pxNewQueue->u.xSemaphore.uxRecursiveCallCount = 0;
    18ec:	e9 81       	ldd	r30, Y+1	; 0x01
    18ee:	fa 81       	ldd	r31, Y+2	; 0x02
    18f0:	16 82       	std	Z+6, r1	; 0x06

			traceCREATE_MUTEX( pxNewQueue );

			/* Start with the semaphore in the expected state. */
			( void ) xQueueGenericSend( pxNewQueue, NULL, ( TickType_t ) 0U, queueSEND_TO_BACK );
    18f2:	89 81       	ldd	r24, Y+1	; 0x01
    18f4:	9a 81       	ldd	r25, Y+2	; 0x02
    18f6:	60 e0       	ldi	r22, 0x00	; 0
    18f8:	70 e0       	ldi	r23, 0x00	; 0
    18fa:	40 e0       	ldi	r20, 0x00	; 0
    18fc:	50 e0       	ldi	r21, 0x00	; 0
    18fe:	20 e0       	ldi	r18, 0x00	; 0
    1900:	0e 94 48 0d 	call	0x1a90	; 0x1a90 <xQueueGenericSend>
		}
		else
		{
			traceCREATE_MUTEX_FAILED();
		}
	}
    1904:	0f 90       	pop	r0
    1906:	0f 90       	pop	r0
    1908:	cf 91       	pop	r28
    190a:	df 91       	pop	r29
    190c:	08 95       	ret

0000190e <xQueueCreateMutex>:
/*-----------------------------------------------------------*/

#if( ( configUSE_MUTEXES == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) )

	QueueHandle_t xQueueCreateMutex( const uint8_t ucQueueType )
	{
    190e:	df 93       	push	r29
    1910:	cf 93       	push	r28
    1912:	00 d0       	rcall	.+0      	; 0x1914 <xQueueCreateMutex+0x6>
    1914:	00 d0       	rcall	.+0      	; 0x1916 <xQueueCreateMutex+0x8>
    1916:	0f 92       	push	r0
    1918:	cd b7       	in	r28, 0x3d	; 61
    191a:	de b7       	in	r29, 0x3e	; 62
    191c:	8d 83       	std	Y+5, r24	; 0x05
	QueueHandle_t xNewQueue;
	const UBaseType_t uxMutexLength = ( UBaseType_t ) 1, uxMutexSize = ( UBaseType_t ) 0;
    191e:	81 e0       	ldi	r24, 0x01	; 1
    1920:	8a 83       	std	Y+2, r24	; 0x02
    1922:	19 82       	std	Y+1, r1	; 0x01

		xNewQueue = xQueueGenericCreate( uxMutexLength, uxMutexSize, ucQueueType );
    1924:	8a 81       	ldd	r24, Y+2	; 0x02
    1926:	69 81       	ldd	r22, Y+1	; 0x01
    1928:	4d 81       	ldd	r20, Y+5	; 0x05
    192a:	0e 94 d7 0b 	call	0x17ae	; 0x17ae <xQueueGenericCreate>
    192e:	9c 83       	std	Y+4, r25	; 0x04
    1930:	8b 83       	std	Y+3, r24	; 0x03
		prvInitialiseMutex( ( Queue_t * ) xNewQueue );
    1932:	8b 81       	ldd	r24, Y+3	; 0x03
    1934:	9c 81       	ldd	r25, Y+4	; 0x04
    1936:	0e 94 63 0c 	call	0x18c6	; 0x18c6 <prvInitialiseMutex>

		return xNewQueue;
    193a:	8b 81       	ldd	r24, Y+3	; 0x03
    193c:	9c 81       	ldd	r25, Y+4	; 0x04
	}
    193e:	0f 90       	pop	r0
    1940:	0f 90       	pop	r0
    1942:	0f 90       	pop	r0
    1944:	0f 90       	pop	r0
    1946:	0f 90       	pop	r0
    1948:	cf 91       	pop	r28
    194a:	df 91       	pop	r29
    194c:	08 95       	ret

0000194e <xQueueGiveMutexRecursive>:
/*-----------------------------------------------------------*/

#if ( configUSE_RECURSIVE_MUTEXES == 1 )

	BaseType_t xQueueGiveMutexRecursive( QueueHandle_t xMutex )
	{
    194e:	0f 93       	push	r16
    1950:	1f 93       	push	r17
    1952:	df 93       	push	r29
    1954:	cf 93       	push	r28
    1956:	00 d0       	rcall	.+0      	; 0x1958 <xQueueGiveMutexRecursive+0xa>
    1958:	00 d0       	rcall	.+0      	; 0x195a <xQueueGiveMutexRecursive+0xc>
    195a:	0f 92       	push	r0
    195c:	cd b7       	in	r28, 0x3d	; 61
    195e:	de b7       	in	r29, 0x3e	; 62
    1960:	9d 83       	std	Y+5, r25	; 0x05
    1962:	8c 83       	std	Y+4, r24	; 0x04
	BaseType_t xReturn;
	Queue_t * const pxMutex = ( Queue_t * ) xMutex;
    1964:	8c 81       	ldd	r24, Y+4	; 0x04
    1966:	9d 81       	ldd	r25, Y+5	; 0x05
    1968:	9a 83       	std	Y+2, r25	; 0x02
    196a:	89 83       	std	Y+1, r24	; 0x01
		change outside of this task.  If this task does not hold the mutex then
		pxMutexHolder can never coincidentally equal the tasks handle, and as
		this is the only condition we are interested in it does not matter if
		pxMutexHolder is accessed simultaneously by another task.  Therefore no
		mutual exclusion is required to test the pxMutexHolder variable. */
		if( pxMutex->u.xSemaphore.xMutexHolder == xTaskGetCurrentTaskHandle() )
    196c:	e9 81       	ldd	r30, Y+1	; 0x01
    196e:	fa 81       	ldd	r31, Y+2	; 0x02
    1970:	04 81       	ldd	r16, Z+4	; 0x04
    1972:	15 81       	ldd	r17, Z+5	; 0x05
    1974:	0e 94 15 24 	call	0x482a	; 0x482a <xTaskGetCurrentTaskHandle>
    1978:	08 17       	cp	r16, r24
    197a:	19 07       	cpc	r17, r25
    197c:	c1 f4       	brne	.+48     	; 0x19ae <xQueueGiveMutexRecursive+0x60>
			/* uxRecursiveCallCount cannot be zero if xMutexHolder is equal to
			the task handle, therefore no underflow check is required.  Also,
			uxRecursiveCallCount is only modified by the mutex holder, and as
			there can only be one, no mutual exclusion is required to modify the
			uxRecursiveCallCount member. */
			( pxMutex->u.xSemaphore.uxRecursiveCallCount )--;
    197e:	e9 81       	ldd	r30, Y+1	; 0x01
    1980:	fa 81       	ldd	r31, Y+2	; 0x02
    1982:	86 81       	ldd	r24, Z+6	; 0x06
    1984:	81 50       	subi	r24, 0x01	; 1
    1986:	e9 81       	ldd	r30, Y+1	; 0x01
    1988:	fa 81       	ldd	r31, Y+2	; 0x02
    198a:	86 83       	std	Z+6, r24	; 0x06

			/* Has the recursive call count unwound to 0? */
			if( pxMutex->u.xSemaphore.uxRecursiveCallCount == ( UBaseType_t ) 0 )
    198c:	e9 81       	ldd	r30, Y+1	; 0x01
    198e:	fa 81       	ldd	r31, Y+2	; 0x02
    1990:	86 81       	ldd	r24, Z+6	; 0x06
    1992:	88 23       	and	r24, r24
    1994:	49 f4       	brne	.+18     	; 0x19a8 <xQueueGiveMutexRecursive+0x5a>
			{
				/* Return the mutex.  This will automatically unblock any other
				task that might be waiting to access the mutex. */
				( void ) xQueueGenericSend( pxMutex, NULL, queueMUTEX_GIVE_BLOCK_TIME, queueSEND_TO_BACK );
    1996:	89 81       	ldd	r24, Y+1	; 0x01
    1998:	9a 81       	ldd	r25, Y+2	; 0x02
    199a:	60 e0       	ldi	r22, 0x00	; 0
    199c:	70 e0       	ldi	r23, 0x00	; 0
    199e:	40 e0       	ldi	r20, 0x00	; 0
    19a0:	50 e0       	ldi	r21, 0x00	; 0
    19a2:	20 e0       	ldi	r18, 0x00	; 0
    19a4:	0e 94 48 0d 	call	0x1a90	; 0x1a90 <xQueueGenericSend>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}

			xReturn = pdPASS;
    19a8:	81 e0       	ldi	r24, 0x01	; 1
    19aa:	8b 83       	std	Y+3, r24	; 0x03
    19ac:	01 c0       	rjmp	.+2      	; 0x19b0 <xQueueGiveMutexRecursive+0x62>
		}
		else
		{
			/* The mutex cannot be given because the calling task is not the
			holder. */
			xReturn = pdFAIL;
    19ae:	1b 82       	std	Y+3, r1	; 0x03

			traceGIVE_MUTEX_RECURSIVE_FAILED( pxMutex );
		}

		return xReturn;
    19b0:	8b 81       	ldd	r24, Y+3	; 0x03
	}
    19b2:	0f 90       	pop	r0
    19b4:	0f 90       	pop	r0
    19b6:	0f 90       	pop	r0
    19b8:	0f 90       	pop	r0
    19ba:	0f 90       	pop	r0
    19bc:	cf 91       	pop	r28
    19be:	df 91       	pop	r29
    19c0:	1f 91       	pop	r17
    19c2:	0f 91       	pop	r16
    19c4:	08 95       	ret

000019c6 <xQueueTakeMutexRecursive>:
/*-----------------------------------------------------------*/

#if ( configUSE_RECURSIVE_MUTEXES == 1 )

	BaseType_t xQueueTakeMutexRecursive( QueueHandle_t xMutex, TickType_t xTicksToWait )
	{
    19c6:	0f 93       	push	r16
    19c8:	1f 93       	push	r17
    19ca:	df 93       	push	r29
    19cc:	cf 93       	push	r28
    19ce:	cd b7       	in	r28, 0x3d	; 61
    19d0:	de b7       	in	r29, 0x3e	; 62
    19d2:	27 97       	sbiw	r28, 0x07	; 7
    19d4:	0f b6       	in	r0, 0x3f	; 63
    19d6:	f8 94       	cli
    19d8:	de bf       	out	0x3e, r29	; 62
    19da:	0f be       	out	0x3f, r0	; 63
    19dc:	cd bf       	out	0x3d, r28	; 61
    19de:	9d 83       	std	Y+5, r25	; 0x05
    19e0:	8c 83       	std	Y+4, r24	; 0x04
    19e2:	7f 83       	std	Y+7, r23	; 0x07
    19e4:	6e 83       	std	Y+6, r22	; 0x06
	BaseType_t xReturn;
	Queue_t * const pxMutex = ( Queue_t * ) xMutex;
    19e6:	8c 81       	ldd	r24, Y+4	; 0x04
    19e8:	9d 81       	ldd	r25, Y+5	; 0x05
    19ea:	9a 83       	std	Y+2, r25	; 0x02
    19ec:	89 83       	std	Y+1, r24	; 0x01
		/* Comments regarding mutual exclusion as per those within
		xQueueGiveMutexRecursive(). */

		traceTAKE_MUTEX_RECURSIVE( pxMutex );

		if( pxMutex->u.xSemaphore.xMutexHolder == xTaskGetCurrentTaskHandle() )
    19ee:	e9 81       	ldd	r30, Y+1	; 0x01
    19f0:	fa 81       	ldd	r31, Y+2	; 0x02
    19f2:	04 81       	ldd	r16, Z+4	; 0x04
    19f4:	15 81       	ldd	r17, Z+5	; 0x05
    19f6:	0e 94 15 24 	call	0x482a	; 0x482a <xTaskGetCurrentTaskHandle>
    19fa:	08 17       	cp	r16, r24
    19fc:	19 07       	cpc	r17, r25
    19fe:	51 f4       	brne	.+20     	; 0x1a14 <xQueueTakeMutexRecursive+0x4e>
		{
			( pxMutex->u.xSemaphore.uxRecursiveCallCount )++;
    1a00:	e9 81       	ldd	r30, Y+1	; 0x01
    1a02:	fa 81       	ldd	r31, Y+2	; 0x02
    1a04:	86 81       	ldd	r24, Z+6	; 0x06
    1a06:	8f 5f       	subi	r24, 0xFF	; 255
    1a08:	e9 81       	ldd	r30, Y+1	; 0x01
    1a0a:	fa 81       	ldd	r31, Y+2	; 0x02
    1a0c:	86 83       	std	Z+6, r24	; 0x06
			xReturn = pdPASS;
    1a0e:	81 e0       	ldi	r24, 0x01	; 1
    1a10:	8b 83       	std	Y+3, r24	; 0x03
    1a12:	12 c0       	rjmp	.+36     	; 0x1a38 <xQueueTakeMutexRecursive+0x72>
		}
		else
		{
			xReturn = xQueueSemaphoreTake( pxMutex, xTicksToWait );
    1a14:	89 81       	ldd	r24, Y+1	; 0x01
    1a16:	9a 81       	ldd	r25, Y+2	; 0x02
    1a18:	2e 81       	ldd	r18, Y+6	; 0x06
    1a1a:	3f 81       	ldd	r19, Y+7	; 0x07
    1a1c:	b9 01       	movw	r22, r18
    1a1e:	0e 94 48 0f 	call	0x1e90	; 0x1e90 <xQueueSemaphoreTake>
    1a22:	8b 83       	std	Y+3, r24	; 0x03

			/* pdPASS will only be returned if the mutex was successfully
			obtained.  The calling task may have entered the Blocked state
			before reaching here. */
			if( xReturn != pdFAIL )
    1a24:	8b 81       	ldd	r24, Y+3	; 0x03
    1a26:	88 23       	and	r24, r24
    1a28:	39 f0       	breq	.+14     	; 0x1a38 <xQueueTakeMutexRecursive+0x72>
			{
				( pxMutex->u.xSemaphore.uxRecursiveCallCount )++;
    1a2a:	e9 81       	ldd	r30, Y+1	; 0x01
    1a2c:	fa 81       	ldd	r31, Y+2	; 0x02
    1a2e:	86 81       	ldd	r24, Z+6	; 0x06
    1a30:	8f 5f       	subi	r24, 0xFF	; 255
    1a32:	e9 81       	ldd	r30, Y+1	; 0x01
    1a34:	fa 81       	ldd	r31, Y+2	; 0x02
    1a36:	86 83       	std	Z+6, r24	; 0x06
			{
				traceTAKE_MUTEX_RECURSIVE_FAILED( pxMutex );
			}
		}

		return xReturn;
    1a38:	8b 81       	ldd	r24, Y+3	; 0x03
	}
    1a3a:	27 96       	adiw	r28, 0x07	; 7
    1a3c:	0f b6       	in	r0, 0x3f	; 63
    1a3e:	f8 94       	cli
    1a40:	de bf       	out	0x3e, r29	; 62
    1a42:	0f be       	out	0x3f, r0	; 63
    1a44:	cd bf       	out	0x3d, r28	; 61
    1a46:	cf 91       	pop	r28
    1a48:	df 91       	pop	r29
    1a4a:	1f 91       	pop	r17
    1a4c:	0f 91       	pop	r16
    1a4e:	08 95       	ret

00001a50 <xQueueCreateCountingSemaphore>:
/*-----------------------------------------------------------*/

#if( ( configUSE_COUNTING_SEMAPHORES == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) )

	QueueHandle_t xQueueCreateCountingSemaphore( const UBaseType_t uxMaxCount, const UBaseType_t uxInitialCount )
	{
    1a50:	df 93       	push	r29
    1a52:	cf 93       	push	r28
    1a54:	00 d0       	rcall	.+0      	; 0x1a56 <xQueueCreateCountingSemaphore+0x6>
    1a56:	00 d0       	rcall	.+0      	; 0x1a58 <xQueueCreateCountingSemaphore+0x8>
    1a58:	cd b7       	in	r28, 0x3d	; 61
    1a5a:	de b7       	in	r29, 0x3e	; 62
    1a5c:	8b 83       	std	Y+3, r24	; 0x03
    1a5e:	6c 83       	std	Y+4, r22	; 0x04
	QueueHandle_t xHandle;

		configASSERT( uxMaxCount != 0 );
		configASSERT( uxInitialCount <= uxMaxCount );

		xHandle = xQueueGenericCreate( uxMaxCount, queueSEMAPHORE_QUEUE_ITEM_LENGTH, queueQUEUE_TYPE_COUNTING_SEMAPHORE );
    1a60:	8b 81       	ldd	r24, Y+3	; 0x03
    1a62:	60 e0       	ldi	r22, 0x00	; 0
    1a64:	42 e0       	ldi	r20, 0x02	; 2
    1a66:	0e 94 d7 0b 	call	0x17ae	; 0x17ae <xQueueGenericCreate>
    1a6a:	9a 83       	std	Y+2, r25	; 0x02
    1a6c:	89 83       	std	Y+1, r24	; 0x01

		if( xHandle != NULL )
    1a6e:	89 81       	ldd	r24, Y+1	; 0x01
    1a70:	9a 81       	ldd	r25, Y+2	; 0x02
    1a72:	00 97       	sbiw	r24, 0x00	; 0
    1a74:	21 f0       	breq	.+8      	; 0x1a7e <xQueueCreateCountingSemaphore+0x2e>
		{
			( ( Queue_t * ) xHandle )->uxMessagesWaiting = uxInitialCount;
    1a76:	e9 81       	ldd	r30, Y+1	; 0x01
    1a78:	fa 81       	ldd	r31, Y+2	; 0x02
    1a7a:	8c 81       	ldd	r24, Y+4	; 0x04
    1a7c:	82 8f       	std	Z+26, r24	; 0x1a
		else
		{
			traceCREATE_COUNTING_SEMAPHORE_FAILED();
		}

		return xHandle;
    1a7e:	89 81       	ldd	r24, Y+1	; 0x01
    1a80:	9a 81       	ldd	r25, Y+2	; 0x02
	}
    1a82:	0f 90       	pop	r0
    1a84:	0f 90       	pop	r0
    1a86:	0f 90       	pop	r0
    1a88:	0f 90       	pop	r0
    1a8a:	cf 91       	pop	r28
    1a8c:	df 91       	pop	r29
    1a8e:	08 95       	ret

00001a90 <xQueueGenericSend>:

#endif /* ( ( configUSE_COUNTING_SEMAPHORES == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) ) */
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericSend( QueueHandle_t xQueue, const void * const pvItemToQueue, TickType_t xTicksToWait, const BaseType_t xCopyPosition )
{
    1a90:	df 93       	push	r29
    1a92:	cf 93       	push	r28
    1a94:	cd b7       	in	r28, 0x3d	; 61
    1a96:	de b7       	in	r29, 0x3e	; 62
    1a98:	2f 97       	sbiw	r28, 0x0f	; 15
    1a9a:	0f b6       	in	r0, 0x3f	; 63
    1a9c:	f8 94       	cli
    1a9e:	de bf       	out	0x3e, r29	; 62
    1aa0:	0f be       	out	0x3f, r0	; 63
    1aa2:	cd bf       	out	0x3d, r28	; 61
    1aa4:	99 87       	std	Y+9, r25	; 0x09
    1aa6:	88 87       	std	Y+8, r24	; 0x08
    1aa8:	7b 87       	std	Y+11, r23	; 0x0b
    1aaa:	6a 87       	std	Y+10, r22	; 0x0a
    1aac:	5d 87       	std	Y+13, r21	; 0x0d
    1aae:	4c 87       	std	Y+12, r20	; 0x0c
    1ab0:	2e 87       	std	Y+14, r18	; 0x0e
BaseType_t xEntryTimeSet = pdFALSE, xYieldRequired;
    1ab2:	1c 82       	std	Y+4, r1	; 0x04
TimeOut_t xTimeOut;
Queue_t * const pxQueue = xQueue;
    1ab4:	88 85       	ldd	r24, Y+8	; 0x08
    1ab6:	99 85       	ldd	r25, Y+9	; 0x09
    1ab8:	9a 83       	std	Y+2, r25	; 0x02
    1aba:	89 83       	std	Y+1, r24	; 0x01
	/*lint -save -e904 This function relaxes the coding standard somewhat to
	allow return statements within the function itself.  This is done in the
	interest of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
    1abc:	0f b6       	in	r0, 0x3f	; 63
    1abe:	f8 94       	cli
    1ac0:	0f 92       	push	r0
		{
			/* Is there room on the queue now?  The running task must be the
			highest priority task wanting to access the queue.  If the head item
			in the queue is to be overwritten then it does not matter if the
			queue is full. */
			if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
    1ac2:	e9 81       	ldd	r30, Y+1	; 0x01
    1ac4:	fa 81       	ldd	r31, Y+2	; 0x02
    1ac6:	92 8d       	ldd	r25, Z+26	; 0x1a
    1ac8:	e9 81       	ldd	r30, Y+1	; 0x01
    1aca:	fa 81       	ldd	r31, Y+2	; 0x02
    1acc:	83 8d       	ldd	r24, Z+27	; 0x1b
    1ace:	98 17       	cp	r25, r24
    1ad0:	18 f0       	brcs	.+6      	; 0x1ad8 <xQueueGenericSend+0x48>
    1ad2:	8e 85       	ldd	r24, Y+14	; 0x0e
    1ad4:	82 30       	cpi	r24, 0x02	; 2
    1ad6:	11 f5       	brne	.+68     	; 0x1b1c <xQueueGenericSend+0x8c>
						}
					}
				}
				#else /* configUSE_QUEUE_SETS */
				{
					xYieldRequired = prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    1ad8:	89 81       	ldd	r24, Y+1	; 0x01
    1ada:	9a 81       	ldd	r25, Y+2	; 0x02
    1adc:	2a 85       	ldd	r18, Y+10	; 0x0a
    1ade:	3b 85       	ldd	r19, Y+11	; 0x0b
    1ae0:	b9 01       	movw	r22, r18
    1ae2:	4e 85       	ldd	r20, Y+14	; 0x0e
    1ae4:	0e 94 ee 11 	call	0x23dc	; 0x23dc <prvCopyDataToQueue>
    1ae8:	8b 83       	std	Y+3, r24	; 0x03

					/* If there was a task waiting for data to arrive on the
					queue then unblock it now. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    1aea:	e9 81       	ldd	r30, Y+1	; 0x01
    1aec:	fa 81       	ldd	r31, Y+2	; 0x02
    1aee:	81 89       	ldd	r24, Z+17	; 0x11
    1af0:	88 23       	and	r24, r24
    1af2:	51 f0       	breq	.+20     	; 0x1b08 <xQueueGenericSend+0x78>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    1af4:	89 81       	ldd	r24, Y+1	; 0x01
    1af6:	9a 81       	ldd	r25, Y+2	; 0x02
    1af8:	41 96       	adiw	r24, 0x11	; 17
    1afa:	0e 94 e4 21 	call	0x43c8	; 0x43c8 <xTaskRemoveFromEventList>
    1afe:	88 23       	and	r24, r24
    1b00:	41 f0       	breq	.+16     	; 0x1b12 <xQueueGenericSend+0x82>
						{
							/* The unblocked task has a priority higher than
							our own so yield immediately.  Yes it is ok to do
							this from within the critical section - the kernel
							takes care of that. */
							queueYIELD_IF_USING_PREEMPTION();
    1b02:	0e 94 3c 0a 	call	0x1478	; 0x1478 <vPortYield>
    1b06:	05 c0       	rjmp	.+10     	; 0x1b12 <xQueueGenericSend+0x82>
						else
						{
							mtCOVERAGE_TEST_MARKER();
						}
					}
					else if( xYieldRequired != pdFALSE )
    1b08:	8b 81       	ldd	r24, Y+3	; 0x03
    1b0a:	88 23       	and	r24, r24
    1b0c:	11 f0       	breq	.+4      	; 0x1b12 <xQueueGenericSend+0x82>
					{
						/* This path is a special case that will only get
						executed if the task was holding multiple mutexes and
						the mutexes were given back in an order that is
						different to that in which they were taken. */
						queueYIELD_IF_USING_PREEMPTION();
    1b0e:	0e 94 3c 0a 	call	0x1478	; 0x1478 <vPortYield>
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif /* configUSE_QUEUE_SETS */

				taskEXIT_CRITICAL();
    1b12:	0f 90       	pop	r0
    1b14:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
    1b16:	81 e0       	ldi	r24, 0x01	; 1
    1b18:	8f 87       	std	Y+15, r24	; 0x0f
    1b1a:	5c c0       	rjmp	.+184    	; 0x1bd4 <xQueueGenericSend+0x144>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
    1b1c:	8c 85       	ldd	r24, Y+12	; 0x0c
    1b1e:	9d 85       	ldd	r25, Y+13	; 0x0d
    1b20:	00 97       	sbiw	r24, 0x00	; 0
    1b22:	21 f4       	brne	.+8      	; 0x1b2c <xQueueGenericSend+0x9c>
				{
					/* The queue was full and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    1b24:	0f 90       	pop	r0
    1b26:	0f be       	out	0x3f, r0	; 63

					/* Return to the original privilege level before exiting
					the function. */
					traceQUEUE_SEND_FAILED( pxQueue );
					return errQUEUE_FULL;
    1b28:	1f 86       	std	Y+15, r1	; 0x0f
    1b2a:	54 c0       	rjmp	.+168    	; 0x1bd4 <xQueueGenericSend+0x144>
				}
				else if( xEntryTimeSet == pdFALSE )
    1b2c:	8c 81       	ldd	r24, Y+4	; 0x04
    1b2e:	88 23       	and	r24, r24
    1b30:	31 f4       	brne	.+12     	; 0x1b3e <xQueueGenericSend+0xae>
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskInternalSetTimeOutState( &xTimeOut );
    1b32:	ce 01       	movw	r24, r28
    1b34:	05 96       	adiw	r24, 0x05	; 5
    1b36:	0e 94 ca 22 	call	0x4594	; 0x4594 <vTaskInternalSetTimeOutState>
					xEntryTimeSet = pdTRUE;
    1b3a:	81 e0       	ldi	r24, 0x01	; 1
    1b3c:	8c 83       	std	Y+4, r24	; 0x04
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
    1b3e:	0f 90       	pop	r0
    1b40:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    1b42:	0e 94 44 1f 	call	0x3e88	; 0x3e88 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    1b46:	0f b6       	in	r0, 0x3f	; 63
    1b48:	f8 94       	cli
    1b4a:	0f 92       	push	r0
    1b4c:	e9 81       	ldd	r30, Y+1	; 0x01
    1b4e:	fa 81       	ldd	r31, Y+2	; 0x02
    1b50:	85 8d       	ldd	r24, Z+29	; 0x1d
    1b52:	8f 3f       	cpi	r24, 0xFF	; 255
    1b54:	19 f4       	brne	.+6      	; 0x1b5c <xQueueGenericSend+0xcc>
    1b56:	e9 81       	ldd	r30, Y+1	; 0x01
    1b58:	fa 81       	ldd	r31, Y+2	; 0x02
    1b5a:	15 8e       	std	Z+29, r1	; 0x1d
    1b5c:	e9 81       	ldd	r30, Y+1	; 0x01
    1b5e:	fa 81       	ldd	r31, Y+2	; 0x02
    1b60:	86 8d       	ldd	r24, Z+30	; 0x1e
    1b62:	8f 3f       	cpi	r24, 0xFF	; 255
    1b64:	19 f4       	brne	.+6      	; 0x1b6c <xQueueGenericSend+0xdc>
    1b66:	e9 81       	ldd	r30, Y+1	; 0x01
    1b68:	fa 81       	ldd	r31, Y+2	; 0x02
    1b6a:	16 8e       	std	Z+30, r1	; 0x1e
    1b6c:	0f 90       	pop	r0
    1b6e:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    1b70:	ce 01       	movw	r24, r28
    1b72:	05 96       	adiw	r24, 0x05	; 5
    1b74:	9e 01       	movw	r18, r28
    1b76:	24 5f       	subi	r18, 0xF4	; 244
    1b78:	3f 4f       	sbci	r19, 0xFF	; 255
    1b7a:	b9 01       	movw	r22, r18
    1b7c:	0e 94 e3 22 	call	0x45c6	; 0x45c6 <xTaskCheckForTimeOut>
    1b80:	88 23       	and	r24, r24
    1b82:	09 f5       	brne	.+66     	; 0x1bc6 <xQueueGenericSend+0x136>
		{
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
    1b84:	89 81       	ldd	r24, Y+1	; 0x01
    1b86:	9a 81       	ldd	r25, Y+2	; 0x02
    1b88:	0e 94 7c 13 	call	0x26f8	; 0x26f8 <prvIsQueueFull>
    1b8c:	88 23       	and	r24, r24
    1b8e:	a1 f0       	breq	.+40     	; 0x1bb8 <xQueueGenericSend+0x128>
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
    1b90:	89 81       	ldd	r24, Y+1	; 0x01
    1b92:	9a 81       	ldd	r25, Y+2	; 0x02
    1b94:	08 96       	adiw	r24, 0x08	; 8
    1b96:	2c 85       	ldd	r18, Y+12	; 0x0c
    1b98:	3d 85       	ldd	r19, Y+13	; 0x0d
    1b9a:	b9 01       	movw	r22, r18
    1b9c:	0e 94 92 21 	call	0x4324	; 0x4324 <vTaskPlaceOnEventList>
				/* Unlocking the queue means queue events can effect the
				event list.  It is possible that interrupts occurring now
				remove this task from the event list again - but as the
				scheduler is suspended the task will go onto the pending
				ready last instead of the actual ready list. */
				prvUnlockQueue( pxQueue );
    1ba0:	89 81       	ldd	r24, Y+1	; 0x01
    1ba2:	9a 81       	ldd	r25, Y+2	; 0x02
    1ba4:	0e 94 ed 12 	call	0x25da	; 0x25da <prvUnlockQueue>
				/* Resuming the scheduler will move tasks from the pending
				ready list into the ready list - so it is feasible that this
				task is already in a ready list before it yields - in which
				case the yield will not cause a context switch unless there
				is also a higher priority task in the pending ready list. */
				if( xTaskResumeAll() == pdFALSE )
    1ba8:	0e 94 50 1f 	call	0x3ea0	; 0x3ea0 <xTaskResumeAll>
    1bac:	88 23       	and	r24, r24
    1bae:	09 f0       	breq	.+2      	; 0x1bb2 <xQueueGenericSend+0x122>
    1bb0:	85 cf       	rjmp	.-246    	; 0x1abc <xQueueGenericSend+0x2c>
				{
					portYIELD_WITHIN_API();
    1bb2:	0e 94 3c 0a 	call	0x1478	; 0x1478 <vPortYield>
    1bb6:	82 cf       	rjmp	.-252    	; 0x1abc <xQueueGenericSend+0x2c>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
    1bb8:	89 81       	ldd	r24, Y+1	; 0x01
    1bba:	9a 81       	ldd	r25, Y+2	; 0x02
    1bbc:	0e 94 ed 12 	call	0x25da	; 0x25da <prvUnlockQueue>
				( void ) xTaskResumeAll();
    1bc0:	0e 94 50 1f 	call	0x3ea0	; 0x3ea0 <xTaskResumeAll>
    1bc4:	7b cf       	rjmp	.-266    	; 0x1abc <xQueueGenericSend+0x2c>
			}
		}
		else
		{
			/* The timeout has expired. */
			prvUnlockQueue( pxQueue );
    1bc6:	89 81       	ldd	r24, Y+1	; 0x01
    1bc8:	9a 81       	ldd	r25, Y+2	; 0x02
    1bca:	0e 94 ed 12 	call	0x25da	; 0x25da <prvUnlockQueue>
			( void ) xTaskResumeAll();
    1bce:	0e 94 50 1f 	call	0x3ea0	; 0x3ea0 <xTaskResumeAll>

			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
    1bd2:	1f 86       	std	Y+15, r1	; 0x0f
    1bd4:	8f 85       	ldd	r24, Y+15	; 0x0f
		}
	} /*lint -restore */
}
    1bd6:	2f 96       	adiw	r28, 0x0f	; 15
    1bd8:	0f b6       	in	r0, 0x3f	; 63
    1bda:	f8 94       	cli
    1bdc:	de bf       	out	0x3e, r29	; 62
    1bde:	0f be       	out	0x3f, r0	; 63
    1be0:	cd bf       	out	0x3d, r28	; 61
    1be2:	cf 91       	pop	r28
    1be4:	df 91       	pop	r29
    1be6:	08 95       	ret

00001be8 <xQueueGenericSendFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericSendFromISR( QueueHandle_t xQueue, const void * const pvItemToQueue, BaseType_t * const pxHigherPriorityTaskWoken, const BaseType_t xCopyPosition )
{
    1be8:	df 93       	push	r29
    1bea:	cf 93       	push	r28
    1bec:	cd b7       	in	r28, 0x3d	; 61
    1bee:	de b7       	in	r29, 0x3e	; 62
    1bf0:	2c 97       	sbiw	r28, 0x0c	; 12
    1bf2:	0f b6       	in	r0, 0x3f	; 63
    1bf4:	f8 94       	cli
    1bf6:	de bf       	out	0x3e, r29	; 62
    1bf8:	0f be       	out	0x3f, r0	; 63
    1bfa:	cd bf       	out	0x3d, r28	; 61
    1bfc:	9f 83       	std	Y+7, r25	; 0x07
    1bfe:	8e 83       	std	Y+6, r24	; 0x06
    1c00:	79 87       	std	Y+9, r23	; 0x09
    1c02:	68 87       	std	Y+8, r22	; 0x08
    1c04:	5b 87       	std	Y+11, r21	; 0x0b
    1c06:	4a 87       	std	Y+10, r20	; 0x0a
    1c08:	2c 87       	std	Y+12, r18	; 0x0c
BaseType_t xReturn;
UBaseType_t uxSavedInterruptStatus;
Queue_t * const pxQueue = xQueue;
    1c0a:	8e 81       	ldd	r24, Y+6	; 0x06
    1c0c:	9f 81       	ldd	r25, Y+7	; 0x07
    1c0e:	9b 83       	std	Y+3, r25	; 0x03
    1c10:	8a 83       	std	Y+2, r24	; 0x02
	/* Similar to xQueueGenericSend, except without blocking if there is no room
	in the queue.  Also don't directly wake a task that was blocked on a queue
	read, instead return a flag to say whether a context switch is required or
	not (i.e. has a task with a higher priority than us been woken by this
	post). */
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    1c12:	1c 82       	std	Y+4, r1	; 0x04
	{
		if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
    1c14:	ea 81       	ldd	r30, Y+2	; 0x02
    1c16:	fb 81       	ldd	r31, Y+3	; 0x03
    1c18:	92 8d       	ldd	r25, Z+26	; 0x1a
    1c1a:	ea 81       	ldd	r30, Y+2	; 0x02
    1c1c:	fb 81       	ldd	r31, Y+3	; 0x03
    1c1e:	83 8d       	ldd	r24, Z+27	; 0x1b
    1c20:	98 17       	cp	r25, r24
    1c22:	18 f0       	brcs	.+6      	; 0x1c2a <xQueueGenericSendFromISR+0x42>
    1c24:	8c 85       	ldd	r24, Y+12	; 0x0c
    1c26:	82 30       	cpi	r24, 0x02	; 2
    1c28:	61 f5       	brne	.+88     	; 0x1c82 <xQueueGenericSendFromISR+0x9a>
		{
			const int8_t cTxLock = pxQueue->cTxLock;
    1c2a:	ea 81       	ldd	r30, Y+2	; 0x02
    1c2c:	fb 81       	ldd	r31, Y+3	; 0x03
    1c2e:	86 8d       	ldd	r24, Z+30	; 0x1e
    1c30:	89 83       	std	Y+1, r24	; 0x01
			/* Semaphores use xQueueGiveFromISR(), so pxQueue will not be a
			semaphore or mutex.  That means prvCopyDataToQueue() cannot result
			in a task disinheriting a priority and prvCopyDataToQueue() can be
			called here even though the disinherit function does not check if
			the scheduler is suspended before accessing the ready lists. */
			( void ) prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    1c32:	8a 81       	ldd	r24, Y+2	; 0x02
    1c34:	9b 81       	ldd	r25, Y+3	; 0x03
    1c36:	28 85       	ldd	r18, Y+8	; 0x08
    1c38:	39 85       	ldd	r19, Y+9	; 0x09
    1c3a:	b9 01       	movw	r22, r18
    1c3c:	4c 85       	ldd	r20, Y+12	; 0x0c
    1c3e:	0e 94 ee 11 	call	0x23dc	; 0x23dc <prvCopyDataToQueue>

			/* The event list is not altered if the queue is locked.  This will
			be done when the queue is unlocked later. */
			if( cTxLock == queueUNLOCKED )
    1c42:	89 81       	ldd	r24, Y+1	; 0x01
    1c44:	8f 3f       	cpi	r24, 0xFF	; 255
    1c46:	a9 f4       	brne	.+42     	; 0x1c72 <xQueueGenericSendFromISR+0x8a>
						}
					}
				}
				#else /* configUSE_QUEUE_SETS */
				{
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    1c48:	ea 81       	ldd	r30, Y+2	; 0x02
    1c4a:	fb 81       	ldd	r31, Y+3	; 0x03
    1c4c:	81 89       	ldd	r24, Z+17	; 0x11
    1c4e:	88 23       	and	r24, r24
    1c50:	a9 f0       	breq	.+42     	; 0x1c7c <xQueueGenericSendFromISR+0x94>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    1c52:	8a 81       	ldd	r24, Y+2	; 0x02
    1c54:	9b 81       	ldd	r25, Y+3	; 0x03
    1c56:	41 96       	adiw	r24, 0x11	; 17
    1c58:	0e 94 e4 21 	call	0x43c8	; 0x43c8 <xTaskRemoveFromEventList>
    1c5c:	88 23       	and	r24, r24
    1c5e:	71 f0       	breq	.+28     	; 0x1c7c <xQueueGenericSendFromISR+0x94>
						{
							/* The task waiting has a higher priority so record that a
							context	switch is required. */
							if( pxHigherPriorityTaskWoken != NULL )
    1c60:	8a 85       	ldd	r24, Y+10	; 0x0a
    1c62:	9b 85       	ldd	r25, Y+11	; 0x0b
    1c64:	00 97       	sbiw	r24, 0x00	; 0
    1c66:	51 f0       	breq	.+20     	; 0x1c7c <xQueueGenericSendFromISR+0x94>
							{
								*pxHigherPriorityTaskWoken = pdTRUE;
    1c68:	ea 85       	ldd	r30, Y+10	; 0x0a
    1c6a:	fb 85       	ldd	r31, Y+11	; 0x0b
    1c6c:	81 e0       	ldi	r24, 0x01	; 1
    1c6e:	80 83       	st	Z, r24
    1c70:	05 c0       	rjmp	.+10     	; 0x1c7c <xQueueGenericSendFromISR+0x94>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				pxQueue->cTxLock = ( int8_t ) ( cTxLock + 1 );
    1c72:	89 81       	ldd	r24, Y+1	; 0x01
    1c74:	8f 5f       	subi	r24, 0xFF	; 255
    1c76:	ea 81       	ldd	r30, Y+2	; 0x02
    1c78:	fb 81       	ldd	r31, Y+3	; 0x03
    1c7a:	86 8f       	std	Z+30, r24	; 0x1e
			}

			xReturn = pdPASS;
    1c7c:	81 e0       	ldi	r24, 0x01	; 1
    1c7e:	8d 83       	std	Y+5, r24	; 0x05
    1c80:	01 c0       	rjmp	.+2      	; 0x1c84 <xQueueGenericSendFromISR+0x9c>
		}
		else
		{
			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
			xReturn = errQUEUE_FULL;
    1c82:	1d 82       	std	Y+5, r1	; 0x05
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
    1c84:	8d 81       	ldd	r24, Y+5	; 0x05
}
    1c86:	2c 96       	adiw	r28, 0x0c	; 12
    1c88:	0f b6       	in	r0, 0x3f	; 63
    1c8a:	f8 94       	cli
    1c8c:	de bf       	out	0x3e, r29	; 62
    1c8e:	0f be       	out	0x3f, r0	; 63
    1c90:	cd bf       	out	0x3d, r28	; 61
    1c92:	cf 91       	pop	r28
    1c94:	df 91       	pop	r29
    1c96:	08 95       	ret

00001c98 <xQueueGiveFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueGiveFromISR( QueueHandle_t xQueue, BaseType_t * const pxHigherPriorityTaskWoken )
{
    1c98:	df 93       	push	r29
    1c9a:	cf 93       	push	r28
    1c9c:	cd b7       	in	r28, 0x3d	; 61
    1c9e:	de b7       	in	r29, 0x3e	; 62
    1ca0:	2a 97       	sbiw	r28, 0x0a	; 10
    1ca2:	0f b6       	in	r0, 0x3f	; 63
    1ca4:	f8 94       	cli
    1ca6:	de bf       	out	0x3e, r29	; 62
    1ca8:	0f be       	out	0x3f, r0	; 63
    1caa:	cd bf       	out	0x3d, r28	; 61
    1cac:	98 87       	std	Y+8, r25	; 0x08
    1cae:	8f 83       	std	Y+7, r24	; 0x07
    1cb0:	7a 87       	std	Y+10, r23	; 0x0a
    1cb2:	69 87       	std	Y+9, r22	; 0x09
BaseType_t xReturn;
UBaseType_t uxSavedInterruptStatus;
Queue_t * const pxQueue = xQueue;
    1cb4:	8f 81       	ldd	r24, Y+7	; 0x07
    1cb6:	98 85       	ldd	r25, Y+8	; 0x08
    1cb8:	9c 83       	std	Y+4, r25	; 0x04
    1cba:	8b 83       	std	Y+3, r24	; 0x03
	safe API to ensure interrupt entry is as fast and as simple as possible.
	More information (albeit Cortex-M specific) is provided on the following
	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    1cbc:	1d 82       	std	Y+5, r1	; 0x05
	{
		const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    1cbe:	eb 81       	ldd	r30, Y+3	; 0x03
    1cc0:	fc 81       	ldd	r31, Y+4	; 0x04
    1cc2:	82 8d       	ldd	r24, Z+26	; 0x1a
    1cc4:	8a 83       	std	Y+2, r24	; 0x02

		/* When the queue is used to implement a semaphore no data is ever
		moved through the queue but it is still valid to see if the queue 'has
		space'. */
		if( uxMessagesWaiting < pxQueue->uxLength )
    1cc6:	eb 81       	ldd	r30, Y+3	; 0x03
    1cc8:	fc 81       	ldd	r31, Y+4	; 0x04
    1cca:	93 8d       	ldd	r25, Z+27	; 0x1b
    1ccc:	8a 81       	ldd	r24, Y+2	; 0x02
    1cce:	89 17       	cp	r24, r25
    1cd0:	48 f5       	brcc	.+82     	; 0x1d24 <xQueueGiveFromISR+0x8c>
		{
			const int8_t cTxLock = pxQueue->cTxLock;
    1cd2:	eb 81       	ldd	r30, Y+3	; 0x03
    1cd4:	fc 81       	ldd	r31, Y+4	; 0x04
    1cd6:	86 8d       	ldd	r24, Z+30	; 0x1e
    1cd8:	89 83       	std	Y+1, r24	; 0x01
			holder - and if there is a mutex holder then the mutex cannot be
			given from an ISR.  As this is the ISR version of the function it
			can be assumed there is no mutex holder and no need to determine if
			priority disinheritance is needed.  Simply increase the count of
			messages (semaphores) available. */
			pxQueue->uxMessagesWaiting = uxMessagesWaiting + ( UBaseType_t ) 1;
    1cda:	8a 81       	ldd	r24, Y+2	; 0x02
    1cdc:	8f 5f       	subi	r24, 0xFF	; 255
    1cde:	eb 81       	ldd	r30, Y+3	; 0x03
    1ce0:	fc 81       	ldd	r31, Y+4	; 0x04
    1ce2:	82 8f       	std	Z+26, r24	; 0x1a

			/* The event list is not altered if the queue is locked.  This will
			be done when the queue is unlocked later. */
			if( cTxLock == queueUNLOCKED )
    1ce4:	89 81       	ldd	r24, Y+1	; 0x01
    1ce6:	8f 3f       	cpi	r24, 0xFF	; 255
    1ce8:	a9 f4       	brne	.+42     	; 0x1d14 <xQueueGiveFromISR+0x7c>
						}
					}
				}
				#else /* configUSE_QUEUE_SETS */
				{
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    1cea:	eb 81       	ldd	r30, Y+3	; 0x03
    1cec:	fc 81       	ldd	r31, Y+4	; 0x04
    1cee:	81 89       	ldd	r24, Z+17	; 0x11
    1cf0:	88 23       	and	r24, r24
    1cf2:	a9 f0       	breq	.+42     	; 0x1d1e <xQueueGiveFromISR+0x86>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    1cf4:	8b 81       	ldd	r24, Y+3	; 0x03
    1cf6:	9c 81       	ldd	r25, Y+4	; 0x04
    1cf8:	41 96       	adiw	r24, 0x11	; 17
    1cfa:	0e 94 e4 21 	call	0x43c8	; 0x43c8 <xTaskRemoveFromEventList>
    1cfe:	88 23       	and	r24, r24
    1d00:	71 f0       	breq	.+28     	; 0x1d1e <xQueueGiveFromISR+0x86>
						{
							/* The task waiting has a higher priority so record that a
							context	switch is required. */
							if( pxHigherPriorityTaskWoken != NULL )
    1d02:	89 85       	ldd	r24, Y+9	; 0x09
    1d04:	9a 85       	ldd	r25, Y+10	; 0x0a
    1d06:	00 97       	sbiw	r24, 0x00	; 0
    1d08:	51 f0       	breq	.+20     	; 0x1d1e <xQueueGiveFromISR+0x86>
							{
								*pxHigherPriorityTaskWoken = pdTRUE;
    1d0a:	e9 85       	ldd	r30, Y+9	; 0x09
    1d0c:	fa 85       	ldd	r31, Y+10	; 0x0a
    1d0e:	81 e0       	ldi	r24, 0x01	; 1
    1d10:	80 83       	st	Z, r24
    1d12:	05 c0       	rjmp	.+10     	; 0x1d1e <xQueueGiveFromISR+0x86>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				pxQueue->cTxLock = ( int8_t ) ( cTxLock + 1 );
    1d14:	89 81       	ldd	r24, Y+1	; 0x01
    1d16:	8f 5f       	subi	r24, 0xFF	; 255
    1d18:	eb 81       	ldd	r30, Y+3	; 0x03
    1d1a:	fc 81       	ldd	r31, Y+4	; 0x04
    1d1c:	86 8f       	std	Z+30, r24	; 0x1e
			}

			xReturn = pdPASS;
    1d1e:	81 e0       	ldi	r24, 0x01	; 1
    1d20:	8e 83       	std	Y+6, r24	; 0x06
    1d22:	01 c0       	rjmp	.+2      	; 0x1d26 <xQueueGiveFromISR+0x8e>
		}
		else
		{
			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
			xReturn = errQUEUE_FULL;
    1d24:	1e 82       	std	Y+6, r1	; 0x06
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
    1d26:	8e 81       	ldd	r24, Y+6	; 0x06
}
    1d28:	2a 96       	adiw	r28, 0x0a	; 10
    1d2a:	0f b6       	in	r0, 0x3f	; 63
    1d2c:	f8 94       	cli
    1d2e:	de bf       	out	0x3e, r29	; 62
    1d30:	0f be       	out	0x3f, r0	; 63
    1d32:	cd bf       	out	0x3d, r28	; 61
    1d34:	cf 91       	pop	r28
    1d36:	df 91       	pop	r29
    1d38:	08 95       	ret

00001d3a <xQueueReceive>:
/*-----------------------------------------------------------*/

BaseType_t xQueueReceive( QueueHandle_t xQueue, void * const pvBuffer, TickType_t xTicksToWait )
{
    1d3a:	df 93       	push	r29
    1d3c:	cf 93       	push	r28
    1d3e:	cd b7       	in	r28, 0x3d	; 61
    1d40:	de b7       	in	r29, 0x3e	; 62
    1d42:	2e 97       	sbiw	r28, 0x0e	; 14
    1d44:	0f b6       	in	r0, 0x3f	; 63
    1d46:	f8 94       	cli
    1d48:	de bf       	out	0x3e, r29	; 62
    1d4a:	0f be       	out	0x3f, r0	; 63
    1d4c:	cd bf       	out	0x3d, r28	; 61
    1d4e:	99 87       	std	Y+9, r25	; 0x09
    1d50:	88 87       	std	Y+8, r24	; 0x08
    1d52:	7b 87       	std	Y+11, r23	; 0x0b
    1d54:	6a 87       	std	Y+10, r22	; 0x0a
    1d56:	5d 87       	std	Y+13, r21	; 0x0d
    1d58:	4c 87       	std	Y+12, r20	; 0x0c
BaseType_t xEntryTimeSet = pdFALSE;
    1d5a:	1c 82       	std	Y+4, r1	; 0x04
TimeOut_t xTimeOut;
Queue_t * const pxQueue = xQueue;
    1d5c:	88 85       	ldd	r24, Y+8	; 0x08
    1d5e:	99 85       	ldd	r25, Y+9	; 0x09
    1d60:	9b 83       	std	Y+3, r25	; 0x03
    1d62:	8a 83       	std	Y+2, r24	; 0x02
	/*lint -save -e904  This function relaxes the coding standard somewhat to
	allow return statements within the function itself.  This is done in the
	interest of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
    1d64:	0f b6       	in	r0, 0x3f	; 63
    1d66:	f8 94       	cli
    1d68:	0f 92       	push	r0
		{
			const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    1d6a:	ea 81       	ldd	r30, Y+2	; 0x02
    1d6c:	fb 81       	ldd	r31, Y+3	; 0x03
    1d6e:	82 8d       	ldd	r24, Z+26	; 0x1a
    1d70:	89 83       	std	Y+1, r24	; 0x01

			/* Is there data in the queue now?  To be running the calling task
			must be the highest priority task wanting to access the queue. */
			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
    1d72:	89 81       	ldd	r24, Y+1	; 0x01
    1d74:	88 23       	and	r24, r24
    1d76:	f9 f0       	breq	.+62     	; 0x1db6 <xQueueReceive+0x7c>
			{
				/* Data available, remove one item. */
				prvCopyDataFromQueue( pxQueue, pvBuffer );
    1d78:	8a 81       	ldd	r24, Y+2	; 0x02
    1d7a:	9b 81       	ldd	r25, Y+3	; 0x03
    1d7c:	2a 85       	ldd	r18, Y+10	; 0x0a
    1d7e:	3b 85       	ldd	r19, Y+11	; 0x0b
    1d80:	b9 01       	movw	r22, r18
    1d82:	0e 94 a6 12 	call	0x254c	; 0x254c <prvCopyDataFromQueue>
				traceQUEUE_RECEIVE( pxQueue );
				pxQueue->uxMessagesWaiting = uxMessagesWaiting - ( UBaseType_t ) 1;
    1d86:	89 81       	ldd	r24, Y+1	; 0x01
    1d88:	81 50       	subi	r24, 0x01	; 1
    1d8a:	ea 81       	ldd	r30, Y+2	; 0x02
    1d8c:	fb 81       	ldd	r31, Y+3	; 0x03
    1d8e:	82 8f       	std	Z+26, r24	; 0x1a

				/* There is now space in the queue, were any tasks waiting to
				post to the queue?  If so, unblock the highest priority waiting
				task. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    1d90:	ea 81       	ldd	r30, Y+2	; 0x02
    1d92:	fb 81       	ldd	r31, Y+3	; 0x03
    1d94:	80 85       	ldd	r24, Z+8	; 0x08
    1d96:	88 23       	and	r24, r24
    1d98:	49 f0       	breq	.+18     	; 0x1dac <xQueueReceive+0x72>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    1d9a:	8a 81       	ldd	r24, Y+2	; 0x02
    1d9c:	9b 81       	ldd	r25, Y+3	; 0x03
    1d9e:	08 96       	adiw	r24, 0x08	; 8
    1da0:	0e 94 e4 21 	call	0x43c8	; 0x43c8 <xTaskRemoveFromEventList>
    1da4:	88 23       	and	r24, r24
    1da6:	11 f0       	breq	.+4      	; 0x1dac <xQueueReceive+0x72>
					{
						queueYIELD_IF_USING_PREEMPTION();
    1da8:	0e 94 3c 0a 	call	0x1478	; 0x1478 <vPortYield>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				taskEXIT_CRITICAL();
    1dac:	0f 90       	pop	r0
    1dae:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
    1db0:	81 e0       	ldi	r24, 0x01	; 1
    1db2:	8e 87       	std	Y+14, r24	; 0x0e
    1db4:	63 c0       	rjmp	.+198    	; 0x1e7c <xQueueReceive+0x142>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
    1db6:	8c 85       	ldd	r24, Y+12	; 0x0c
    1db8:	9d 85       	ldd	r25, Y+13	; 0x0d
    1dba:	00 97       	sbiw	r24, 0x00	; 0
    1dbc:	21 f4       	brne	.+8      	; 0x1dc6 <xQueueReceive+0x8c>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    1dbe:	0f 90       	pop	r0
    1dc0:	0f be       	out	0x3f, r0	; 63
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
    1dc2:	1e 86       	std	Y+14, r1	; 0x0e
    1dc4:	5b c0       	rjmp	.+182    	; 0x1e7c <xQueueReceive+0x142>
				}
				else if( xEntryTimeSet == pdFALSE )
    1dc6:	8c 81       	ldd	r24, Y+4	; 0x04
    1dc8:	88 23       	and	r24, r24
    1dca:	31 f4       	brne	.+12     	; 0x1dd8 <xQueueReceive+0x9e>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskInternalSetTimeOutState( &xTimeOut );
    1dcc:	ce 01       	movw	r24, r28
    1dce:	05 96       	adiw	r24, 0x05	; 5
    1dd0:	0e 94 ca 22 	call	0x4594	; 0x4594 <vTaskInternalSetTimeOutState>
					xEntryTimeSet = pdTRUE;
    1dd4:	81 e0       	ldi	r24, 0x01	; 1
    1dd6:	8c 83       	std	Y+4, r24	; 0x04
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
    1dd8:	0f 90       	pop	r0
    1dda:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    1ddc:	0e 94 44 1f 	call	0x3e88	; 0x3e88 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    1de0:	0f b6       	in	r0, 0x3f	; 63
    1de2:	f8 94       	cli
    1de4:	0f 92       	push	r0
    1de6:	ea 81       	ldd	r30, Y+2	; 0x02
    1de8:	fb 81       	ldd	r31, Y+3	; 0x03
    1dea:	85 8d       	ldd	r24, Z+29	; 0x1d
    1dec:	8f 3f       	cpi	r24, 0xFF	; 255
    1dee:	19 f4       	brne	.+6      	; 0x1df6 <xQueueReceive+0xbc>
    1df0:	ea 81       	ldd	r30, Y+2	; 0x02
    1df2:	fb 81       	ldd	r31, Y+3	; 0x03
    1df4:	15 8e       	std	Z+29, r1	; 0x1d
    1df6:	ea 81       	ldd	r30, Y+2	; 0x02
    1df8:	fb 81       	ldd	r31, Y+3	; 0x03
    1dfa:	86 8d       	ldd	r24, Z+30	; 0x1e
    1dfc:	8f 3f       	cpi	r24, 0xFF	; 255
    1dfe:	19 f4       	brne	.+6      	; 0x1e06 <xQueueReceive+0xcc>
    1e00:	ea 81       	ldd	r30, Y+2	; 0x02
    1e02:	fb 81       	ldd	r31, Y+3	; 0x03
    1e04:	16 8e       	std	Z+30, r1	; 0x1e
    1e06:	0f 90       	pop	r0
    1e08:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    1e0a:	ce 01       	movw	r24, r28
    1e0c:	05 96       	adiw	r24, 0x05	; 5
    1e0e:	9e 01       	movw	r18, r28
    1e10:	24 5f       	subi	r18, 0xF4	; 244
    1e12:	3f 4f       	sbci	r19, 0xFF	; 255
    1e14:	b9 01       	movw	r22, r18
    1e16:	0e 94 e3 22 	call	0x45c6	; 0x45c6 <xTaskCheckForTimeOut>
    1e1a:	88 23       	and	r24, r24
    1e1c:	09 f5       	brne	.+66     	; 0x1e60 <xQueueReceive+0x126>
		{
			/* The timeout has not expired.  If the queue is still empty place
			the task on the list of tasks waiting to receive from the queue. */
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    1e1e:	8a 81       	ldd	r24, Y+2	; 0x02
    1e20:	9b 81       	ldd	r25, Y+3	; 0x03
    1e22:	0e 94 40 13 	call	0x2680	; 0x2680 <prvIsQueueEmpty>
    1e26:	88 23       	and	r24, r24
    1e28:	a1 f0       	breq	.+40     	; 0x1e52 <xQueueReceive+0x118>
			{
				traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    1e2a:	8a 81       	ldd	r24, Y+2	; 0x02
    1e2c:	9b 81       	ldd	r25, Y+3	; 0x03
    1e2e:	41 96       	adiw	r24, 0x11	; 17
    1e30:	2c 85       	ldd	r18, Y+12	; 0x0c
    1e32:	3d 85       	ldd	r19, Y+13	; 0x0d
    1e34:	b9 01       	movw	r22, r18
    1e36:	0e 94 92 21 	call	0x4324	; 0x4324 <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
    1e3a:	8a 81       	ldd	r24, Y+2	; 0x02
    1e3c:	9b 81       	ldd	r25, Y+3	; 0x03
    1e3e:	0e 94 ed 12 	call	0x25da	; 0x25da <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
    1e42:	0e 94 50 1f 	call	0x3ea0	; 0x3ea0 <xTaskResumeAll>
    1e46:	88 23       	and	r24, r24
    1e48:	09 f0       	breq	.+2      	; 0x1e4c <xQueueReceive+0x112>
    1e4a:	8c cf       	rjmp	.-232    	; 0x1d64 <xQueueReceive+0x2a>
				{
					portYIELD_WITHIN_API();
    1e4c:	0e 94 3c 0a 	call	0x1478	; 0x1478 <vPortYield>
    1e50:	89 cf       	rjmp	.-238    	; 0x1d64 <xQueueReceive+0x2a>
			}
			else
			{
				/* The queue contains data again.  Loop back to try and read the
				data. */
				prvUnlockQueue( pxQueue );
    1e52:	8a 81       	ldd	r24, Y+2	; 0x02
    1e54:	9b 81       	ldd	r25, Y+3	; 0x03
    1e56:	0e 94 ed 12 	call	0x25da	; 0x25da <prvUnlockQueue>
				( void ) xTaskResumeAll();
    1e5a:	0e 94 50 1f 	call	0x3ea0	; 0x3ea0 <xTaskResumeAll>
    1e5e:	82 cf       	rjmp	.-252    	; 0x1d64 <xQueueReceive+0x2a>
		}
		else
		{
			/* Timed out.  If there is no data in the queue exit, otherwise loop
			back and attempt to read the data. */
			prvUnlockQueue( pxQueue );
    1e60:	8a 81       	ldd	r24, Y+2	; 0x02
    1e62:	9b 81       	ldd	r25, Y+3	; 0x03
    1e64:	0e 94 ed 12 	call	0x25da	; 0x25da <prvUnlockQueue>
			( void ) xTaskResumeAll();
    1e68:	0e 94 50 1f 	call	0x3ea0	; 0x3ea0 <xTaskResumeAll>

			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    1e6c:	8a 81       	ldd	r24, Y+2	; 0x02
    1e6e:	9b 81       	ldd	r25, Y+3	; 0x03
    1e70:	0e 94 40 13 	call	0x2680	; 0x2680 <prvIsQueueEmpty>
    1e74:	88 23       	and	r24, r24
    1e76:	09 f4       	brne	.+2      	; 0x1e7a <xQueueReceive+0x140>
    1e78:	75 cf       	rjmp	.-278    	; 0x1d64 <xQueueReceive+0x2a>
			{
				traceQUEUE_RECEIVE_FAILED( pxQueue );
				return errQUEUE_EMPTY;
    1e7a:	1e 86       	std	Y+14, r1	; 0x0e
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
	} /*lint -restore */
    1e7c:	8e 85       	ldd	r24, Y+14	; 0x0e
}
    1e7e:	2e 96       	adiw	r28, 0x0e	; 14
    1e80:	0f b6       	in	r0, 0x3f	; 63
    1e82:	f8 94       	cli
    1e84:	de bf       	out	0x3e, r29	; 62
    1e86:	0f be       	out	0x3f, r0	; 63
    1e88:	cd bf       	out	0x3d, r28	; 61
    1e8a:	cf 91       	pop	r28
    1e8c:	df 91       	pop	r29
    1e8e:	08 95       	ret

00001e90 <xQueueSemaphoreTake>:
/*-----------------------------------------------------------*/

BaseType_t xQueueSemaphoreTake( QueueHandle_t xQueue, TickType_t xTicksToWait )
{
    1e90:	df 93       	push	r29
    1e92:	cf 93       	push	r28
    1e94:	cd b7       	in	r28, 0x3d	; 61
    1e96:	de b7       	in	r29, 0x3e	; 62
    1e98:	2e 97       	sbiw	r28, 0x0e	; 14
    1e9a:	0f b6       	in	r0, 0x3f	; 63
    1e9c:	f8 94       	cli
    1e9e:	de bf       	out	0x3e, r29	; 62
    1ea0:	0f be       	out	0x3f, r0	; 63
    1ea2:	cd bf       	out	0x3d, r28	; 61
    1ea4:	9b 87       	std	Y+11, r25	; 0x0b
    1ea6:	8a 87       	std	Y+10, r24	; 0x0a
    1ea8:	7d 87       	std	Y+13, r23	; 0x0d
    1eaa:	6c 87       	std	Y+12, r22	; 0x0c
BaseType_t xEntryTimeSet = pdFALSE;
    1eac:	1e 82       	std	Y+6, r1	; 0x06
TimeOut_t xTimeOut;
Queue_t * const pxQueue = xQueue;
    1eae:	8a 85       	ldd	r24, Y+10	; 0x0a
    1eb0:	9b 85       	ldd	r25, Y+11	; 0x0b
    1eb2:	9d 83       	std	Y+5, r25	; 0x05
    1eb4:	8c 83       	std	Y+4, r24	; 0x04

#if( configUSE_MUTEXES == 1 )
	BaseType_t xInheritanceOccurred = pdFALSE;
    1eb6:	1b 82       	std	Y+3, r1	; 0x03
	/*lint -save -e904 This function relaxes the coding standard somewhat to allow return
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
    1eb8:	0f b6       	in	r0, 0x3f	; 63
    1eba:	f8 94       	cli
    1ebc:	0f 92       	push	r0
		{
			/* Semaphores are queues with an item size of 0, and where the
			number of messages in the queue is the semaphore's count value. */
			const UBaseType_t uxSemaphoreCount = pxQueue->uxMessagesWaiting;
    1ebe:	ec 81       	ldd	r30, Y+4	; 0x04
    1ec0:	fd 81       	ldd	r31, Y+5	; 0x05
    1ec2:	82 8d       	ldd	r24, Z+26	; 0x1a
    1ec4:	8a 83       	std	Y+2, r24	; 0x02

			/* Is there data in the queue now?  To be running the calling task
			must be the highest priority task wanting to access the queue. */
			if( uxSemaphoreCount > ( UBaseType_t ) 0 )
    1ec6:	8a 81       	ldd	r24, Y+2	; 0x02
    1ec8:	88 23       	and	r24, r24
    1eca:	21 f1       	breq	.+72     	; 0x1f14 <xQueueSemaphoreTake+0x84>
			{
				traceQUEUE_RECEIVE( pxQueue );

				/* Semaphores are queues with a data size of zero and where the
				messages waiting is the semaphore's count.  Reduce the count. */
				pxQueue->uxMessagesWaiting = uxSemaphoreCount - ( UBaseType_t ) 1;
    1ecc:	8a 81       	ldd	r24, Y+2	; 0x02
    1ece:	81 50       	subi	r24, 0x01	; 1
    1ed0:	ec 81       	ldd	r30, Y+4	; 0x04
    1ed2:	fd 81       	ldd	r31, Y+5	; 0x05
    1ed4:	82 8f       	std	Z+26, r24	; 0x1a

				#if ( configUSE_MUTEXES == 1 )
				{
					if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
    1ed6:	ec 81       	ldd	r30, Y+4	; 0x04
    1ed8:	fd 81       	ldd	r31, Y+5	; 0x05
    1eda:	80 81       	ld	r24, Z
    1edc:	91 81       	ldd	r25, Z+1	; 0x01
    1ede:	00 97       	sbiw	r24, 0x00	; 0
    1ee0:	31 f4       	brne	.+12     	; 0x1eee <xQueueSemaphoreTake+0x5e>
					{
						/* Record the information required to implement
						priority inheritance should it become necessary. */
						pxQueue->u.xSemaphore.xMutexHolder = pvTaskIncrementMutexHeldCount();
    1ee2:	0e 94 f3 25 	call	0x4be6	; 0x4be6 <pvTaskIncrementMutexHeldCount>
    1ee6:	ec 81       	ldd	r30, Y+4	; 0x04
    1ee8:	fd 81       	ldd	r31, Y+5	; 0x05
    1eea:	95 83       	std	Z+5, r25	; 0x05
    1eec:	84 83       	std	Z+4, r24	; 0x04
				}
				#endif /* configUSE_MUTEXES */

				/* Check to see if other tasks are blocked waiting to give the
				semaphore, and if so, unblock the highest priority such task. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    1eee:	ec 81       	ldd	r30, Y+4	; 0x04
    1ef0:	fd 81       	ldd	r31, Y+5	; 0x05
    1ef2:	80 85       	ldd	r24, Z+8	; 0x08
    1ef4:	88 23       	and	r24, r24
    1ef6:	49 f0       	breq	.+18     	; 0x1f0a <xQueueSemaphoreTake+0x7a>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    1ef8:	8c 81       	ldd	r24, Y+4	; 0x04
    1efa:	9d 81       	ldd	r25, Y+5	; 0x05
    1efc:	08 96       	adiw	r24, 0x08	; 8
    1efe:	0e 94 e4 21 	call	0x43c8	; 0x43c8 <xTaskRemoveFromEventList>
    1f02:	88 23       	and	r24, r24
    1f04:	11 f0       	breq	.+4      	; 0x1f0a <xQueueSemaphoreTake+0x7a>
					{
						queueYIELD_IF_USING_PREEMPTION();
    1f06:	0e 94 3c 0a 	call	0x1478	; 0x1478 <vPortYield>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				taskEXIT_CRITICAL();
    1f0a:	0f 90       	pop	r0
    1f0c:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
    1f0e:	81 e0       	ldi	r24, 0x01	; 1
    1f10:	8e 87       	std	Y+14, r24	; 0x0e
    1f12:	89 c0       	rjmp	.+274    	; 0x2026 <xQueueSemaphoreTake+0x196>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
    1f14:	8c 85       	ldd	r24, Y+12	; 0x0c
    1f16:	9d 85       	ldd	r25, Y+13	; 0x0d
    1f18:	00 97       	sbiw	r24, 0x00	; 0
    1f1a:	21 f4       	brne	.+8      	; 0x1f24 <xQueueSemaphoreTake+0x94>
					}
					#endif /* configUSE_MUTEXES */

					/* The semaphore count was 0 and no block time is specified
					(or the block time has expired) so exit now. */
					taskEXIT_CRITICAL();
    1f1c:	0f 90       	pop	r0
    1f1e:	0f be       	out	0x3f, r0	; 63
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
    1f20:	1e 86       	std	Y+14, r1	; 0x0e
    1f22:	81 c0       	rjmp	.+258    	; 0x2026 <xQueueSemaphoreTake+0x196>
				}
				else if( xEntryTimeSet == pdFALSE )
    1f24:	8e 81       	ldd	r24, Y+6	; 0x06
    1f26:	88 23       	and	r24, r24
    1f28:	31 f4       	brne	.+12     	; 0x1f36 <xQueueSemaphoreTake+0xa6>
				{
					/* The semaphore count was 0 and a block time was specified
					so configure the timeout structure ready to block. */
					vTaskInternalSetTimeOutState( &xTimeOut );
    1f2a:	ce 01       	movw	r24, r28
    1f2c:	07 96       	adiw	r24, 0x07	; 7
    1f2e:	0e 94 ca 22 	call	0x4594	; 0x4594 <vTaskInternalSetTimeOutState>
					xEntryTimeSet = pdTRUE;
    1f32:	81 e0       	ldi	r24, 0x01	; 1
    1f34:	8e 83       	std	Y+6, r24	; 0x06
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
    1f36:	0f 90       	pop	r0
    1f38:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can give to and take from the semaphore
		now the critical section has been exited. */

		vTaskSuspendAll();
    1f3a:	0e 94 44 1f 	call	0x3e88	; 0x3e88 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    1f3e:	0f b6       	in	r0, 0x3f	; 63
    1f40:	f8 94       	cli
    1f42:	0f 92       	push	r0
    1f44:	ec 81       	ldd	r30, Y+4	; 0x04
    1f46:	fd 81       	ldd	r31, Y+5	; 0x05
    1f48:	85 8d       	ldd	r24, Z+29	; 0x1d
    1f4a:	8f 3f       	cpi	r24, 0xFF	; 255
    1f4c:	19 f4       	brne	.+6      	; 0x1f54 <xQueueSemaphoreTake+0xc4>
    1f4e:	ec 81       	ldd	r30, Y+4	; 0x04
    1f50:	fd 81       	ldd	r31, Y+5	; 0x05
    1f52:	15 8e       	std	Z+29, r1	; 0x1d
    1f54:	ec 81       	ldd	r30, Y+4	; 0x04
    1f56:	fd 81       	ldd	r31, Y+5	; 0x05
    1f58:	86 8d       	ldd	r24, Z+30	; 0x1e
    1f5a:	8f 3f       	cpi	r24, 0xFF	; 255
    1f5c:	19 f4       	brne	.+6      	; 0x1f64 <xQueueSemaphoreTake+0xd4>
    1f5e:	ec 81       	ldd	r30, Y+4	; 0x04
    1f60:	fd 81       	ldd	r31, Y+5	; 0x05
    1f62:	16 8e       	std	Z+30, r1	; 0x1e
    1f64:	0f 90       	pop	r0
    1f66:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    1f68:	ce 01       	movw	r24, r28
    1f6a:	07 96       	adiw	r24, 0x07	; 7
    1f6c:	9e 01       	movw	r18, r28
    1f6e:	24 5f       	subi	r18, 0xF4	; 244
    1f70:	3f 4f       	sbci	r19, 0xFF	; 255
    1f72:	b9 01       	movw	r22, r18
    1f74:	0e 94 e3 22 	call	0x45c6	; 0x45c6 <xTaskCheckForTimeOut>
    1f78:	88 23       	and	r24, r24
    1f7a:	99 f5       	brne	.+102    	; 0x1fe2 <xQueueSemaphoreTake+0x152>
		{
			/* A block time is specified and not expired.  If the semaphore
			count is 0 then enter the Blocked state to wait for a semaphore to
			become available.  As semaphores are implemented with queues the
			queue being empty is equivalent to the semaphore count being 0. */
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    1f7c:	8c 81       	ldd	r24, Y+4	; 0x04
    1f7e:	9d 81       	ldd	r25, Y+5	; 0x05
    1f80:	0e 94 40 13 	call	0x2680	; 0x2680 <prvIsQueueEmpty>
    1f84:	88 23       	and	r24, r24
    1f86:	31 f1       	breq	.+76     	; 0x1fd4 <xQueueSemaphoreTake+0x144>
			{
				traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );

				#if ( configUSE_MUTEXES == 1 )
				{
					if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
    1f88:	ec 81       	ldd	r30, Y+4	; 0x04
    1f8a:	fd 81       	ldd	r31, Y+5	; 0x05
    1f8c:	80 81       	ld	r24, Z
    1f8e:	91 81       	ldd	r25, Z+1	; 0x01
    1f90:	00 97       	sbiw	r24, 0x00	; 0
    1f92:	61 f4       	brne	.+24     	; 0x1fac <xQueueSemaphoreTake+0x11c>
					{
						taskENTER_CRITICAL();
    1f94:	0f b6       	in	r0, 0x3f	; 63
    1f96:	f8 94       	cli
    1f98:	0f 92       	push	r0
						{
							xInheritanceOccurred = xTaskPriorityInherit( pxQueue->u.xSemaphore.xMutexHolder );
    1f9a:	ec 81       	ldd	r30, Y+4	; 0x04
    1f9c:	fd 81       	ldd	r31, Y+5	; 0x05
    1f9e:	84 81       	ldd	r24, Z+4	; 0x04
    1fa0:	95 81       	ldd	r25, Z+5	; 0x05
    1fa2:	0e 94 27 24 	call	0x484e	; 0x484e <xTaskPriorityInherit>
    1fa6:	8b 83       	std	Y+3, r24	; 0x03
						}
						taskEXIT_CRITICAL();
    1fa8:	0f 90       	pop	r0
    1faa:	0f be       	out	0x3f, r0	; 63
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    1fac:	8c 81       	ldd	r24, Y+4	; 0x04
    1fae:	9d 81       	ldd	r25, Y+5	; 0x05
    1fb0:	41 96       	adiw	r24, 0x11	; 17
    1fb2:	2c 85       	ldd	r18, Y+12	; 0x0c
    1fb4:	3d 85       	ldd	r19, Y+13	; 0x0d
    1fb6:	b9 01       	movw	r22, r18
    1fb8:	0e 94 92 21 	call	0x4324	; 0x4324 <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
    1fbc:	8c 81       	ldd	r24, Y+4	; 0x04
    1fbe:	9d 81       	ldd	r25, Y+5	; 0x05
    1fc0:	0e 94 ed 12 	call	0x25da	; 0x25da <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
    1fc4:	0e 94 50 1f 	call	0x3ea0	; 0x3ea0 <xTaskResumeAll>
    1fc8:	88 23       	and	r24, r24
    1fca:	09 f0       	breq	.+2      	; 0x1fce <xQueueSemaphoreTake+0x13e>
    1fcc:	75 cf       	rjmp	.-278    	; 0x1eb8 <xQueueSemaphoreTake+0x28>
				{
					portYIELD_WITHIN_API();
    1fce:	0e 94 3c 0a 	call	0x1478	; 0x1478 <vPortYield>
    1fd2:	72 cf       	rjmp	.-284    	; 0x1eb8 <xQueueSemaphoreTake+0x28>
			}
			else
			{
				/* There was no timeout and the semaphore count was not 0, so
				attempt to take the semaphore again. */
				prvUnlockQueue( pxQueue );
    1fd4:	8c 81       	ldd	r24, Y+4	; 0x04
    1fd6:	9d 81       	ldd	r25, Y+5	; 0x05
    1fd8:	0e 94 ed 12 	call	0x25da	; 0x25da <prvUnlockQueue>
				( void ) xTaskResumeAll();
    1fdc:	0e 94 50 1f 	call	0x3ea0	; 0x3ea0 <xTaskResumeAll>
    1fe0:	6b cf       	rjmp	.-298    	; 0x1eb8 <xQueueSemaphoreTake+0x28>
			}
		}
		else
		{
			/* Timed out. */
			prvUnlockQueue( pxQueue );
    1fe2:	8c 81       	ldd	r24, Y+4	; 0x04
    1fe4:	9d 81       	ldd	r25, Y+5	; 0x05
    1fe6:	0e 94 ed 12 	call	0x25da	; 0x25da <prvUnlockQueue>
			( void ) xTaskResumeAll();
    1fea:	0e 94 50 1f 	call	0x3ea0	; 0x3ea0 <xTaskResumeAll>

			/* If the semaphore count is 0 exit now as the timeout has
			expired.  Otherwise return to attempt to take the semaphore that is
			known to be available.  As semaphores are implemented by queues the
			queue being empty is equivalent to the semaphore count being 0. */
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    1fee:	8c 81       	ldd	r24, Y+4	; 0x04
    1ff0:	9d 81       	ldd	r25, Y+5	; 0x05
    1ff2:	0e 94 40 13 	call	0x2680	; 0x2680 <prvIsQueueEmpty>
    1ff6:	88 23       	and	r24, r24
    1ff8:	09 f4       	brne	.+2      	; 0x1ffc <xQueueSemaphoreTake+0x16c>
    1ffa:	5e cf       	rjmp	.-324    	; 0x1eb8 <xQueueSemaphoreTake+0x28>
				#if ( configUSE_MUTEXES == 1 )
				{
					/* xInheritanceOccurred could only have be set if
					pxQueue->uxQueueType == queueQUEUE_IS_MUTEX so no need to
					test the mutex type again to check it is actually a mutex. */
					if( xInheritanceOccurred != pdFALSE )
    1ffc:	8b 81       	ldd	r24, Y+3	; 0x03
    1ffe:	88 23       	and	r24, r24
    2000:	89 f0       	breq	.+34     	; 0x2024 <xQueueSemaphoreTake+0x194>
					{
						taskENTER_CRITICAL();
    2002:	0f b6       	in	r0, 0x3f	; 63
    2004:	f8 94       	cli
    2006:	0f 92       	push	r0
							/* This task blocking on the mutex caused another
							task to inherit this task's priority.  Now this task
							has timed out the priority should be disinherited
							again, but only as low as the next highest priority
							task that is waiting for the same mutex. */
							uxHighestWaitingPriority = prvGetDisinheritPriorityAfterTimeout( pxQueue );
    2008:	8c 81       	ldd	r24, Y+4	; 0x04
    200a:	9d 81       	ldd	r25, Y+5	; 0x05
    200c:	0e 94 cd 11 	call	0x239a	; 0x239a <prvGetDisinheritPriorityAfterTimeout>
    2010:	89 83       	std	Y+1, r24	; 0x01
							vTaskPriorityDisinheritAfterTimeout( pxQueue->u.xSemaphore.xMutexHolder, uxHighestWaitingPriority );
    2012:	ec 81       	ldd	r30, Y+4	; 0x04
    2014:	fd 81       	ldd	r31, Y+5	; 0x05
    2016:	84 81       	ldd	r24, Z+4	; 0x04
    2018:	95 81       	ldd	r25, Z+5	; 0x05
    201a:	69 81       	ldd	r22, Y+1	; 0x01
    201c:	0e 94 37 25 	call	0x4a6e	; 0x4a6e <vTaskPriorityDisinheritAfterTimeout>
						}
						taskEXIT_CRITICAL();
    2020:	0f 90       	pop	r0
    2022:	0f be       	out	0x3f, r0	; 63
					}
				}
				#endif /* configUSE_MUTEXES */

				traceQUEUE_RECEIVE_FAILED( pxQueue );
				return errQUEUE_EMPTY;
    2024:	1e 86       	std	Y+14, r1	; 0x0e
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
	} /*lint -restore */
    2026:	8e 85       	ldd	r24, Y+14	; 0x0e
}
    2028:	2e 96       	adiw	r28, 0x0e	; 14
    202a:	0f b6       	in	r0, 0x3f	; 63
    202c:	f8 94       	cli
    202e:	de bf       	out	0x3e, r29	; 62
    2030:	0f be       	out	0x3f, r0	; 63
    2032:	cd bf       	out	0x3d, r28	; 61
    2034:	cf 91       	pop	r28
    2036:	df 91       	pop	r29
    2038:	08 95       	ret

0000203a <xQueuePeek>:
/*-----------------------------------------------------------*/

BaseType_t xQueuePeek( QueueHandle_t xQueue, void * const pvBuffer, TickType_t xTicksToWait )
{
    203a:	df 93       	push	r29
    203c:	cf 93       	push	r28
    203e:	cd b7       	in	r28, 0x3d	; 61
    2040:	de b7       	in	r29, 0x3e	; 62
    2042:	60 97       	sbiw	r28, 0x10	; 16
    2044:	0f b6       	in	r0, 0x3f	; 63
    2046:	f8 94       	cli
    2048:	de bf       	out	0x3e, r29	; 62
    204a:	0f be       	out	0x3f, r0	; 63
    204c:	cd bf       	out	0x3d, r28	; 61
    204e:	9b 87       	std	Y+11, r25	; 0x0b
    2050:	8a 87       	std	Y+10, r24	; 0x0a
    2052:	7d 87       	std	Y+13, r23	; 0x0d
    2054:	6c 87       	std	Y+12, r22	; 0x0c
    2056:	5f 87       	std	Y+15, r21	; 0x0f
    2058:	4e 87       	std	Y+14, r20	; 0x0e
BaseType_t xEntryTimeSet = pdFALSE;
    205a:	1e 82       	std	Y+6, r1	; 0x06
TimeOut_t xTimeOut;
int8_t *pcOriginalReadPosition;
Queue_t * const pxQueue = xQueue;
    205c:	8a 85       	ldd	r24, Y+10	; 0x0a
    205e:	9b 85       	ldd	r25, Y+11	; 0x0b
    2060:	9b 83       	std	Y+3, r25	; 0x03
    2062:	8a 83       	std	Y+2, r24	; 0x02
	/*lint -save -e904  This function relaxes the coding standard somewhat to
	allow return statements within the function itself.  This is done in the
	interest of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
    2064:	0f b6       	in	r0, 0x3f	; 63
    2066:	f8 94       	cli
    2068:	0f 92       	push	r0
		{
			const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    206a:	ea 81       	ldd	r30, Y+2	; 0x02
    206c:	fb 81       	ldd	r31, Y+3	; 0x03
    206e:	82 8d       	ldd	r24, Z+26	; 0x1a
    2070:	89 83       	std	Y+1, r24	; 0x01

			/* Is there data in the queue now?  To be running the calling task
			must be the highest priority task wanting to access the queue. */
			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
    2072:	89 81       	ldd	r24, Y+1	; 0x01
    2074:	88 23       	and	r24, r24
    2076:	31 f1       	breq	.+76     	; 0x20c4 <xQueuePeek+0x8a>
			{
				/* Remember the read position so it can be reset after the data
				is read from the queue as this function is only peeking the
				data, not removing it. */
				pcOriginalReadPosition = pxQueue->u.xQueue.pcReadFrom;
    2078:	ea 81       	ldd	r30, Y+2	; 0x02
    207a:	fb 81       	ldd	r31, Y+3	; 0x03
    207c:	86 81       	ldd	r24, Z+6	; 0x06
    207e:	97 81       	ldd	r25, Z+7	; 0x07
    2080:	9d 83       	std	Y+5, r25	; 0x05
    2082:	8c 83       	std	Y+4, r24	; 0x04

				prvCopyDataFromQueue( pxQueue, pvBuffer );
    2084:	8a 81       	ldd	r24, Y+2	; 0x02
    2086:	9b 81       	ldd	r25, Y+3	; 0x03
    2088:	2c 85       	ldd	r18, Y+12	; 0x0c
    208a:	3d 85       	ldd	r19, Y+13	; 0x0d
    208c:	b9 01       	movw	r22, r18
    208e:	0e 94 a6 12 	call	0x254c	; 0x254c <prvCopyDataFromQueue>
				traceQUEUE_PEEK( pxQueue );

				/* The data is not being removed, so reset the read pointer. */
				pxQueue->u.xQueue.pcReadFrom = pcOriginalReadPosition;
    2092:	ea 81       	ldd	r30, Y+2	; 0x02
    2094:	fb 81       	ldd	r31, Y+3	; 0x03
    2096:	8c 81       	ldd	r24, Y+4	; 0x04
    2098:	9d 81       	ldd	r25, Y+5	; 0x05
    209a:	97 83       	std	Z+7, r25	; 0x07
    209c:	86 83       	std	Z+6, r24	; 0x06

				/* The data is being left in the queue, so see if there are
				any other tasks waiting for the data. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    209e:	ea 81       	ldd	r30, Y+2	; 0x02
    20a0:	fb 81       	ldd	r31, Y+3	; 0x03
    20a2:	81 89       	ldd	r24, Z+17	; 0x11
    20a4:	88 23       	and	r24, r24
    20a6:	49 f0       	breq	.+18     	; 0x20ba <xQueuePeek+0x80>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    20a8:	8a 81       	ldd	r24, Y+2	; 0x02
    20aa:	9b 81       	ldd	r25, Y+3	; 0x03
    20ac:	41 96       	adiw	r24, 0x11	; 17
    20ae:	0e 94 e4 21 	call	0x43c8	; 0x43c8 <xTaskRemoveFromEventList>
    20b2:	88 23       	and	r24, r24
    20b4:	11 f0       	breq	.+4      	; 0x20ba <xQueuePeek+0x80>
					{
						/* The task waiting has a higher priority than this task. */
						queueYIELD_IF_USING_PREEMPTION();
    20b6:	0e 94 3c 0a 	call	0x1478	; 0x1478 <vPortYield>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				taskEXIT_CRITICAL();
    20ba:	0f 90       	pop	r0
    20bc:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
    20be:	81 e0       	ldi	r24, 0x01	; 1
    20c0:	88 8b       	std	Y+16, r24	; 0x10
    20c2:	63 c0       	rjmp	.+198    	; 0x218a <xQueuePeek+0x150>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
    20c4:	8e 85       	ldd	r24, Y+14	; 0x0e
    20c6:	9f 85       	ldd	r25, Y+15	; 0x0f
    20c8:	00 97       	sbiw	r24, 0x00	; 0
    20ca:	21 f4       	brne	.+8      	; 0x20d4 <xQueuePeek+0x9a>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    20cc:	0f 90       	pop	r0
    20ce:	0f be       	out	0x3f, r0	; 63
					traceQUEUE_PEEK_FAILED( pxQueue );
					return errQUEUE_EMPTY;
    20d0:	18 8a       	std	Y+16, r1	; 0x10
    20d2:	5b c0       	rjmp	.+182    	; 0x218a <xQueuePeek+0x150>
				}
				else if( xEntryTimeSet == pdFALSE )
    20d4:	8e 81       	ldd	r24, Y+6	; 0x06
    20d6:	88 23       	and	r24, r24
    20d8:	31 f4       	brne	.+12     	; 0x20e6 <xQueuePeek+0xac>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure ready to enter the blocked
					state. */
					vTaskInternalSetTimeOutState( &xTimeOut );
    20da:	ce 01       	movw	r24, r28
    20dc:	07 96       	adiw	r24, 0x07	; 7
    20de:	0e 94 ca 22 	call	0x4594	; 0x4594 <vTaskInternalSetTimeOutState>
					xEntryTimeSet = pdTRUE;
    20e2:	81 e0       	ldi	r24, 0x01	; 1
    20e4:	8e 83       	std	Y+6, r24	; 0x06
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
    20e6:	0f 90       	pop	r0
    20e8:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    20ea:	0e 94 44 1f 	call	0x3e88	; 0x3e88 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    20ee:	0f b6       	in	r0, 0x3f	; 63
    20f0:	f8 94       	cli
    20f2:	0f 92       	push	r0
    20f4:	ea 81       	ldd	r30, Y+2	; 0x02
    20f6:	fb 81       	ldd	r31, Y+3	; 0x03
    20f8:	85 8d       	ldd	r24, Z+29	; 0x1d
    20fa:	8f 3f       	cpi	r24, 0xFF	; 255
    20fc:	19 f4       	brne	.+6      	; 0x2104 <xQueuePeek+0xca>
    20fe:	ea 81       	ldd	r30, Y+2	; 0x02
    2100:	fb 81       	ldd	r31, Y+3	; 0x03
    2102:	15 8e       	std	Z+29, r1	; 0x1d
    2104:	ea 81       	ldd	r30, Y+2	; 0x02
    2106:	fb 81       	ldd	r31, Y+3	; 0x03
    2108:	86 8d       	ldd	r24, Z+30	; 0x1e
    210a:	8f 3f       	cpi	r24, 0xFF	; 255
    210c:	19 f4       	brne	.+6      	; 0x2114 <xQueuePeek+0xda>
    210e:	ea 81       	ldd	r30, Y+2	; 0x02
    2110:	fb 81       	ldd	r31, Y+3	; 0x03
    2112:	16 8e       	std	Z+30, r1	; 0x1e
    2114:	0f 90       	pop	r0
    2116:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    2118:	ce 01       	movw	r24, r28
    211a:	07 96       	adiw	r24, 0x07	; 7
    211c:	9e 01       	movw	r18, r28
    211e:	22 5f       	subi	r18, 0xF2	; 242
    2120:	3f 4f       	sbci	r19, 0xFF	; 255
    2122:	b9 01       	movw	r22, r18
    2124:	0e 94 e3 22 	call	0x45c6	; 0x45c6 <xTaskCheckForTimeOut>
    2128:	88 23       	and	r24, r24
    212a:	09 f5       	brne	.+66     	; 0x216e <xQueuePeek+0x134>
		{
			/* Timeout has not expired yet, check to see if there is data in the
			queue now, and if not enter the Blocked state to wait for data. */
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    212c:	8a 81       	ldd	r24, Y+2	; 0x02
    212e:	9b 81       	ldd	r25, Y+3	; 0x03
    2130:	0e 94 40 13 	call	0x2680	; 0x2680 <prvIsQueueEmpty>
    2134:	88 23       	and	r24, r24
    2136:	a1 f0       	breq	.+40     	; 0x2160 <xQueuePeek+0x126>
			{
				traceBLOCKING_ON_QUEUE_PEEK( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    2138:	8a 81       	ldd	r24, Y+2	; 0x02
    213a:	9b 81       	ldd	r25, Y+3	; 0x03
    213c:	41 96       	adiw	r24, 0x11	; 17
    213e:	2e 85       	ldd	r18, Y+14	; 0x0e
    2140:	3f 85       	ldd	r19, Y+15	; 0x0f
    2142:	b9 01       	movw	r22, r18
    2144:	0e 94 92 21 	call	0x4324	; 0x4324 <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
    2148:	8a 81       	ldd	r24, Y+2	; 0x02
    214a:	9b 81       	ldd	r25, Y+3	; 0x03
    214c:	0e 94 ed 12 	call	0x25da	; 0x25da <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
    2150:	0e 94 50 1f 	call	0x3ea0	; 0x3ea0 <xTaskResumeAll>
    2154:	88 23       	and	r24, r24
    2156:	09 f0       	breq	.+2      	; 0x215a <xQueuePeek+0x120>
    2158:	85 cf       	rjmp	.-246    	; 0x2064 <xQueuePeek+0x2a>
				{
					portYIELD_WITHIN_API();
    215a:	0e 94 3c 0a 	call	0x1478	; 0x1478 <vPortYield>
    215e:	82 cf       	rjmp	.-252    	; 0x2064 <xQueuePeek+0x2a>
			}
			else
			{
				/* There is data in the queue now, so don't enter the blocked
				state, instead return to try and obtain the data. */
				prvUnlockQueue( pxQueue );
    2160:	8a 81       	ldd	r24, Y+2	; 0x02
    2162:	9b 81       	ldd	r25, Y+3	; 0x03
    2164:	0e 94 ed 12 	call	0x25da	; 0x25da <prvUnlockQueue>
				( void ) xTaskResumeAll();
    2168:	0e 94 50 1f 	call	0x3ea0	; 0x3ea0 <xTaskResumeAll>
    216c:	7b cf       	rjmp	.-266    	; 0x2064 <xQueuePeek+0x2a>
		}
		else
		{
			/* The timeout has expired.  If there is still no data in the queue
			exit, otherwise go back and try to read the data again. */
			prvUnlockQueue( pxQueue );
    216e:	8a 81       	ldd	r24, Y+2	; 0x02
    2170:	9b 81       	ldd	r25, Y+3	; 0x03
    2172:	0e 94 ed 12 	call	0x25da	; 0x25da <prvUnlockQueue>
			( void ) xTaskResumeAll();
    2176:	0e 94 50 1f 	call	0x3ea0	; 0x3ea0 <xTaskResumeAll>

			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    217a:	8a 81       	ldd	r24, Y+2	; 0x02
    217c:	9b 81       	ldd	r25, Y+3	; 0x03
    217e:	0e 94 40 13 	call	0x2680	; 0x2680 <prvIsQueueEmpty>
    2182:	88 23       	and	r24, r24
    2184:	09 f4       	brne	.+2      	; 0x2188 <xQueuePeek+0x14e>
    2186:	6e cf       	rjmp	.-292    	; 0x2064 <xQueuePeek+0x2a>
			{
				traceQUEUE_PEEK_FAILED( pxQueue );
				return errQUEUE_EMPTY;
    2188:	18 8a       	std	Y+16, r1	; 0x10
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
	} /*lint -restore */
    218a:	88 89       	ldd	r24, Y+16	; 0x10
}
    218c:	60 96       	adiw	r28, 0x10	; 16
    218e:	0f b6       	in	r0, 0x3f	; 63
    2190:	f8 94       	cli
    2192:	de bf       	out	0x3e, r29	; 62
    2194:	0f be       	out	0x3f, r0	; 63
    2196:	cd bf       	out	0x3d, r28	; 61
    2198:	cf 91       	pop	r28
    219a:	df 91       	pop	r29
    219c:	08 95       	ret

0000219e <xQueueReceiveFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueReceiveFromISR( QueueHandle_t xQueue, void * const pvBuffer, BaseType_t * const pxHigherPriorityTaskWoken )
{
    219e:	df 93       	push	r29
    21a0:	cf 93       	push	r28
    21a2:	cd b7       	in	r28, 0x3d	; 61
    21a4:	de b7       	in	r29, 0x3e	; 62
    21a6:	2c 97       	sbiw	r28, 0x0c	; 12
    21a8:	0f b6       	in	r0, 0x3f	; 63
    21aa:	f8 94       	cli
    21ac:	de bf       	out	0x3e, r29	; 62
    21ae:	0f be       	out	0x3f, r0	; 63
    21b0:	cd bf       	out	0x3d, r28	; 61
    21b2:	98 87       	std	Y+8, r25	; 0x08
    21b4:	8f 83       	std	Y+7, r24	; 0x07
    21b6:	7a 87       	std	Y+10, r23	; 0x0a
    21b8:	69 87       	std	Y+9, r22	; 0x09
    21ba:	5c 87       	std	Y+12, r21	; 0x0c
    21bc:	4b 87       	std	Y+11, r20	; 0x0b
BaseType_t xReturn;
UBaseType_t uxSavedInterruptStatus;
Queue_t * const pxQueue = xQueue;
    21be:	8f 81       	ldd	r24, Y+7	; 0x07
    21c0:	98 85       	ldd	r25, Y+8	; 0x08
    21c2:	9c 83       	std	Y+4, r25	; 0x04
    21c4:	8b 83       	std	Y+3, r24	; 0x03
	safe API to ensure interrupt entry is as fast and as simple as possible.
	More information (albeit Cortex-M specific) is provided on the following
	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    21c6:	1d 82       	std	Y+5, r1	; 0x05
	{
		const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    21c8:	eb 81       	ldd	r30, Y+3	; 0x03
    21ca:	fc 81       	ldd	r31, Y+4	; 0x04
    21cc:	82 8d       	ldd	r24, Z+26	; 0x1a
    21ce:	8a 83       	std	Y+2, r24	; 0x02

		/* Cannot block in an ISR, so check there is data available. */
		if( uxMessagesWaiting > ( UBaseType_t ) 0 )
    21d0:	8a 81       	ldd	r24, Y+2	; 0x02
    21d2:	88 23       	and	r24, r24
    21d4:	81 f1       	breq	.+96     	; 0x2236 <xQueueReceiveFromISR+0x98>
		{
			const int8_t cRxLock = pxQueue->cRxLock;
    21d6:	eb 81       	ldd	r30, Y+3	; 0x03
    21d8:	fc 81       	ldd	r31, Y+4	; 0x04
    21da:	85 8d       	ldd	r24, Z+29	; 0x1d
    21dc:	89 83       	std	Y+1, r24	; 0x01

			traceQUEUE_RECEIVE_FROM_ISR( pxQueue );

			prvCopyDataFromQueue( pxQueue, pvBuffer );
    21de:	8b 81       	ldd	r24, Y+3	; 0x03
    21e0:	9c 81       	ldd	r25, Y+4	; 0x04
    21e2:	29 85       	ldd	r18, Y+9	; 0x09
    21e4:	3a 85       	ldd	r19, Y+10	; 0x0a
    21e6:	b9 01       	movw	r22, r18
    21e8:	0e 94 a6 12 	call	0x254c	; 0x254c <prvCopyDataFromQueue>
			pxQueue->uxMessagesWaiting = uxMessagesWaiting - ( UBaseType_t ) 1;
    21ec:	8a 81       	ldd	r24, Y+2	; 0x02
    21ee:	81 50       	subi	r24, 0x01	; 1
    21f0:	eb 81       	ldd	r30, Y+3	; 0x03
    21f2:	fc 81       	ldd	r31, Y+4	; 0x04
    21f4:	82 8f       	std	Z+26, r24	; 0x1a

			/* If the queue is locked the event list will not be modified.
			Instead update the lock count so the task that unlocks the queue
			will know that an ISR has removed data while the queue was
			locked. */
			if( cRxLock == queueUNLOCKED )
    21f6:	89 81       	ldd	r24, Y+1	; 0x01
    21f8:	8f 3f       	cpi	r24, 0xFF	; 255
    21fa:	a9 f4       	brne	.+42     	; 0x2226 <xQueueReceiveFromISR+0x88>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    21fc:	eb 81       	ldd	r30, Y+3	; 0x03
    21fe:	fc 81       	ldd	r31, Y+4	; 0x04
    2200:	80 85       	ldd	r24, Z+8	; 0x08
    2202:	88 23       	and	r24, r24
    2204:	a9 f0       	breq	.+42     	; 0x2230 <xQueueReceiveFromISR+0x92>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    2206:	8b 81       	ldd	r24, Y+3	; 0x03
    2208:	9c 81       	ldd	r25, Y+4	; 0x04
    220a:	08 96       	adiw	r24, 0x08	; 8
    220c:	0e 94 e4 21 	call	0x43c8	; 0x43c8 <xTaskRemoveFromEventList>
    2210:	88 23       	and	r24, r24
    2212:	71 f0       	breq	.+28     	; 0x2230 <xQueueReceiveFromISR+0x92>
					{
						/* The task waiting has a higher priority than us so
						force a context switch. */
						if( pxHigherPriorityTaskWoken != NULL )
    2214:	8b 85       	ldd	r24, Y+11	; 0x0b
    2216:	9c 85       	ldd	r25, Y+12	; 0x0c
    2218:	00 97       	sbiw	r24, 0x00	; 0
    221a:	51 f0       	breq	.+20     	; 0x2230 <xQueueReceiveFromISR+0x92>
						{
							*pxHigherPriorityTaskWoken = pdTRUE;
    221c:	eb 85       	ldd	r30, Y+11	; 0x0b
    221e:	fc 85       	ldd	r31, Y+12	; 0x0c
    2220:	81 e0       	ldi	r24, 0x01	; 1
    2222:	80 83       	st	Z, r24
    2224:	05 c0       	rjmp	.+10     	; 0x2230 <xQueueReceiveFromISR+0x92>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was removed while it was locked. */
				pxQueue->cRxLock = ( int8_t ) ( cRxLock + 1 );
    2226:	89 81       	ldd	r24, Y+1	; 0x01
    2228:	8f 5f       	subi	r24, 0xFF	; 255
    222a:	eb 81       	ldd	r30, Y+3	; 0x03
    222c:	fc 81       	ldd	r31, Y+4	; 0x04
    222e:	85 8f       	std	Z+29, r24	; 0x1d
			}

			xReturn = pdPASS;
    2230:	81 e0       	ldi	r24, 0x01	; 1
    2232:	8e 83       	std	Y+6, r24	; 0x06
    2234:	01 c0       	rjmp	.+2      	; 0x2238 <xQueueReceiveFromISR+0x9a>
		}
		else
		{
			xReturn = pdFAIL;
    2236:	1e 82       	std	Y+6, r1	; 0x06
			traceQUEUE_RECEIVE_FROM_ISR_FAILED( pxQueue );
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
    2238:	8e 81       	ldd	r24, Y+6	; 0x06
}
    223a:	2c 96       	adiw	r28, 0x0c	; 12
    223c:	0f b6       	in	r0, 0x3f	; 63
    223e:	f8 94       	cli
    2240:	de bf       	out	0x3e, r29	; 62
    2242:	0f be       	out	0x3f, r0	; 63
    2244:	cd bf       	out	0x3d, r28	; 61
    2246:	cf 91       	pop	r28
    2248:	df 91       	pop	r29
    224a:	08 95       	ret

0000224c <xQueuePeekFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueuePeekFromISR( QueueHandle_t xQueue,  void * const pvBuffer )
{
    224c:	df 93       	push	r29
    224e:	cf 93       	push	r28
    2250:	cd b7       	in	r28, 0x3d	; 61
    2252:	de b7       	in	r29, 0x3e	; 62
    2254:	2a 97       	sbiw	r28, 0x0a	; 10
    2256:	0f b6       	in	r0, 0x3f	; 63
    2258:	f8 94       	cli
    225a:	de bf       	out	0x3e, r29	; 62
    225c:	0f be       	out	0x3f, r0	; 63
    225e:	cd bf       	out	0x3d, r28	; 61
    2260:	98 87       	std	Y+8, r25	; 0x08
    2262:	8f 83       	std	Y+7, r24	; 0x07
    2264:	7a 87       	std	Y+10, r23	; 0x0a
    2266:	69 87       	std	Y+9, r22	; 0x09
BaseType_t xReturn;
UBaseType_t uxSavedInterruptStatus;
int8_t *pcOriginalReadPosition;
Queue_t * const pxQueue = xQueue;
    2268:	8f 81       	ldd	r24, Y+7	; 0x07
    226a:	98 85       	ldd	r25, Y+8	; 0x08
    226c:	9a 83       	std	Y+2, r25	; 0x02
    226e:	89 83       	std	Y+1, r24	; 0x01
	safe API to ensure interrupt entry is as fast and as simple as possible.
	More information (albeit Cortex-M specific) is provided on the following
	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    2270:	1d 82       	std	Y+5, r1	; 0x05
	{
		/* Cannot block in an ISR, so check there is data available. */
		if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
    2272:	e9 81       	ldd	r30, Y+1	; 0x01
    2274:	fa 81       	ldd	r31, Y+2	; 0x02
    2276:	82 8d       	ldd	r24, Z+26	; 0x1a
    2278:	88 23       	and	r24, r24
    227a:	b1 f0       	breq	.+44     	; 0x22a8 <xQueuePeekFromISR+0x5c>
		{
			traceQUEUE_PEEK_FROM_ISR( pxQueue );

			/* Remember the read position so it can be reset as nothing is
			actually being removed from the queue. */
			pcOriginalReadPosition = pxQueue->u.xQueue.pcReadFrom;
    227c:	e9 81       	ldd	r30, Y+1	; 0x01
    227e:	fa 81       	ldd	r31, Y+2	; 0x02
    2280:	86 81       	ldd	r24, Z+6	; 0x06
    2282:	97 81       	ldd	r25, Z+7	; 0x07
    2284:	9c 83       	std	Y+4, r25	; 0x04
    2286:	8b 83       	std	Y+3, r24	; 0x03
			prvCopyDataFromQueue( pxQueue, pvBuffer );
    2288:	89 81       	ldd	r24, Y+1	; 0x01
    228a:	9a 81       	ldd	r25, Y+2	; 0x02
    228c:	29 85       	ldd	r18, Y+9	; 0x09
    228e:	3a 85       	ldd	r19, Y+10	; 0x0a
    2290:	b9 01       	movw	r22, r18
    2292:	0e 94 a6 12 	call	0x254c	; 0x254c <prvCopyDataFromQueue>
			pxQueue->u.xQueue.pcReadFrom = pcOriginalReadPosition;
    2296:	e9 81       	ldd	r30, Y+1	; 0x01
    2298:	fa 81       	ldd	r31, Y+2	; 0x02
    229a:	8b 81       	ldd	r24, Y+3	; 0x03
    229c:	9c 81       	ldd	r25, Y+4	; 0x04
    229e:	97 83       	std	Z+7, r25	; 0x07
    22a0:	86 83       	std	Z+6, r24	; 0x06

			xReturn = pdPASS;
    22a2:	81 e0       	ldi	r24, 0x01	; 1
    22a4:	8e 83       	std	Y+6, r24	; 0x06
    22a6:	01 c0       	rjmp	.+2      	; 0x22aa <xQueuePeekFromISR+0x5e>
		}
		else
		{
			xReturn = pdFAIL;
    22a8:	1e 82       	std	Y+6, r1	; 0x06
			traceQUEUE_PEEK_FROM_ISR_FAILED( pxQueue );
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
    22aa:	8e 81       	ldd	r24, Y+6	; 0x06
}
    22ac:	2a 96       	adiw	r28, 0x0a	; 10
    22ae:	0f b6       	in	r0, 0x3f	; 63
    22b0:	f8 94       	cli
    22b2:	de bf       	out	0x3e, r29	; 62
    22b4:	0f be       	out	0x3f, r0	; 63
    22b6:	cd bf       	out	0x3d, r28	; 61
    22b8:	cf 91       	pop	r28
    22ba:	df 91       	pop	r29
    22bc:	08 95       	ret

000022be <uxQueueMessagesWaiting>:
/*-----------------------------------------------------------*/

UBaseType_t uxQueueMessagesWaiting( const QueueHandle_t xQueue )
{
    22be:	df 93       	push	r29
    22c0:	cf 93       	push	r28
    22c2:	00 d0       	rcall	.+0      	; 0x22c4 <uxQueueMessagesWaiting+0x6>
    22c4:	0f 92       	push	r0
    22c6:	cd b7       	in	r28, 0x3d	; 61
    22c8:	de b7       	in	r29, 0x3e	; 62
    22ca:	9b 83       	std	Y+3, r25	; 0x03
    22cc:	8a 83       	std	Y+2, r24	; 0x02
UBaseType_t uxReturn;

	configASSERT( xQueue );

	taskENTER_CRITICAL();
    22ce:	0f b6       	in	r0, 0x3f	; 63
    22d0:	f8 94       	cli
    22d2:	0f 92       	push	r0
	{
		uxReturn = ( ( Queue_t * ) xQueue )->uxMessagesWaiting;
    22d4:	ea 81       	ldd	r30, Y+2	; 0x02
    22d6:	fb 81       	ldd	r31, Y+3	; 0x03
    22d8:	82 8d       	ldd	r24, Z+26	; 0x1a
    22da:	89 83       	std	Y+1, r24	; 0x01
	}
	taskEXIT_CRITICAL();
    22dc:	0f 90       	pop	r0
    22de:	0f be       	out	0x3f, r0	; 63

	return uxReturn;
    22e0:	89 81       	ldd	r24, Y+1	; 0x01
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
    22e2:	0f 90       	pop	r0
    22e4:	0f 90       	pop	r0
    22e6:	0f 90       	pop	r0
    22e8:	cf 91       	pop	r28
    22ea:	df 91       	pop	r29
    22ec:	08 95       	ret

000022ee <uxQueueSpacesAvailable>:
/*-----------------------------------------------------------*/

UBaseType_t uxQueueSpacesAvailable( const QueueHandle_t xQueue )
{
    22ee:	df 93       	push	r29
    22f0:	cf 93       	push	r28
    22f2:	00 d0       	rcall	.+0      	; 0x22f4 <uxQueueSpacesAvailable+0x6>
    22f4:	00 d0       	rcall	.+0      	; 0x22f6 <uxQueueSpacesAvailable+0x8>
    22f6:	0f 92       	push	r0
    22f8:	cd b7       	in	r28, 0x3d	; 61
    22fa:	de b7       	in	r29, 0x3e	; 62
    22fc:	9d 83       	std	Y+5, r25	; 0x05
    22fe:	8c 83       	std	Y+4, r24	; 0x04
UBaseType_t uxReturn;
Queue_t * const pxQueue = xQueue;
    2300:	8c 81       	ldd	r24, Y+4	; 0x04
    2302:	9d 81       	ldd	r25, Y+5	; 0x05
    2304:	9a 83       	std	Y+2, r25	; 0x02
    2306:	89 83       	std	Y+1, r24	; 0x01

	configASSERT( pxQueue );

	taskENTER_CRITICAL();
    2308:	0f b6       	in	r0, 0x3f	; 63
    230a:	f8 94       	cli
    230c:	0f 92       	push	r0
	{
		uxReturn = pxQueue->uxLength - pxQueue->uxMessagesWaiting;
    230e:	e9 81       	ldd	r30, Y+1	; 0x01
    2310:	fa 81       	ldd	r31, Y+2	; 0x02
    2312:	93 8d       	ldd	r25, Z+27	; 0x1b
    2314:	e9 81       	ldd	r30, Y+1	; 0x01
    2316:	fa 81       	ldd	r31, Y+2	; 0x02
    2318:	82 8d       	ldd	r24, Z+26	; 0x1a
    231a:	29 2f       	mov	r18, r25
    231c:	28 1b       	sub	r18, r24
    231e:	82 2f       	mov	r24, r18
    2320:	8b 83       	std	Y+3, r24	; 0x03
	}
	taskEXIT_CRITICAL();
    2322:	0f 90       	pop	r0
    2324:	0f be       	out	0x3f, r0	; 63

	return uxReturn;
    2326:	8b 81       	ldd	r24, Y+3	; 0x03
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
    2328:	0f 90       	pop	r0
    232a:	0f 90       	pop	r0
    232c:	0f 90       	pop	r0
    232e:	0f 90       	pop	r0
    2330:	0f 90       	pop	r0
    2332:	cf 91       	pop	r28
    2334:	df 91       	pop	r29
    2336:	08 95       	ret

00002338 <uxQueueMessagesWaitingFromISR>:
/*-----------------------------------------------------------*/

UBaseType_t uxQueueMessagesWaitingFromISR( const QueueHandle_t xQueue )
{
    2338:	df 93       	push	r29
    233a:	cf 93       	push	r28
    233c:	00 d0       	rcall	.+0      	; 0x233e <uxQueueMessagesWaitingFromISR+0x6>
    233e:	00 d0       	rcall	.+0      	; 0x2340 <uxQueueMessagesWaitingFromISR+0x8>
    2340:	0f 92       	push	r0
    2342:	cd b7       	in	r28, 0x3d	; 61
    2344:	de b7       	in	r29, 0x3e	; 62
    2346:	9d 83       	std	Y+5, r25	; 0x05
    2348:	8c 83       	std	Y+4, r24	; 0x04
UBaseType_t uxReturn;
Queue_t * const pxQueue = xQueue;
    234a:	8c 81       	ldd	r24, Y+4	; 0x04
    234c:	9d 81       	ldd	r25, Y+5	; 0x05
    234e:	9a 83       	std	Y+2, r25	; 0x02
    2350:	89 83       	std	Y+1, r24	; 0x01

	configASSERT( pxQueue );
	uxReturn = pxQueue->uxMessagesWaiting;
    2352:	e9 81       	ldd	r30, Y+1	; 0x01
    2354:	fa 81       	ldd	r31, Y+2	; 0x02
    2356:	82 8d       	ldd	r24, Z+26	; 0x1a
    2358:	8b 83       	std	Y+3, r24	; 0x03

	return uxReturn;
    235a:	8b 81       	ldd	r24, Y+3	; 0x03
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
    235c:	0f 90       	pop	r0
    235e:	0f 90       	pop	r0
    2360:	0f 90       	pop	r0
    2362:	0f 90       	pop	r0
    2364:	0f 90       	pop	r0
    2366:	cf 91       	pop	r28
    2368:	df 91       	pop	r29
    236a:	08 95       	ret

0000236c <vQueueDelete>:
/*-----------------------------------------------------------*/

void vQueueDelete( QueueHandle_t xQueue )
{
    236c:	df 93       	push	r29
    236e:	cf 93       	push	r28
    2370:	00 d0       	rcall	.+0      	; 0x2372 <vQueueDelete+0x6>
    2372:	00 d0       	rcall	.+0      	; 0x2374 <vQueueDelete+0x8>
    2374:	cd b7       	in	r28, 0x3d	; 61
    2376:	de b7       	in	r29, 0x3e	; 62
    2378:	9c 83       	std	Y+4, r25	; 0x04
    237a:	8b 83       	std	Y+3, r24	; 0x03
Queue_t * const pxQueue = xQueue;
    237c:	8b 81       	ldd	r24, Y+3	; 0x03
    237e:	9c 81       	ldd	r25, Y+4	; 0x04
    2380:	9a 83       	std	Y+2, r25	; 0x02
    2382:	89 83       	std	Y+1, r24	; 0x01

	#if( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) )
	{
		/* The queue can only have been allocated dynamically - free it
		again. */
		vPortFree( pxQueue );
    2384:	89 81       	ldd	r24, Y+1	; 0x01
    2386:	9a 81       	ldd	r25, Y+2	; 0x02
    2388:	0e 94 80 06 	call	0xd00	; 0xd00 <vPortFree>
		/* The queue must have been statically allocated, so is not going to be
		deleted.  Avoid compiler warnings about the unused parameter. */
		( void ) pxQueue;
	}
	#endif /* configSUPPORT_DYNAMIC_ALLOCATION */
}
    238c:	0f 90       	pop	r0
    238e:	0f 90       	pop	r0
    2390:	0f 90       	pop	r0
    2392:	0f 90       	pop	r0
    2394:	cf 91       	pop	r28
    2396:	df 91       	pop	r29
    2398:	08 95       	ret

0000239a <prvGetDisinheritPriorityAfterTimeout>:
/*-----------------------------------------------------------*/

#if( configUSE_MUTEXES == 1 )

	static UBaseType_t prvGetDisinheritPriorityAfterTimeout( const Queue_t * const pxQueue )
	{
    239a:	df 93       	push	r29
    239c:	cf 93       	push	r28
    239e:	00 d0       	rcall	.+0      	; 0x23a0 <prvGetDisinheritPriorityAfterTimeout+0x6>
    23a0:	0f 92       	push	r0
    23a2:	cd b7       	in	r28, 0x3d	; 61
    23a4:	de b7       	in	r29, 0x3e	; 62
    23a6:	9b 83       	std	Y+3, r25	; 0x03
    23a8:	8a 83       	std	Y+2, r24	; 0x02
		priority, but the waiting task times out, then the holder should
		disinherit the priority - but only down to the highest priority of any
		other tasks that are waiting for the same mutex.  For this purpose,
		return the priority of the highest priority task that is waiting for the
		mutex. */
		if( listCURRENT_LIST_LENGTH( &( pxQueue->xTasksWaitingToReceive ) ) > 0U )
    23aa:	ea 81       	ldd	r30, Y+2	; 0x02
    23ac:	fb 81       	ldd	r31, Y+3	; 0x03
    23ae:	81 89       	ldd	r24, Z+17	; 0x11
    23b0:	88 23       	and	r24, r24
    23b2:	61 f0       	breq	.+24     	; 0x23cc <prvGetDisinheritPriorityAfterTimeout+0x32>
		{
			uxHighestPriorityOfWaitingTasks = ( UBaseType_t ) configMAX_PRIORITIES - ( UBaseType_t ) listGET_ITEM_VALUE_OF_HEAD_ENTRY( &( pxQueue->xTasksWaitingToReceive ) );
    23b4:	ea 81       	ldd	r30, Y+2	; 0x02
    23b6:	fb 81       	ldd	r31, Y+3	; 0x03
    23b8:	06 88       	ldd	r0, Z+22	; 0x16
    23ba:	f7 89       	ldd	r31, Z+23	; 0x17
    23bc:	e0 2d       	mov	r30, r0
    23be:	80 81       	ld	r24, Z
    23c0:	91 81       	ldd	r25, Z+1	; 0x01
    23c2:	98 2f       	mov	r25, r24
    23c4:	84 e0       	ldi	r24, 0x04	; 4
    23c6:	89 1b       	sub	r24, r25
    23c8:	89 83       	std	Y+1, r24	; 0x01
    23ca:	01 c0       	rjmp	.+2      	; 0x23ce <prvGetDisinheritPriorityAfterTimeout+0x34>
		}
		else
		{
			uxHighestPriorityOfWaitingTasks = tskIDLE_PRIORITY;
    23cc:	19 82       	std	Y+1, r1	; 0x01
		}

		return uxHighestPriorityOfWaitingTasks;
    23ce:	89 81       	ldd	r24, Y+1	; 0x01
	}
    23d0:	0f 90       	pop	r0
    23d2:	0f 90       	pop	r0
    23d4:	0f 90       	pop	r0
    23d6:	cf 91       	pop	r28
    23d8:	df 91       	pop	r29
    23da:	08 95       	ret

000023dc <prvCopyDataToQueue>:

#endif /* configUSE_MUTEXES */
/*-----------------------------------------------------------*/

static BaseType_t prvCopyDataToQueue( Queue_t * const pxQueue, const void *pvItemToQueue, const BaseType_t xPosition )
{
    23dc:	df 93       	push	r29
    23de:	cf 93       	push	r28
    23e0:	cd b7       	in	r28, 0x3d	; 61
    23e2:	de b7       	in	r29, 0x3e	; 62
    23e4:	27 97       	sbiw	r28, 0x07	; 7
    23e6:	0f b6       	in	r0, 0x3f	; 63
    23e8:	f8 94       	cli
    23ea:	de bf       	out	0x3e, r29	; 62
    23ec:	0f be       	out	0x3f, r0	; 63
    23ee:	cd bf       	out	0x3d, r28	; 61
    23f0:	9c 83       	std	Y+4, r25	; 0x04
    23f2:	8b 83       	std	Y+3, r24	; 0x03
    23f4:	7e 83       	std	Y+6, r23	; 0x06
    23f6:	6d 83       	std	Y+5, r22	; 0x05
    23f8:	4f 83       	std	Y+7, r20	; 0x07
BaseType_t xReturn = pdFALSE;
    23fa:	1a 82       	std	Y+2, r1	; 0x02
UBaseType_t uxMessagesWaiting;

	/* This function is called from a critical section. */

	uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    23fc:	eb 81       	ldd	r30, Y+3	; 0x03
    23fe:	fc 81       	ldd	r31, Y+4	; 0x04
    2400:	82 8d       	ldd	r24, Z+26	; 0x1a
    2402:	89 83       	std	Y+1, r24	; 0x01

	if( pxQueue->uxItemSize == ( UBaseType_t ) 0 )
    2404:	eb 81       	ldd	r30, Y+3	; 0x03
    2406:	fc 81       	ldd	r31, Y+4	; 0x04
    2408:	84 8d       	ldd	r24, Z+28	; 0x1c
    240a:	88 23       	and	r24, r24
    240c:	99 f4       	brne	.+38     	; 0x2434 <prvCopyDataToQueue+0x58>
	{
		#if ( configUSE_MUTEXES == 1 )
		{
			if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
    240e:	eb 81       	ldd	r30, Y+3	; 0x03
    2410:	fc 81       	ldd	r31, Y+4	; 0x04
    2412:	80 81       	ld	r24, Z
    2414:	91 81       	ldd	r25, Z+1	; 0x01
    2416:	00 97       	sbiw	r24, 0x00	; 0
    2418:	09 f0       	breq	.+2      	; 0x241c <prvCopyDataToQueue+0x40>
    241a:	89 c0       	rjmp	.+274    	; 0x252e <prvCopyDataToQueue+0x152>
			{
				/* The mutex is no longer being held. */
				xReturn = xTaskPriorityDisinherit( pxQueue->u.xSemaphore.xMutexHolder );
    241c:	eb 81       	ldd	r30, Y+3	; 0x03
    241e:	fc 81       	ldd	r31, Y+4	; 0x04
    2420:	84 81       	ldd	r24, Z+4	; 0x04
    2422:	95 81       	ldd	r25, Z+5	; 0x05
    2424:	0e 94 c5 24 	call	0x498a	; 0x498a <xTaskPriorityDisinherit>
    2428:	8a 83       	std	Y+2, r24	; 0x02
				pxQueue->u.xSemaphore.xMutexHolder = NULL;
    242a:	eb 81       	ldd	r30, Y+3	; 0x03
    242c:	fc 81       	ldd	r31, Y+4	; 0x04
    242e:	15 82       	std	Z+5, r1	; 0x05
    2430:	14 82       	std	Z+4, r1	; 0x04
    2432:	7d c0       	rjmp	.+250    	; 0x252e <prvCopyDataToQueue+0x152>
				mtCOVERAGE_TEST_MARKER();
			}
		}
		#endif /* configUSE_MUTEXES */
	}
	else if( xPosition == queueSEND_TO_BACK )
    2434:	8f 81       	ldd	r24, Y+7	; 0x07
    2436:	88 23       	and	r24, r24
    2438:	99 f5       	brne	.+102    	; 0x24a0 <prvCopyDataToQueue+0xc4>
	{
		( void ) memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 !e9087 MISRA exception as the casts are only redundant for some ports, plus previous logic ensures a null pointer can only be passed to memcpy() if the copy size is 0.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes. */
    243a:	eb 81       	ldd	r30, Y+3	; 0x03
    243c:	fc 81       	ldd	r31, Y+4	; 0x04
    243e:	62 81       	ldd	r22, Z+2	; 0x02
    2440:	73 81       	ldd	r23, Z+3	; 0x03
    2442:	eb 81       	ldd	r30, Y+3	; 0x03
    2444:	fc 81       	ldd	r31, Y+4	; 0x04
    2446:	84 8d       	ldd	r24, Z+28	; 0x1c
    2448:	48 2f       	mov	r20, r24
    244a:	50 e0       	ldi	r21, 0x00	; 0
    244c:	2d 81       	ldd	r18, Y+5	; 0x05
    244e:	3e 81       	ldd	r19, Y+6	; 0x06
    2450:	cb 01       	movw	r24, r22
    2452:	b9 01       	movw	r22, r18
    2454:	0e 94 2f 2a 	call	0x545e	; 0x545e <memcpy>
		pxQueue->pcWriteTo += pxQueue->uxItemSize; /*lint !e9016 Pointer arithmetic on char types ok, especially in this use case where it is the clearest way of conveying intent. */
    2458:	eb 81       	ldd	r30, Y+3	; 0x03
    245a:	fc 81       	ldd	r31, Y+4	; 0x04
    245c:	22 81       	ldd	r18, Z+2	; 0x02
    245e:	33 81       	ldd	r19, Z+3	; 0x03
    2460:	eb 81       	ldd	r30, Y+3	; 0x03
    2462:	fc 81       	ldd	r31, Y+4	; 0x04
    2464:	84 8d       	ldd	r24, Z+28	; 0x1c
    2466:	88 2f       	mov	r24, r24
    2468:	90 e0       	ldi	r25, 0x00	; 0
    246a:	82 0f       	add	r24, r18
    246c:	93 1f       	adc	r25, r19
    246e:	eb 81       	ldd	r30, Y+3	; 0x03
    2470:	fc 81       	ldd	r31, Y+4	; 0x04
    2472:	93 83       	std	Z+3, r25	; 0x03
    2474:	82 83       	std	Z+2, r24	; 0x02
		if( pxQueue->pcWriteTo >= pxQueue->u.xQueue.pcTail ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
    2476:	eb 81       	ldd	r30, Y+3	; 0x03
    2478:	fc 81       	ldd	r31, Y+4	; 0x04
    247a:	22 81       	ldd	r18, Z+2	; 0x02
    247c:	33 81       	ldd	r19, Z+3	; 0x03
    247e:	eb 81       	ldd	r30, Y+3	; 0x03
    2480:	fc 81       	ldd	r31, Y+4	; 0x04
    2482:	84 81       	ldd	r24, Z+4	; 0x04
    2484:	95 81       	ldd	r25, Z+5	; 0x05
    2486:	28 17       	cp	r18, r24
    2488:	39 07       	cpc	r19, r25
    248a:	08 f4       	brcc	.+2      	; 0x248e <prvCopyDataToQueue+0xb2>
    248c:	50 c0       	rjmp	.+160    	; 0x252e <prvCopyDataToQueue+0x152>
		{
			pxQueue->pcWriteTo = pxQueue->pcHead;
    248e:	eb 81       	ldd	r30, Y+3	; 0x03
    2490:	fc 81       	ldd	r31, Y+4	; 0x04
    2492:	80 81       	ld	r24, Z
    2494:	91 81       	ldd	r25, Z+1	; 0x01
    2496:	eb 81       	ldd	r30, Y+3	; 0x03
    2498:	fc 81       	ldd	r31, Y+4	; 0x04
    249a:	93 83       	std	Z+3, r25	; 0x03
    249c:	82 83       	std	Z+2, r24	; 0x02
    249e:	47 c0       	rjmp	.+142    	; 0x252e <prvCopyDataToQueue+0x152>
			mtCOVERAGE_TEST_MARKER();
		}
	}
	else
	{
		( void ) memcpy( ( void * ) pxQueue->u.xQueue.pcReadFrom, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e9087 !e418 MISRA exception as the casts are only redundant for some ports.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes.  Assert checks null pointer only used when length is 0. */
    24a0:	eb 81       	ldd	r30, Y+3	; 0x03
    24a2:	fc 81       	ldd	r31, Y+4	; 0x04
    24a4:	66 81       	ldd	r22, Z+6	; 0x06
    24a6:	77 81       	ldd	r23, Z+7	; 0x07
    24a8:	eb 81       	ldd	r30, Y+3	; 0x03
    24aa:	fc 81       	ldd	r31, Y+4	; 0x04
    24ac:	84 8d       	ldd	r24, Z+28	; 0x1c
    24ae:	48 2f       	mov	r20, r24
    24b0:	50 e0       	ldi	r21, 0x00	; 0
    24b2:	2d 81       	ldd	r18, Y+5	; 0x05
    24b4:	3e 81       	ldd	r19, Y+6	; 0x06
    24b6:	cb 01       	movw	r24, r22
    24b8:	b9 01       	movw	r22, r18
    24ba:	0e 94 2f 2a 	call	0x545e	; 0x545e <memcpy>
		pxQueue->u.xQueue.pcReadFrom -= pxQueue->uxItemSize;
    24be:	eb 81       	ldd	r30, Y+3	; 0x03
    24c0:	fc 81       	ldd	r31, Y+4	; 0x04
    24c2:	26 81       	ldd	r18, Z+6	; 0x06
    24c4:	37 81       	ldd	r19, Z+7	; 0x07
    24c6:	eb 81       	ldd	r30, Y+3	; 0x03
    24c8:	fc 81       	ldd	r31, Y+4	; 0x04
    24ca:	84 8d       	ldd	r24, Z+28	; 0x1c
    24cc:	88 2f       	mov	r24, r24
    24ce:	90 e0       	ldi	r25, 0x00	; 0
    24d0:	90 95       	com	r25
    24d2:	81 95       	neg	r24
    24d4:	9f 4f       	sbci	r25, 0xFF	; 255
    24d6:	82 0f       	add	r24, r18
    24d8:	93 1f       	adc	r25, r19
    24da:	eb 81       	ldd	r30, Y+3	; 0x03
    24dc:	fc 81       	ldd	r31, Y+4	; 0x04
    24de:	97 83       	std	Z+7, r25	; 0x07
    24e0:	86 83       	std	Z+6, r24	; 0x06
		if( pxQueue->u.xQueue.pcReadFrom < pxQueue->pcHead ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
    24e2:	eb 81       	ldd	r30, Y+3	; 0x03
    24e4:	fc 81       	ldd	r31, Y+4	; 0x04
    24e6:	26 81       	ldd	r18, Z+6	; 0x06
    24e8:	37 81       	ldd	r19, Z+7	; 0x07
    24ea:	eb 81       	ldd	r30, Y+3	; 0x03
    24ec:	fc 81       	ldd	r31, Y+4	; 0x04
    24ee:	80 81       	ld	r24, Z
    24f0:	91 81       	ldd	r25, Z+1	; 0x01
    24f2:	28 17       	cp	r18, r24
    24f4:	39 07       	cpc	r19, r25
    24f6:	90 f4       	brcc	.+36     	; 0x251c <prvCopyDataToQueue+0x140>
		{
			pxQueue->u.xQueue.pcReadFrom = ( pxQueue->u.xQueue.pcTail - pxQueue->uxItemSize );
    24f8:	eb 81       	ldd	r30, Y+3	; 0x03
    24fa:	fc 81       	ldd	r31, Y+4	; 0x04
    24fc:	24 81       	ldd	r18, Z+4	; 0x04
    24fe:	35 81       	ldd	r19, Z+5	; 0x05
    2500:	eb 81       	ldd	r30, Y+3	; 0x03
    2502:	fc 81       	ldd	r31, Y+4	; 0x04
    2504:	84 8d       	ldd	r24, Z+28	; 0x1c
    2506:	88 2f       	mov	r24, r24
    2508:	90 e0       	ldi	r25, 0x00	; 0
    250a:	90 95       	com	r25
    250c:	81 95       	neg	r24
    250e:	9f 4f       	sbci	r25, 0xFF	; 255
    2510:	82 0f       	add	r24, r18
    2512:	93 1f       	adc	r25, r19
    2514:	eb 81       	ldd	r30, Y+3	; 0x03
    2516:	fc 81       	ldd	r31, Y+4	; 0x04
    2518:	97 83       	std	Z+7, r25	; 0x07
    251a:	86 83       	std	Z+6, r24	; 0x06
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}

		if( xPosition == queueOVERWRITE )
    251c:	8f 81       	ldd	r24, Y+7	; 0x07
    251e:	82 30       	cpi	r24, 0x02	; 2
    2520:	31 f4       	brne	.+12     	; 0x252e <prvCopyDataToQueue+0x152>
		{
			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
    2522:	89 81       	ldd	r24, Y+1	; 0x01
    2524:	88 23       	and	r24, r24
    2526:	19 f0       	breq	.+6      	; 0x252e <prvCopyDataToQueue+0x152>
			{
				/* An item is not being added but overwritten, so subtract
				one from the recorded number of items in the queue so when
				one is added again below the number of recorded items remains
				correct. */
				--uxMessagesWaiting;
    2528:	89 81       	ldd	r24, Y+1	; 0x01
    252a:	81 50       	subi	r24, 0x01	; 1
    252c:	89 83       	std	Y+1, r24	; 0x01
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}

	pxQueue->uxMessagesWaiting = uxMessagesWaiting + ( UBaseType_t ) 1;
    252e:	89 81       	ldd	r24, Y+1	; 0x01
    2530:	8f 5f       	subi	r24, 0xFF	; 255
    2532:	eb 81       	ldd	r30, Y+3	; 0x03
    2534:	fc 81       	ldd	r31, Y+4	; 0x04
    2536:	82 8f       	std	Z+26, r24	; 0x1a

	return xReturn;
    2538:	8a 81       	ldd	r24, Y+2	; 0x02
}
    253a:	27 96       	adiw	r28, 0x07	; 7
    253c:	0f b6       	in	r0, 0x3f	; 63
    253e:	f8 94       	cli
    2540:	de bf       	out	0x3e, r29	; 62
    2542:	0f be       	out	0x3f, r0	; 63
    2544:	cd bf       	out	0x3d, r28	; 61
    2546:	cf 91       	pop	r28
    2548:	df 91       	pop	r29
    254a:	08 95       	ret

0000254c <prvCopyDataFromQueue>:
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( Queue_t * const pxQueue, void * const pvBuffer )
{
    254c:	df 93       	push	r29
    254e:	cf 93       	push	r28
    2550:	00 d0       	rcall	.+0      	; 0x2552 <prvCopyDataFromQueue+0x6>
    2552:	00 d0       	rcall	.+0      	; 0x2554 <prvCopyDataFromQueue+0x8>
    2554:	cd b7       	in	r28, 0x3d	; 61
    2556:	de b7       	in	r29, 0x3e	; 62
    2558:	9a 83       	std	Y+2, r25	; 0x02
    255a:	89 83       	std	Y+1, r24	; 0x01
    255c:	7c 83       	std	Y+4, r23	; 0x04
    255e:	6b 83       	std	Y+3, r22	; 0x03
	if( pxQueue->uxItemSize != ( UBaseType_t ) 0 )
    2560:	e9 81       	ldd	r30, Y+1	; 0x01
    2562:	fa 81       	ldd	r31, Y+2	; 0x02
    2564:	84 8d       	ldd	r24, Z+28	; 0x1c
    2566:	88 23       	and	r24, r24
    2568:	89 f1       	breq	.+98     	; 0x25cc <prvCopyDataFromQueue+0x80>
	{
		pxQueue->u.xQueue.pcReadFrom += pxQueue->uxItemSize; /*lint !e9016 Pointer arithmetic on char types ok, especially in this use case where it is the clearest way of conveying intent. */
    256a:	e9 81       	ldd	r30, Y+1	; 0x01
    256c:	fa 81       	ldd	r31, Y+2	; 0x02
    256e:	26 81       	ldd	r18, Z+6	; 0x06
    2570:	37 81       	ldd	r19, Z+7	; 0x07
    2572:	e9 81       	ldd	r30, Y+1	; 0x01
    2574:	fa 81       	ldd	r31, Y+2	; 0x02
    2576:	84 8d       	ldd	r24, Z+28	; 0x1c
    2578:	88 2f       	mov	r24, r24
    257a:	90 e0       	ldi	r25, 0x00	; 0
    257c:	82 0f       	add	r24, r18
    257e:	93 1f       	adc	r25, r19
    2580:	e9 81       	ldd	r30, Y+1	; 0x01
    2582:	fa 81       	ldd	r31, Y+2	; 0x02
    2584:	97 83       	std	Z+7, r25	; 0x07
    2586:	86 83       	std	Z+6, r24	; 0x06
		if( pxQueue->u.xQueue.pcReadFrom >= pxQueue->u.xQueue.pcTail ) /*lint !e946 MISRA exception justified as use of the relational operator is the cleanest solutions. */
    2588:	e9 81       	ldd	r30, Y+1	; 0x01
    258a:	fa 81       	ldd	r31, Y+2	; 0x02
    258c:	26 81       	ldd	r18, Z+6	; 0x06
    258e:	37 81       	ldd	r19, Z+7	; 0x07
    2590:	e9 81       	ldd	r30, Y+1	; 0x01
    2592:	fa 81       	ldd	r31, Y+2	; 0x02
    2594:	84 81       	ldd	r24, Z+4	; 0x04
    2596:	95 81       	ldd	r25, Z+5	; 0x05
    2598:	28 17       	cp	r18, r24
    259a:	39 07       	cpc	r19, r25
    259c:	40 f0       	brcs	.+16     	; 0x25ae <prvCopyDataFromQueue+0x62>
		{
			pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead;
    259e:	e9 81       	ldd	r30, Y+1	; 0x01
    25a0:	fa 81       	ldd	r31, Y+2	; 0x02
    25a2:	80 81       	ld	r24, Z
    25a4:	91 81       	ldd	r25, Z+1	; 0x01
    25a6:	e9 81       	ldd	r30, Y+1	; 0x01
    25a8:	fa 81       	ldd	r31, Y+2	; 0x02
    25aa:	97 83       	std	Z+7, r25	; 0x07
    25ac:	86 83       	std	Z+6, r24	; 0x06
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
		( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.xQueue.pcReadFrom, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 !e9087 MISRA exception as the casts are only redundant for some ports.  Also previous logic ensures a null pointer can only be passed to memcpy() when the count is 0.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes. */
    25ae:	e9 81       	ldd	r30, Y+1	; 0x01
    25b0:	fa 81       	ldd	r31, Y+2	; 0x02
    25b2:	46 81       	ldd	r20, Z+6	; 0x06
    25b4:	57 81       	ldd	r21, Z+7	; 0x07
    25b6:	e9 81       	ldd	r30, Y+1	; 0x01
    25b8:	fa 81       	ldd	r31, Y+2	; 0x02
    25ba:	84 8d       	ldd	r24, Z+28	; 0x1c
    25bc:	28 2f       	mov	r18, r24
    25be:	30 e0       	ldi	r19, 0x00	; 0
    25c0:	8b 81       	ldd	r24, Y+3	; 0x03
    25c2:	9c 81       	ldd	r25, Y+4	; 0x04
    25c4:	ba 01       	movw	r22, r20
    25c6:	a9 01       	movw	r20, r18
    25c8:	0e 94 2f 2a 	call	0x545e	; 0x545e <memcpy>
	}
}
    25cc:	0f 90       	pop	r0
    25ce:	0f 90       	pop	r0
    25d0:	0f 90       	pop	r0
    25d2:	0f 90       	pop	r0
    25d4:	cf 91       	pop	r28
    25d6:	df 91       	pop	r29
    25d8:	08 95       	ret

000025da <prvUnlockQueue>:
/*-----------------------------------------------------------*/

static void prvUnlockQueue( Queue_t * const pxQueue )
{
    25da:	df 93       	push	r29
    25dc:	cf 93       	push	r28
    25de:	00 d0       	rcall	.+0      	; 0x25e0 <prvUnlockQueue+0x6>
    25e0:	00 d0       	rcall	.+0      	; 0x25e2 <prvUnlockQueue+0x8>
    25e2:	cd b7       	in	r28, 0x3d	; 61
    25e4:	de b7       	in	r29, 0x3e	; 62
    25e6:	9c 83       	std	Y+4, r25	; 0x04
    25e8:	8b 83       	std	Y+3, r24	; 0x03

	/* The lock counts contains the number of extra data items placed or
	removed from the queue while the queue was locked.  When a queue is
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
    25ea:	0f b6       	in	r0, 0x3f	; 63
    25ec:	f8 94       	cli
    25ee:	0f 92       	push	r0
	{
		int8_t cTxLock = pxQueue->cTxLock;
    25f0:	eb 81       	ldd	r30, Y+3	; 0x03
    25f2:	fc 81       	ldd	r31, Y+4	; 0x04
    25f4:	86 8d       	ldd	r24, Z+30	; 0x1e
    25f6:	8a 83       	std	Y+2, r24	; 0x02
    25f8:	11 c0       	rjmp	.+34     	; 0x261c <prvUnlockQueue+0x42>
			}
			#else /* configUSE_QUEUE_SETS */
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    25fa:	eb 81       	ldd	r30, Y+3	; 0x03
    25fc:	fc 81       	ldd	r31, Y+4	; 0x04
    25fe:	81 89       	ldd	r24, Z+17	; 0x11
    2600:	88 23       	and	r24, r24
    2602:	79 f0       	breq	.+30     	; 0x2622 <prvUnlockQueue+0x48>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    2604:	8b 81       	ldd	r24, Y+3	; 0x03
    2606:	9c 81       	ldd	r25, Y+4	; 0x04
    2608:	41 96       	adiw	r24, 0x11	; 17
    260a:	0e 94 e4 21 	call	0x43c8	; 0x43c8 <xTaskRemoveFromEventList>
    260e:	88 23       	and	r24, r24
    2610:	11 f0       	breq	.+4      	; 0x2616 <prvUnlockQueue+0x3c>
					{
						/* The task waiting has a higher priority so record that
						a context switch is required. */
						vTaskMissedYield();
    2612:	0e 94 50 23 	call	0x46a0	; 0x46a0 <vTaskMissedYield>
					break;
				}
			}
			#endif /* configUSE_QUEUE_SETS */

			--cTxLock;
    2616:	8a 81       	ldd	r24, Y+2	; 0x02
    2618:	81 50       	subi	r24, 0x01	; 1
    261a:	8a 83       	std	Y+2, r24	; 0x02
	taskENTER_CRITICAL();
	{
		int8_t cTxLock = pxQueue->cTxLock;

		/* See if data was added to the queue while it was locked. */
		while( cTxLock > queueLOCKED_UNMODIFIED )
    261c:	8a 81       	ldd	r24, Y+2	; 0x02
    261e:	18 16       	cp	r1, r24
    2620:	64 f3       	brlt	.-40     	; 0x25fa <prvUnlockQueue+0x20>
			#endif /* configUSE_QUEUE_SETS */

			--cTxLock;
		}

		pxQueue->cTxLock = queueUNLOCKED;
    2622:	eb 81       	ldd	r30, Y+3	; 0x03
    2624:	fc 81       	ldd	r31, Y+4	; 0x04
    2626:	8f ef       	ldi	r24, 0xFF	; 255
    2628:	86 8f       	std	Z+30, r24	; 0x1e
	}
	taskEXIT_CRITICAL();
    262a:	0f 90       	pop	r0
    262c:	0f be       	out	0x3f, r0	; 63

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
    262e:	0f b6       	in	r0, 0x3f	; 63
    2630:	f8 94       	cli
    2632:	0f 92       	push	r0
	{
		int8_t cRxLock = pxQueue->cRxLock;
    2634:	eb 81       	ldd	r30, Y+3	; 0x03
    2636:	fc 81       	ldd	r31, Y+4	; 0x04
    2638:	85 8d       	ldd	r24, Z+29	; 0x1d
    263a:	89 83       	std	Y+1, r24	; 0x01
    263c:	11 c0       	rjmp	.+34     	; 0x2660 <prvUnlockQueue+0x86>

		while( cRxLock > queueLOCKED_UNMODIFIED )
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    263e:	eb 81       	ldd	r30, Y+3	; 0x03
    2640:	fc 81       	ldd	r31, Y+4	; 0x04
    2642:	80 85       	ldd	r24, Z+8	; 0x08
    2644:	88 23       	and	r24, r24
    2646:	79 f0       	breq	.+30     	; 0x2666 <prvUnlockQueue+0x8c>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    2648:	8b 81       	ldd	r24, Y+3	; 0x03
    264a:	9c 81       	ldd	r25, Y+4	; 0x04
    264c:	08 96       	adiw	r24, 0x08	; 8
    264e:	0e 94 e4 21 	call	0x43c8	; 0x43c8 <xTaskRemoveFromEventList>
    2652:	88 23       	and	r24, r24
    2654:	11 f0       	breq	.+4      	; 0x265a <prvUnlockQueue+0x80>
				{
					vTaskMissedYield();
    2656:	0e 94 50 23 	call	0x46a0	; 0x46a0 <vTaskMissedYield>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				--cRxLock;
    265a:	89 81       	ldd	r24, Y+1	; 0x01
    265c:	81 50       	subi	r24, 0x01	; 1
    265e:	89 83       	std	Y+1, r24	; 0x01
	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		int8_t cRxLock = pxQueue->cRxLock;

		while( cRxLock > queueLOCKED_UNMODIFIED )
    2660:	89 81       	ldd	r24, Y+1	; 0x01
    2662:	18 16       	cp	r1, r24
    2664:	64 f3       	brlt	.-40     	; 0x263e <prvUnlockQueue+0x64>
			{
				break;
			}
		}

		pxQueue->cRxLock = queueUNLOCKED;
    2666:	eb 81       	ldd	r30, Y+3	; 0x03
    2668:	fc 81       	ldd	r31, Y+4	; 0x04
    266a:	8f ef       	ldi	r24, 0xFF	; 255
    266c:	85 8f       	std	Z+29, r24	; 0x1d
	}
	taskEXIT_CRITICAL();
    266e:	0f 90       	pop	r0
    2670:	0f be       	out	0x3f, r0	; 63
}
    2672:	0f 90       	pop	r0
    2674:	0f 90       	pop	r0
    2676:	0f 90       	pop	r0
    2678:	0f 90       	pop	r0
    267a:	cf 91       	pop	r28
    267c:	df 91       	pop	r29
    267e:	08 95       	ret

00002680 <prvIsQueueEmpty>:
/*-----------------------------------------------------------*/

static BaseType_t prvIsQueueEmpty( const Queue_t *pxQueue )
{
    2680:	df 93       	push	r29
    2682:	cf 93       	push	r28
    2684:	00 d0       	rcall	.+0      	; 0x2686 <prvIsQueueEmpty+0x6>
    2686:	0f 92       	push	r0
    2688:	cd b7       	in	r28, 0x3d	; 61
    268a:	de b7       	in	r29, 0x3e	; 62
    268c:	9b 83       	std	Y+3, r25	; 0x03
    268e:	8a 83       	std	Y+2, r24	; 0x02
BaseType_t xReturn;

	taskENTER_CRITICAL();
    2690:	0f b6       	in	r0, 0x3f	; 63
    2692:	f8 94       	cli
    2694:	0f 92       	push	r0
	{
		if( pxQueue->uxMessagesWaiting == ( UBaseType_t )  0 )
    2696:	ea 81       	ldd	r30, Y+2	; 0x02
    2698:	fb 81       	ldd	r31, Y+3	; 0x03
    269a:	82 8d       	ldd	r24, Z+26	; 0x1a
    269c:	88 23       	and	r24, r24
    269e:	19 f4       	brne	.+6      	; 0x26a6 <prvIsQueueEmpty+0x26>
		{
			xReturn = pdTRUE;
    26a0:	81 e0       	ldi	r24, 0x01	; 1
    26a2:	89 83       	std	Y+1, r24	; 0x01
    26a4:	01 c0       	rjmp	.+2      	; 0x26a8 <prvIsQueueEmpty+0x28>
		}
		else
		{
			xReturn = pdFALSE;
    26a6:	19 82       	std	Y+1, r1	; 0x01
		}
	}
	taskEXIT_CRITICAL();
    26a8:	0f 90       	pop	r0
    26aa:	0f be       	out	0x3f, r0	; 63

	return xReturn;
    26ac:	89 81       	ldd	r24, Y+1	; 0x01
}
    26ae:	0f 90       	pop	r0
    26b0:	0f 90       	pop	r0
    26b2:	0f 90       	pop	r0
    26b4:	cf 91       	pop	r28
    26b6:	df 91       	pop	r29
    26b8:	08 95       	ret

000026ba <xQueueIsQueueEmptyFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueIsQueueEmptyFromISR( const QueueHandle_t xQueue )
{
    26ba:	df 93       	push	r29
    26bc:	cf 93       	push	r28
    26be:	00 d0       	rcall	.+0      	; 0x26c0 <xQueueIsQueueEmptyFromISR+0x6>
    26c0:	00 d0       	rcall	.+0      	; 0x26c2 <xQueueIsQueueEmptyFromISR+0x8>
    26c2:	0f 92       	push	r0
    26c4:	cd b7       	in	r28, 0x3d	; 61
    26c6:	de b7       	in	r29, 0x3e	; 62
    26c8:	9d 83       	std	Y+5, r25	; 0x05
    26ca:	8c 83       	std	Y+4, r24	; 0x04
BaseType_t xReturn;
Queue_t * const pxQueue = xQueue;
    26cc:	8c 81       	ldd	r24, Y+4	; 0x04
    26ce:	9d 81       	ldd	r25, Y+5	; 0x05
    26d0:	9a 83       	std	Y+2, r25	; 0x02
    26d2:	89 83       	std	Y+1, r24	; 0x01

	configASSERT( pxQueue );
	if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0 )
    26d4:	e9 81       	ldd	r30, Y+1	; 0x01
    26d6:	fa 81       	ldd	r31, Y+2	; 0x02
    26d8:	82 8d       	ldd	r24, Z+26	; 0x1a
    26da:	88 23       	and	r24, r24
    26dc:	19 f4       	brne	.+6      	; 0x26e4 <xQueueIsQueueEmptyFromISR+0x2a>
	{
		xReturn = pdTRUE;
    26de:	81 e0       	ldi	r24, 0x01	; 1
    26e0:	8b 83       	std	Y+3, r24	; 0x03
    26e2:	01 c0       	rjmp	.+2      	; 0x26e6 <xQueueIsQueueEmptyFromISR+0x2c>
	}
	else
	{
		xReturn = pdFALSE;
    26e4:	1b 82       	std	Y+3, r1	; 0x03
	}

	return xReturn;
    26e6:	8b 81       	ldd	r24, Y+3	; 0x03
} /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
    26e8:	0f 90       	pop	r0
    26ea:	0f 90       	pop	r0
    26ec:	0f 90       	pop	r0
    26ee:	0f 90       	pop	r0
    26f0:	0f 90       	pop	r0
    26f2:	cf 91       	pop	r28
    26f4:	df 91       	pop	r29
    26f6:	08 95       	ret

000026f8 <prvIsQueueFull>:
/*-----------------------------------------------------------*/

static BaseType_t prvIsQueueFull( const Queue_t *pxQueue )
{
    26f8:	df 93       	push	r29
    26fa:	cf 93       	push	r28
    26fc:	00 d0       	rcall	.+0      	; 0x26fe <prvIsQueueFull+0x6>
    26fe:	0f 92       	push	r0
    2700:	cd b7       	in	r28, 0x3d	; 61
    2702:	de b7       	in	r29, 0x3e	; 62
    2704:	9b 83       	std	Y+3, r25	; 0x03
    2706:	8a 83       	std	Y+2, r24	; 0x02
BaseType_t xReturn;

	taskENTER_CRITICAL();
    2708:	0f b6       	in	r0, 0x3f	; 63
    270a:	f8 94       	cli
    270c:	0f 92       	push	r0
	{
		if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
    270e:	ea 81       	ldd	r30, Y+2	; 0x02
    2710:	fb 81       	ldd	r31, Y+3	; 0x03
    2712:	92 8d       	ldd	r25, Z+26	; 0x1a
    2714:	ea 81       	ldd	r30, Y+2	; 0x02
    2716:	fb 81       	ldd	r31, Y+3	; 0x03
    2718:	83 8d       	ldd	r24, Z+27	; 0x1b
    271a:	98 17       	cp	r25, r24
    271c:	19 f4       	brne	.+6      	; 0x2724 <prvIsQueueFull+0x2c>
		{
			xReturn = pdTRUE;
    271e:	81 e0       	ldi	r24, 0x01	; 1
    2720:	89 83       	std	Y+1, r24	; 0x01
    2722:	01 c0       	rjmp	.+2      	; 0x2726 <prvIsQueueFull+0x2e>
		}
		else
		{
			xReturn = pdFALSE;
    2724:	19 82       	std	Y+1, r1	; 0x01
		}
	}
	taskEXIT_CRITICAL();
    2726:	0f 90       	pop	r0
    2728:	0f be       	out	0x3f, r0	; 63

	return xReturn;
    272a:	89 81       	ldd	r24, Y+1	; 0x01
}
    272c:	0f 90       	pop	r0
    272e:	0f 90       	pop	r0
    2730:	0f 90       	pop	r0
    2732:	cf 91       	pop	r28
    2734:	df 91       	pop	r29
    2736:	08 95       	ret

00002738 <xQueueIsQueueFullFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueIsQueueFullFromISR( const QueueHandle_t xQueue )
{
    2738:	df 93       	push	r29
    273a:	cf 93       	push	r28
    273c:	00 d0       	rcall	.+0      	; 0x273e <xQueueIsQueueFullFromISR+0x6>
    273e:	00 d0       	rcall	.+0      	; 0x2740 <xQueueIsQueueFullFromISR+0x8>
    2740:	0f 92       	push	r0
    2742:	cd b7       	in	r28, 0x3d	; 61
    2744:	de b7       	in	r29, 0x3e	; 62
    2746:	9d 83       	std	Y+5, r25	; 0x05
    2748:	8c 83       	std	Y+4, r24	; 0x04
BaseType_t xReturn;
Queue_t * const pxQueue = xQueue;
    274a:	8c 81       	ldd	r24, Y+4	; 0x04
    274c:	9d 81       	ldd	r25, Y+5	; 0x05
    274e:	9a 83       	std	Y+2, r25	; 0x02
    2750:	89 83       	std	Y+1, r24	; 0x01

	configASSERT( pxQueue );
	if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
    2752:	e9 81       	ldd	r30, Y+1	; 0x01
    2754:	fa 81       	ldd	r31, Y+2	; 0x02
    2756:	92 8d       	ldd	r25, Z+26	; 0x1a
    2758:	e9 81       	ldd	r30, Y+1	; 0x01
    275a:	fa 81       	ldd	r31, Y+2	; 0x02
    275c:	83 8d       	ldd	r24, Z+27	; 0x1b
    275e:	98 17       	cp	r25, r24
    2760:	19 f4       	brne	.+6      	; 0x2768 <xQueueIsQueueFullFromISR+0x30>
	{
		xReturn = pdTRUE;
    2762:	81 e0       	ldi	r24, 0x01	; 1
    2764:	8b 83       	std	Y+3, r24	; 0x03
    2766:	01 c0       	rjmp	.+2      	; 0x276a <xQueueIsQueueFullFromISR+0x32>
	}
	else
	{
		xReturn = pdFALSE;
    2768:	1b 82       	std	Y+3, r1	; 0x03
	}

	return xReturn;
    276a:	8b 81       	ldd	r24, Y+3	; 0x03
} /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
    276c:	0f 90       	pop	r0
    276e:	0f 90       	pop	r0
    2770:	0f 90       	pop	r0
    2772:	0f 90       	pop	r0
    2774:	0f 90       	pop	r0
    2776:	cf 91       	pop	r28
    2778:	df 91       	pop	r29
    277a:	08 95       	ret

0000277c <xStreamBufferGenericCreate>:
/*-----------------------------------------------------------*/

#if( configSUPPORT_DYNAMIC_ALLOCATION == 1 )

	StreamBufferHandle_t xStreamBufferGenericCreate( size_t xBufferSizeBytes, size_t xTriggerLevelBytes, BaseType_t xIsMessageBuffer )
	{
    277c:	0f 93       	push	r16
    277e:	df 93       	push	r29
    2780:	cf 93       	push	r28
    2782:	cd b7       	in	r28, 0x3d	; 61
    2784:	de b7       	in	r29, 0x3e	; 62
    2786:	28 97       	sbiw	r28, 0x08	; 8
    2788:	0f b6       	in	r0, 0x3f	; 63
    278a:	f8 94       	cli
    278c:	de bf       	out	0x3e, r29	; 62
    278e:	0f be       	out	0x3f, r0	; 63
    2790:	cd bf       	out	0x3d, r28	; 61
    2792:	9d 83       	std	Y+5, r25	; 0x05
    2794:	8c 83       	std	Y+4, r24	; 0x04
    2796:	7f 83       	std	Y+7, r23	; 0x07
    2798:	6e 83       	std	Y+6, r22	; 0x06
    279a:	48 87       	std	Y+8, r20	; 0x08

		/* In case the stream buffer is going to be used as a message buffer
		(that is, it will hold discrete messages with a little meta data that
		says how big the next message is) check the buffer will be large enough
		to hold at least one message. */
		if( xIsMessageBuffer == pdTRUE )
    279c:	88 85       	ldd	r24, Y+8	; 0x08
    279e:	81 30       	cpi	r24, 0x01	; 1
    27a0:	19 f4       	brne	.+6      	; 0x27a8 <xStreamBufferGenericCreate+0x2c>
		{
			/* Is a message buffer but not statically allocated. */
			ucFlags = sbFLAGS_IS_MESSAGE_BUFFER;
    27a2:	81 e0       	ldi	r24, 0x01	; 1
    27a4:	89 83       	std	Y+1, r24	; 0x01
    27a6:	01 c0       	rjmp	.+2      	; 0x27aa <xStreamBufferGenericCreate+0x2e>
			configASSERT( xBufferSizeBytes > sbBYTES_TO_STORE_MESSAGE_LENGTH );
		}
		else
		{
			/* Not a message buffer and not statically allocated. */
			ucFlags = 0;
    27a8:	19 82       	std	Y+1, r1	; 0x01
		}
		configASSERT( xTriggerLevelBytes <= xBufferSizeBytes );

		/* A trigger level of 0 would cause a waiting task to unblock even when
		the buffer was empty. */
		if( xTriggerLevelBytes == ( size_t ) 0 )
    27aa:	8e 81       	ldd	r24, Y+6	; 0x06
    27ac:	9f 81       	ldd	r25, Y+7	; 0x07
    27ae:	00 97       	sbiw	r24, 0x00	; 0
    27b0:	21 f4       	brne	.+8      	; 0x27ba <xStreamBufferGenericCreate+0x3e>
		{
			xTriggerLevelBytes = ( size_t ) 1;
    27b2:	81 e0       	ldi	r24, 0x01	; 1
    27b4:	90 e0       	ldi	r25, 0x00	; 0
    27b6:	9f 83       	std	Y+7, r25	; 0x07
    27b8:	8e 83       	std	Y+6, r24	; 0x06
		and the buffer follows immediately after.  The requested size is
		incremented so the free space is returned as the user would expect -
		this is a quirk of the implementation that means otherwise the free
		space would be reported as one byte smaller than would be logically
		expected. */
		xBufferSizeBytes++;
    27ba:	8c 81       	ldd	r24, Y+4	; 0x04
    27bc:	9d 81       	ldd	r25, Y+5	; 0x05
    27be:	01 96       	adiw	r24, 0x01	; 1
    27c0:	9d 83       	std	Y+5, r25	; 0x05
    27c2:	8c 83       	std	Y+4, r24	; 0x04
		pucAllocatedMemory = ( uint8_t * ) pvPortMalloc( xBufferSizeBytes + sizeof( StreamBuffer_t ) ); /*lint !e9079 malloc() only returns void*. */
    27c4:	8c 81       	ldd	r24, Y+4	; 0x04
    27c6:	9d 81       	ldd	r25, Y+5	; 0x05
    27c8:	0f 96       	adiw	r24, 0x0f	; 15
    27ca:	0e 94 2a 06 	call	0xc54	; 0xc54 <pvPortMalloc>
    27ce:	9b 83       	std	Y+3, r25	; 0x03
    27d0:	8a 83       	std	Y+2, r24	; 0x02

		if( pucAllocatedMemory != NULL )
    27d2:	8a 81       	ldd	r24, Y+2	; 0x02
    27d4:	9b 81       	ldd	r25, Y+3	; 0x03
    27d6:	00 97       	sbiw	r24, 0x00	; 0
    27d8:	89 f0       	breq	.+34     	; 0x27fc <xStreamBufferGenericCreate+0x80>
		{
			prvInitialiseNewStreamBuffer( ( StreamBuffer_t * ) pucAllocatedMemory, /* Structure at the start of the allocated memory. */ /*lint !e9087 Safe cast as allocated memory is aligned. */ /*lint !e826 Area is not too small and alignment is guaranteed provided malloc() behaves as expected and returns aligned buffer. */
    27da:	6a 81       	ldd	r22, Y+2	; 0x02
    27dc:	7b 81       	ldd	r23, Y+3	; 0x03
    27de:	8a 81       	ldd	r24, Y+2	; 0x02
    27e0:	9b 81       	ldd	r25, Y+3	; 0x03
    27e2:	9c 01       	movw	r18, r24
    27e4:	21 5f       	subi	r18, 0xF1	; 241
    27e6:	3f 4f       	sbci	r19, 0xFF	; 255
    27e8:	4c 81       	ldd	r20, Y+4	; 0x04
    27ea:	5d 81       	ldd	r21, Y+5	; 0x05
    27ec:	ee 81       	ldd	r30, Y+6	; 0x06
    27ee:	ff 81       	ldd	r31, Y+7	; 0x07
    27f0:	cb 01       	movw	r24, r22
    27f2:	b9 01       	movw	r22, r18
    27f4:	9f 01       	movw	r18, r30
    27f6:	09 81       	ldd	r16, Y+1	; 0x01
    27f8:	0e 94 16 1b 	call	0x362c	; 0x362c <prvInitialiseNewStreamBuffer>
		else
		{
			traceSTREAM_BUFFER_CREATE_FAILED( xIsMessageBuffer );
		}

		return ( StreamBufferHandle_t ) pucAllocatedMemory; /*lint !e9087 !e826 Safe cast as allocated memory is aligned. */
    27fc:	8a 81       	ldd	r24, Y+2	; 0x02
    27fe:	9b 81       	ldd	r25, Y+3	; 0x03
	}
    2800:	28 96       	adiw	r28, 0x08	; 8
    2802:	0f b6       	in	r0, 0x3f	; 63
    2804:	f8 94       	cli
    2806:	de bf       	out	0x3e, r29	; 62
    2808:	0f be       	out	0x3f, r0	; 63
    280a:	cd bf       	out	0x3d, r28	; 61
    280c:	cf 91       	pop	r28
    280e:	df 91       	pop	r29
    2810:	0f 91       	pop	r16
    2812:	08 95       	ret

00002814 <vStreamBufferDelete>:

#endif /* ( configSUPPORT_STATIC_ALLOCATION == 1 ) */
/*-----------------------------------------------------------*/

void vStreamBufferDelete( StreamBufferHandle_t xStreamBuffer )
{
    2814:	df 93       	push	r29
    2816:	cf 93       	push	r28
    2818:	00 d0       	rcall	.+0      	; 0x281a <vStreamBufferDelete+0x6>
    281a:	00 d0       	rcall	.+0      	; 0x281c <vStreamBufferDelete+0x8>
    281c:	cd b7       	in	r28, 0x3d	; 61
    281e:	de b7       	in	r29, 0x3e	; 62
    2820:	9c 83       	std	Y+4, r25	; 0x04
    2822:	8b 83       	std	Y+3, r24	; 0x03
StreamBuffer_t * pxStreamBuffer = xStreamBuffer;
    2824:	8b 81       	ldd	r24, Y+3	; 0x03
    2826:	9c 81       	ldd	r25, Y+4	; 0x04
    2828:	9a 83       	std	Y+2, r25	; 0x02
    282a:	89 83       	std	Y+1, r24	; 0x01

	configASSERT( pxStreamBuffer );

	traceSTREAM_BUFFER_DELETE( xStreamBuffer );

	if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_STATICALLY_ALLOCATED ) == ( uint8_t ) pdFALSE )
    282c:	e9 81       	ldd	r30, Y+1	; 0x01
    282e:	fa 81       	ldd	r31, Y+2	; 0x02
    2830:	86 85       	ldd	r24, Z+14	; 0x0e
    2832:	88 2f       	mov	r24, r24
    2834:	90 e0       	ldi	r25, 0x00	; 0
    2836:	82 70       	andi	r24, 0x02	; 2
    2838:	90 70       	andi	r25, 0x00	; 0
    283a:	00 97       	sbiw	r24, 0x00	; 0
    283c:	29 f4       	brne	.+10     	; 0x2848 <vStreamBufferDelete+0x34>
	{
		#if( configSUPPORT_DYNAMIC_ALLOCATION == 1 )
		{
			/* Both the structure and the buffer were allocated using a single call
			to pvPortMalloc(), hence only one call to vPortFree() is required. */
			vPortFree( ( void * ) pxStreamBuffer ); /*lint !e9087 Standard free() semantics require void *, plus pxStreamBuffer was allocated by pvPortMalloc(). */
    283e:	89 81       	ldd	r24, Y+1	; 0x01
    2840:	9a 81       	ldd	r25, Y+2	; 0x02
    2842:	0e 94 80 06 	call	0xd00	; 0xd00 <vPortFree>
    2846:	08 c0       	rjmp	.+16     	; 0x2858 <vStreamBufferDelete+0x44>
	}
	else
	{
		/* The structure and buffer were not allocated dynamically and cannot be
		freed - just scrub the structure so future use will assert. */
		( void ) memset( pxStreamBuffer, 0x00, sizeof( StreamBuffer_t ) );
    2848:	89 81       	ldd	r24, Y+1	; 0x01
    284a:	9a 81       	ldd	r25, Y+2	; 0x02
    284c:	60 e0       	ldi	r22, 0x00	; 0
    284e:	70 e0       	ldi	r23, 0x00	; 0
    2850:	4f e0       	ldi	r20, 0x0F	; 15
    2852:	50 e0       	ldi	r21, 0x00	; 0
    2854:	0e 94 38 2a 	call	0x5470	; 0x5470 <memset>
	}
}
    2858:	0f 90       	pop	r0
    285a:	0f 90       	pop	r0
    285c:	0f 90       	pop	r0
    285e:	0f 90       	pop	r0
    2860:	cf 91       	pop	r28
    2862:	df 91       	pop	r29
    2864:	08 95       	ret

00002866 <xStreamBufferReset>:
/*-----------------------------------------------------------*/

BaseType_t xStreamBufferReset( StreamBufferHandle_t xStreamBuffer )
{
    2866:	0f 93       	push	r16
    2868:	df 93       	push	r29
    286a:	cf 93       	push	r28
    286c:	00 d0       	rcall	.+0      	; 0x286e <xStreamBufferReset+0x8>
    286e:	00 d0       	rcall	.+0      	; 0x2870 <xStreamBufferReset+0xa>
    2870:	0f 92       	push	r0
    2872:	cd b7       	in	r28, 0x3d	; 61
    2874:	de b7       	in	r29, 0x3e	; 62
    2876:	9d 83       	std	Y+5, r25	; 0x05
    2878:	8c 83       	std	Y+4, r24	; 0x04
StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
    287a:	8c 81       	ldd	r24, Y+4	; 0x04
    287c:	9d 81       	ldd	r25, Y+5	; 0x05
    287e:	9b 83       	std	Y+3, r25	; 0x03
    2880:	8a 83       	std	Y+2, r24	; 0x02
BaseType_t xReturn = pdFAIL;
    2882:	19 82       	std	Y+1, r1	; 0x01
		uxStreamBufferNumber = pxStreamBuffer->uxStreamBufferNumber;
	}
	#endif

	/* Can only reset a message buffer if there are no tasks blocked on it. */
	taskENTER_CRITICAL();
    2884:	0f b6       	in	r0, 0x3f	; 63
    2886:	f8 94       	cli
    2888:	0f 92       	push	r0
	{
		if( pxStreamBuffer->xTaskWaitingToReceive == NULL )
    288a:	ea 81       	ldd	r30, Y+2	; 0x02
    288c:	fb 81       	ldd	r31, Y+3	; 0x03
    288e:	80 85       	ldd	r24, Z+8	; 0x08
    2890:	91 85       	ldd	r25, Z+9	; 0x09
    2892:	00 97       	sbiw	r24, 0x00	; 0
    2894:	f1 f4       	brne	.+60     	; 0x28d2 <xStreamBufferReset+0x6c>
		{
			if( pxStreamBuffer->xTaskWaitingToSend == NULL )
    2896:	ea 81       	ldd	r30, Y+2	; 0x02
    2898:	fb 81       	ldd	r31, Y+3	; 0x03
    289a:	82 85       	ldd	r24, Z+10	; 0x0a
    289c:	93 85       	ldd	r25, Z+11	; 0x0b
    289e:	00 97       	sbiw	r24, 0x00	; 0
    28a0:	c1 f4       	brne	.+48     	; 0x28d2 <xStreamBufferReset+0x6c>
			{
				prvInitialiseNewStreamBuffer( pxStreamBuffer,
    28a2:	ea 81       	ldd	r30, Y+2	; 0x02
    28a4:	fb 81       	ldd	r31, Y+3	; 0x03
    28a6:	24 85       	ldd	r18, Z+12	; 0x0c
    28a8:	35 85       	ldd	r19, Z+13	; 0x0d
    28aa:	ea 81       	ldd	r30, Y+2	; 0x02
    28ac:	fb 81       	ldd	r31, Y+3	; 0x03
    28ae:	44 81       	ldd	r20, Z+4	; 0x04
    28b0:	55 81       	ldd	r21, Z+5	; 0x05
    28b2:	ea 81       	ldd	r30, Y+2	; 0x02
    28b4:	fb 81       	ldd	r31, Y+3	; 0x03
    28b6:	a6 81       	ldd	r26, Z+6	; 0x06
    28b8:	b7 81       	ldd	r27, Z+7	; 0x07
    28ba:	ea 81       	ldd	r30, Y+2	; 0x02
    28bc:	fb 81       	ldd	r31, Y+3	; 0x03
    28be:	e6 85       	ldd	r30, Z+14	; 0x0e
    28c0:	8a 81       	ldd	r24, Y+2	; 0x02
    28c2:	9b 81       	ldd	r25, Y+3	; 0x03
    28c4:	b9 01       	movw	r22, r18
    28c6:	9d 01       	movw	r18, r26
    28c8:	0e 2f       	mov	r16, r30
    28ca:	0e 94 16 1b 	call	0x362c	; 0x362c <prvInitialiseNewStreamBuffer>
											  pxStreamBuffer->pucBuffer,
											  pxStreamBuffer->xLength,
											  pxStreamBuffer->xTriggerLevelBytes,
											  pxStreamBuffer->ucFlags );
				xReturn = pdPASS;
    28ce:	81 e0       	ldi	r24, 0x01	; 1
    28d0:	89 83       	std	Y+1, r24	; 0x01

				traceSTREAM_BUFFER_RESET( xStreamBuffer );
			}
		}
	}
	taskEXIT_CRITICAL();
    28d2:	0f 90       	pop	r0
    28d4:	0f be       	out	0x3f, r0	; 63

	return xReturn;
    28d6:	89 81       	ldd	r24, Y+1	; 0x01
}
    28d8:	0f 90       	pop	r0
    28da:	0f 90       	pop	r0
    28dc:	0f 90       	pop	r0
    28de:	0f 90       	pop	r0
    28e0:	0f 90       	pop	r0
    28e2:	cf 91       	pop	r28
    28e4:	df 91       	pop	r29
    28e6:	0f 91       	pop	r16
    28e8:	08 95       	ret

000028ea <xStreamBufferSetTriggerLevel>:
/*-----------------------------------------------------------*/

BaseType_t xStreamBufferSetTriggerLevel( StreamBufferHandle_t xStreamBuffer, size_t xTriggerLevel )
{
    28ea:	df 93       	push	r29
    28ec:	cf 93       	push	r28
    28ee:	cd b7       	in	r28, 0x3d	; 61
    28f0:	de b7       	in	r29, 0x3e	; 62
    28f2:	27 97       	sbiw	r28, 0x07	; 7
    28f4:	0f b6       	in	r0, 0x3f	; 63
    28f6:	f8 94       	cli
    28f8:	de bf       	out	0x3e, r29	; 62
    28fa:	0f be       	out	0x3f, r0	; 63
    28fc:	cd bf       	out	0x3d, r28	; 61
    28fe:	9d 83       	std	Y+5, r25	; 0x05
    2900:	8c 83       	std	Y+4, r24	; 0x04
    2902:	7f 83       	std	Y+7, r23	; 0x07
    2904:	6e 83       	std	Y+6, r22	; 0x06
StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
    2906:	8c 81       	ldd	r24, Y+4	; 0x04
    2908:	9d 81       	ldd	r25, Y+5	; 0x05
    290a:	9b 83       	std	Y+3, r25	; 0x03
    290c:	8a 83       	std	Y+2, r24	; 0x02
BaseType_t xReturn;

	configASSERT( pxStreamBuffer );

	/* It is not valid for the trigger level to be 0. */
	if( xTriggerLevel == ( size_t ) 0 )
    290e:	8e 81       	ldd	r24, Y+6	; 0x06
    2910:	9f 81       	ldd	r25, Y+7	; 0x07
    2912:	00 97       	sbiw	r24, 0x00	; 0
    2914:	21 f4       	brne	.+8      	; 0x291e <xStreamBufferSetTriggerLevel+0x34>
	{
		xTriggerLevel = ( size_t ) 1;
    2916:	81 e0       	ldi	r24, 0x01	; 1
    2918:	90 e0       	ldi	r25, 0x00	; 0
    291a:	9f 83       	std	Y+7, r25	; 0x07
    291c:	8e 83       	std	Y+6, r24	; 0x06
	}

	/* The trigger level is the number of bytes that must be in the stream
	buffer before a task that is waiting for data is unblocked. */
	if( xTriggerLevel <= pxStreamBuffer->xLength )
    291e:	ea 81       	ldd	r30, Y+2	; 0x02
    2920:	fb 81       	ldd	r31, Y+3	; 0x03
    2922:	24 81       	ldd	r18, Z+4	; 0x04
    2924:	35 81       	ldd	r19, Z+5	; 0x05
    2926:	8e 81       	ldd	r24, Y+6	; 0x06
    2928:	9f 81       	ldd	r25, Y+7	; 0x07
    292a:	28 17       	cp	r18, r24
    292c:	39 07       	cpc	r19, r25
    292e:	48 f0       	brcs	.+18     	; 0x2942 <xStreamBufferSetTriggerLevel+0x58>
	{
		pxStreamBuffer->xTriggerLevelBytes = xTriggerLevel;
    2930:	ea 81       	ldd	r30, Y+2	; 0x02
    2932:	fb 81       	ldd	r31, Y+3	; 0x03
    2934:	8e 81       	ldd	r24, Y+6	; 0x06
    2936:	9f 81       	ldd	r25, Y+7	; 0x07
    2938:	97 83       	std	Z+7, r25	; 0x07
    293a:	86 83       	std	Z+6, r24	; 0x06
		xReturn = pdPASS;
    293c:	81 e0       	ldi	r24, 0x01	; 1
    293e:	89 83       	std	Y+1, r24	; 0x01
    2940:	01 c0       	rjmp	.+2      	; 0x2944 <xStreamBufferSetTriggerLevel+0x5a>
	}
	else
	{
		xReturn = pdFALSE;
    2942:	19 82       	std	Y+1, r1	; 0x01
	}

	return xReturn;
    2944:	89 81       	ldd	r24, Y+1	; 0x01
}
    2946:	27 96       	adiw	r28, 0x07	; 7
    2948:	0f b6       	in	r0, 0x3f	; 63
    294a:	f8 94       	cli
    294c:	de bf       	out	0x3e, r29	; 62
    294e:	0f be       	out	0x3f, r0	; 63
    2950:	cd bf       	out	0x3d, r28	; 61
    2952:	cf 91       	pop	r28
    2954:	df 91       	pop	r29
    2956:	08 95       	ret

00002958 <xStreamBufferSpacesAvailable>:
/*-----------------------------------------------------------*/

size_t xStreamBufferSpacesAvailable( StreamBufferHandle_t xStreamBuffer )
{
    2958:	df 93       	push	r29
    295a:	cf 93       	push	r28
    295c:	00 d0       	rcall	.+0      	; 0x295e <xStreamBufferSpacesAvailable+0x6>
    295e:	00 d0       	rcall	.+0      	; 0x2960 <xStreamBufferSpacesAvailable+0x8>
    2960:	00 d0       	rcall	.+0      	; 0x2962 <xStreamBufferSpacesAvailable+0xa>
    2962:	cd b7       	in	r28, 0x3d	; 61
    2964:	de b7       	in	r29, 0x3e	; 62
    2966:	9e 83       	std	Y+6, r25	; 0x06
    2968:	8d 83       	std	Y+5, r24	; 0x05
const StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
    296a:	8d 81       	ldd	r24, Y+5	; 0x05
    296c:	9e 81       	ldd	r25, Y+6	; 0x06
    296e:	9c 83       	std	Y+4, r25	; 0x04
    2970:	8b 83       	std	Y+3, r24	; 0x03
size_t xSpace;

	configASSERT( pxStreamBuffer );

	xSpace = pxStreamBuffer->xLength + pxStreamBuffer->xTail;
    2972:	eb 81       	ldd	r30, Y+3	; 0x03
    2974:	fc 81       	ldd	r31, Y+4	; 0x04
    2976:	24 81       	ldd	r18, Z+4	; 0x04
    2978:	35 81       	ldd	r19, Z+5	; 0x05
    297a:	eb 81       	ldd	r30, Y+3	; 0x03
    297c:	fc 81       	ldd	r31, Y+4	; 0x04
    297e:	80 81       	ld	r24, Z
    2980:	91 81       	ldd	r25, Z+1	; 0x01
    2982:	82 0f       	add	r24, r18
    2984:	93 1f       	adc	r25, r19
    2986:	9a 83       	std	Y+2, r25	; 0x02
    2988:	89 83       	std	Y+1, r24	; 0x01
	xSpace -= pxStreamBuffer->xHead;
    298a:	eb 81       	ldd	r30, Y+3	; 0x03
    298c:	fc 81       	ldd	r31, Y+4	; 0x04
    298e:	22 81       	ldd	r18, Z+2	; 0x02
    2990:	33 81       	ldd	r19, Z+3	; 0x03
    2992:	89 81       	ldd	r24, Y+1	; 0x01
    2994:	9a 81       	ldd	r25, Y+2	; 0x02
    2996:	82 1b       	sub	r24, r18
    2998:	93 0b       	sbc	r25, r19
    299a:	9a 83       	std	Y+2, r25	; 0x02
    299c:	89 83       	std	Y+1, r24	; 0x01
	xSpace -= ( size_t ) 1;
    299e:	89 81       	ldd	r24, Y+1	; 0x01
    29a0:	9a 81       	ldd	r25, Y+2	; 0x02
    29a2:	01 97       	sbiw	r24, 0x01	; 1
    29a4:	9a 83       	std	Y+2, r25	; 0x02
    29a6:	89 83       	std	Y+1, r24	; 0x01

	if( xSpace >= pxStreamBuffer->xLength )
    29a8:	eb 81       	ldd	r30, Y+3	; 0x03
    29aa:	fc 81       	ldd	r31, Y+4	; 0x04
    29ac:	24 81       	ldd	r18, Z+4	; 0x04
    29ae:	35 81       	ldd	r19, Z+5	; 0x05
    29b0:	89 81       	ldd	r24, Y+1	; 0x01
    29b2:	9a 81       	ldd	r25, Y+2	; 0x02
    29b4:	82 17       	cp	r24, r18
    29b6:	93 07       	cpc	r25, r19
    29b8:	50 f0       	brcs	.+20     	; 0x29ce <xStreamBufferSpacesAvailable+0x76>
	{
		xSpace -= pxStreamBuffer->xLength;
    29ba:	eb 81       	ldd	r30, Y+3	; 0x03
    29bc:	fc 81       	ldd	r31, Y+4	; 0x04
    29be:	24 81       	ldd	r18, Z+4	; 0x04
    29c0:	35 81       	ldd	r19, Z+5	; 0x05
    29c2:	89 81       	ldd	r24, Y+1	; 0x01
    29c4:	9a 81       	ldd	r25, Y+2	; 0x02
    29c6:	82 1b       	sub	r24, r18
    29c8:	93 0b       	sbc	r25, r19
    29ca:	9a 83       	std	Y+2, r25	; 0x02
    29cc:	89 83       	std	Y+1, r24	; 0x01
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	return xSpace;
    29ce:	89 81       	ldd	r24, Y+1	; 0x01
    29d0:	9a 81       	ldd	r25, Y+2	; 0x02
}
    29d2:	26 96       	adiw	r28, 0x06	; 6
    29d4:	0f b6       	in	r0, 0x3f	; 63
    29d6:	f8 94       	cli
    29d8:	de bf       	out	0x3e, r29	; 62
    29da:	0f be       	out	0x3f, r0	; 63
    29dc:	cd bf       	out	0x3d, r28	; 61
    29de:	cf 91       	pop	r28
    29e0:	df 91       	pop	r29
    29e2:	08 95       	ret

000029e4 <xStreamBufferBytesAvailable>:
/*-----------------------------------------------------------*/

size_t xStreamBufferBytesAvailable( StreamBufferHandle_t xStreamBuffer )
{
    29e4:	df 93       	push	r29
    29e6:	cf 93       	push	r28
    29e8:	00 d0       	rcall	.+0      	; 0x29ea <xStreamBufferBytesAvailable+0x6>
    29ea:	00 d0       	rcall	.+0      	; 0x29ec <xStreamBufferBytesAvailable+0x8>
    29ec:	00 d0       	rcall	.+0      	; 0x29ee <xStreamBufferBytesAvailable+0xa>
    29ee:	cd b7       	in	r28, 0x3d	; 61
    29f0:	de b7       	in	r29, 0x3e	; 62
    29f2:	9e 83       	std	Y+6, r25	; 0x06
    29f4:	8d 83       	std	Y+5, r24	; 0x05
const StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
    29f6:	8d 81       	ldd	r24, Y+5	; 0x05
    29f8:	9e 81       	ldd	r25, Y+6	; 0x06
    29fa:	9c 83       	std	Y+4, r25	; 0x04
    29fc:	8b 83       	std	Y+3, r24	; 0x03
size_t xReturn;

	configASSERT( pxStreamBuffer );

	xReturn = prvBytesInBuffer( pxStreamBuffer );
    29fe:	8b 81       	ldd	r24, Y+3	; 0x03
    2a00:	9c 81       	ldd	r25, Y+4	; 0x04
    2a02:	0e 94 dc 1a 	call	0x35b8	; 0x35b8 <prvBytesInBuffer>
    2a06:	9a 83       	std	Y+2, r25	; 0x02
    2a08:	89 83       	std	Y+1, r24	; 0x01
	return xReturn;
    2a0a:	89 81       	ldd	r24, Y+1	; 0x01
    2a0c:	9a 81       	ldd	r25, Y+2	; 0x02
}
    2a0e:	26 96       	adiw	r28, 0x06	; 6
    2a10:	0f b6       	in	r0, 0x3f	; 63
    2a12:	f8 94       	cli
    2a14:	de bf       	out	0x3e, r29	; 62
    2a16:	0f be       	out	0x3f, r0	; 63
    2a18:	cd bf       	out	0x3d, r28	; 61
    2a1a:	cf 91       	pop	r28
    2a1c:	df 91       	pop	r29
    2a1e:	08 95       	ret

00002a20 <xStreamBufferSend>:

size_t xStreamBufferSend( StreamBufferHandle_t xStreamBuffer,
						  const void *pvTxData,
						  size_t xDataLengthBytes,
						  TickType_t xTicksToWait )
{
    2a20:	ef 92       	push	r14
    2a22:	ff 92       	push	r15
    2a24:	0f 93       	push	r16
    2a26:	1f 93       	push	r17
    2a28:	df 93       	push	r29
    2a2a:	cf 93       	push	r28
    2a2c:	cd b7       	in	r28, 0x3d	; 61
    2a2e:	de b7       	in	r29, 0x3e	; 62
    2a30:	63 97       	sbiw	r28, 0x13	; 19
    2a32:	0f b6       	in	r0, 0x3f	; 63
    2a34:	f8 94       	cli
    2a36:	de bf       	out	0x3e, r29	; 62
    2a38:	0f be       	out	0x3f, r0	; 63
    2a3a:	cd bf       	out	0x3d, r28	; 61
    2a3c:	9d 87       	std	Y+13, r25	; 0x0d
    2a3e:	8c 87       	std	Y+12, r24	; 0x0c
    2a40:	7f 87       	std	Y+15, r23	; 0x0f
    2a42:	6e 87       	std	Y+14, r22	; 0x0e
    2a44:	59 8b       	std	Y+17, r21	; 0x11
    2a46:	48 8b       	std	Y+16, r20	; 0x10
    2a48:	3b 8b       	std	Y+19, r19	; 0x13
    2a4a:	2a 8b       	std	Y+18, r18	; 0x12
StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
    2a4c:	8c 85       	ldd	r24, Y+12	; 0x0c
    2a4e:	9d 85       	ldd	r25, Y+13	; 0x0d
    2a50:	98 87       	std	Y+8, r25	; 0x08
    2a52:	8f 83       	std	Y+7, r24	; 0x07
size_t xReturn, xSpace = 0;
    2a54:	1c 82       	std	Y+4, r1	; 0x04
    2a56:	1b 82       	std	Y+3, r1	; 0x03
size_t xRequiredSpace = xDataLengthBytes;
    2a58:	88 89       	ldd	r24, Y+16	; 0x10
    2a5a:	99 89       	ldd	r25, Y+17	; 0x11
    2a5c:	9a 83       	std	Y+2, r25	; 0x02
    2a5e:	89 83       	std	Y+1, r24	; 0x01

	/* This send function is used to write to both message buffers and stream
	buffers.  If this is a message buffer then the space needed must be
	increased by the amount of bytes needed to store the length of the
	message. */
	if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_MESSAGE_BUFFER ) != ( uint8_t ) 0 )
    2a60:	ef 81       	ldd	r30, Y+7	; 0x07
    2a62:	f8 85       	ldd	r31, Y+8	; 0x08
    2a64:	86 85       	ldd	r24, Z+14	; 0x0e
    2a66:	88 2f       	mov	r24, r24
    2a68:	90 e0       	ldi	r25, 0x00	; 0
    2a6a:	81 70       	andi	r24, 0x01	; 1
    2a6c:	90 70       	andi	r25, 0x00	; 0
    2a6e:	88 23       	and	r24, r24
    2a70:	29 f0       	breq	.+10     	; 0x2a7c <xStreamBufferSend+0x5c>
	{
		xRequiredSpace += sbBYTES_TO_STORE_MESSAGE_LENGTH;
    2a72:	89 81       	ldd	r24, Y+1	; 0x01
    2a74:	9a 81       	ldd	r25, Y+2	; 0x02
    2a76:	02 96       	adiw	r24, 0x02	; 2
    2a78:	9a 83       	std	Y+2, r25	; 0x02
    2a7a:	89 83       	std	Y+1, r24	; 0x01
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	if( xTicksToWait != ( TickType_t ) 0 )
    2a7c:	8a 89       	ldd	r24, Y+18	; 0x12
    2a7e:	9b 89       	ldd	r25, Y+19	; 0x13
    2a80:	00 97       	sbiw	r24, 0x00	; 0
    2a82:	09 f4       	brne	.+2      	; 0x2a86 <xStreamBufferSend+0x66>
    2a84:	40 c0       	rjmp	.+128    	; 0x2b06 <xStreamBufferSend+0xe6>
	{
		vTaskSetTimeOutState( &xTimeOut );
    2a86:	ce 01       	movw	r24, r28
    2a88:	09 96       	adiw	r24, 0x09	; 9
    2a8a:	0e 94 ac 22 	call	0x4558	; 0x4558 <vTaskSetTimeOutState>

		do
		{
			/* Wait until the required number of bytes are free in the message
			buffer. */
			taskENTER_CRITICAL();
    2a8e:	0f b6       	in	r0, 0x3f	; 63
    2a90:	f8 94       	cli
    2a92:	0f 92       	push	r0
			{
				xSpace = xStreamBufferSpacesAvailable( pxStreamBuffer );
    2a94:	8f 81       	ldd	r24, Y+7	; 0x07
    2a96:	98 85       	ldd	r25, Y+8	; 0x08
    2a98:	0e 94 ac 14 	call	0x2958	; 0x2958 <xStreamBufferSpacesAvailable>
    2a9c:	9c 83       	std	Y+4, r25	; 0x04
    2a9e:	8b 83       	std	Y+3, r24	; 0x03

				if( xSpace < xRequiredSpace )
    2aa0:	2b 81       	ldd	r18, Y+3	; 0x03
    2aa2:	3c 81       	ldd	r19, Y+4	; 0x04
    2aa4:	89 81       	ldd	r24, Y+1	; 0x01
    2aa6:	9a 81       	ldd	r25, Y+2	; 0x02
    2aa8:	28 17       	cp	r18, r24
    2aaa:	39 07       	cpc	r19, r25
    2aac:	50 f5       	brcc	.+84     	; 0x2b02 <xStreamBufferSend+0xe2>
				{
					/* Clear notification state as going to wait for space. */
					( void ) xTaskNotifyStateClear( NULL );
    2aae:	80 e0       	ldi	r24, 0x00	; 0
    2ab0:	90 e0       	ldi	r25, 0x00	; 0
    2ab2:	0e 94 79 29 	call	0x52f2	; 0x52f2 <xTaskNotifyStateClear>

					/* Should only be one writer. */
					configASSERT( pxStreamBuffer->xTaskWaitingToSend == NULL );
					pxStreamBuffer->xTaskWaitingToSend = xTaskGetCurrentTaskHandle();
    2ab6:	0e 94 15 24 	call	0x482a	; 0x482a <xTaskGetCurrentTaskHandle>
    2aba:	ef 81       	ldd	r30, Y+7	; 0x07
    2abc:	f8 85       	ldd	r31, Y+8	; 0x08
    2abe:	93 87       	std	Z+11, r25	; 0x0b
    2ac0:	82 87       	std	Z+10, r24	; 0x0a
				{
					taskEXIT_CRITICAL();
					break;
				}
			}
			taskEXIT_CRITICAL();
    2ac2:	0f 90       	pop	r0
    2ac4:	0f be       	out	0x3f, r0	; 63

			traceBLOCKING_ON_STREAM_BUFFER_SEND( xStreamBuffer );
			( void ) xTaskNotifyWait( ( uint32_t ) 0, ( uint32_t ) 0, NULL, xTicksToWait );
    2ac6:	ea 89       	ldd	r30, Y+18	; 0x12
    2ac8:	fb 89       	ldd	r31, Y+19	; 0x13
    2aca:	60 e0       	ldi	r22, 0x00	; 0
    2acc:	70 e0       	ldi	r23, 0x00	; 0
    2ace:	80 e0       	ldi	r24, 0x00	; 0
    2ad0:	90 e0       	ldi	r25, 0x00	; 0
    2ad2:	20 e0       	ldi	r18, 0x00	; 0
    2ad4:	30 e0       	ldi	r19, 0x00	; 0
    2ad6:	40 e0       	ldi	r20, 0x00	; 0
    2ad8:	50 e0       	ldi	r21, 0x00	; 0
    2ada:	00 e0       	ldi	r16, 0x00	; 0
    2adc:	10 e0       	ldi	r17, 0x00	; 0
    2ade:	7f 01       	movw	r14, r30
    2ae0:	0e 94 82 26 	call	0x4d04	; 0x4d04 <xTaskNotifyWait>
			pxStreamBuffer->xTaskWaitingToSend = NULL;
    2ae4:	ef 81       	ldd	r30, Y+7	; 0x07
    2ae6:	f8 85       	ldd	r31, Y+8	; 0x08
    2ae8:	13 86       	std	Z+11, r1	; 0x0b
    2aea:	12 86       	std	Z+10, r1	; 0x0a

		} while( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE );
    2aec:	ce 01       	movw	r24, r28
    2aee:	09 96       	adiw	r24, 0x09	; 9
    2af0:	9e 01       	movw	r18, r28
    2af2:	2e 5e       	subi	r18, 0xEE	; 238
    2af4:	3f 4f       	sbci	r19, 0xFF	; 255
    2af6:	b9 01       	movw	r22, r18
    2af8:	0e 94 e3 22 	call	0x45c6	; 0x45c6 <xTaskCheckForTimeOut>
    2afc:	88 23       	and	r24, r24
    2afe:	39 f2       	breq	.-114    	; 0x2a8e <xStreamBufferSend+0x6e>
    2b00:	02 c0       	rjmp	.+4      	; 0x2b06 <xStreamBufferSend+0xe6>
					configASSERT( pxStreamBuffer->xTaskWaitingToSend == NULL );
					pxStreamBuffer->xTaskWaitingToSend = xTaskGetCurrentTaskHandle();
				}
				else
				{
					taskEXIT_CRITICAL();
    2b02:	0f 90       	pop	r0
    2b04:	0f be       	out	0x3f, r0	; 63
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	if( xSpace == ( size_t ) 0 )
    2b06:	8b 81       	ldd	r24, Y+3	; 0x03
    2b08:	9c 81       	ldd	r25, Y+4	; 0x04
    2b0a:	00 97       	sbiw	r24, 0x00	; 0
    2b0c:	31 f4       	brne	.+12     	; 0x2b1a <xStreamBufferSend+0xfa>
	{
		xSpace = xStreamBufferSpacesAvailable( pxStreamBuffer );
    2b0e:	8f 81       	ldd	r24, Y+7	; 0x07
    2b10:	98 85       	ldd	r25, Y+8	; 0x08
    2b12:	0e 94 ac 14 	call	0x2958	; 0x2958 <xStreamBufferSpacesAvailable>
    2b16:	9c 83       	std	Y+4, r25	; 0x04
    2b18:	8b 83       	std	Y+3, r24	; 0x03
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	xReturn = prvWriteMessageToBuffer( pxStreamBuffer, pvTxData, xDataLengthBytes, xSpace, xRequiredSpace );
    2b1a:	8f 81       	ldd	r24, Y+7	; 0x07
    2b1c:	98 85       	ldd	r25, Y+8	; 0x08
    2b1e:	2e 85       	ldd	r18, Y+14	; 0x0e
    2b20:	3f 85       	ldd	r19, Y+15	; 0x0f
    2b22:	48 89       	ldd	r20, Y+16	; 0x10
    2b24:	59 89       	ldd	r21, Y+17	; 0x11
    2b26:	eb 81       	ldd	r30, Y+3	; 0x03
    2b28:	fc 81       	ldd	r31, Y+4	; 0x04
    2b2a:	a9 81       	ldd	r26, Y+1	; 0x01
    2b2c:	ba 81       	ldd	r27, Y+2	; 0x02
    2b2e:	b9 01       	movw	r22, r18
    2b30:	9f 01       	movw	r18, r30
    2b32:	8d 01       	movw	r16, r26
    2b34:	0e 94 55 16 	call	0x2caa	; 0x2caa <prvWriteMessageToBuffer>
    2b38:	9e 83       	std	Y+6, r25	; 0x06
    2b3a:	8d 83       	std	Y+5, r24	; 0x05

	if( xReturn > ( size_t ) 0 )
    2b3c:	8d 81       	ldd	r24, Y+5	; 0x05
    2b3e:	9e 81       	ldd	r25, Y+6	; 0x06
    2b40:	00 97       	sbiw	r24, 0x00	; 0
    2b42:	39 f1       	breq	.+78     	; 0x2b92 <xStreamBufferSend+0x172>
	{
		traceSTREAM_BUFFER_SEND( xStreamBuffer, xReturn );

		/* Was a task waiting for the data? */
		if( prvBytesInBuffer( pxStreamBuffer ) >= pxStreamBuffer->xTriggerLevelBytes )
    2b44:	8f 81       	ldd	r24, Y+7	; 0x07
    2b46:	98 85       	ldd	r25, Y+8	; 0x08
    2b48:	0e 94 dc 1a 	call	0x35b8	; 0x35b8 <prvBytesInBuffer>
    2b4c:	9c 01       	movw	r18, r24
    2b4e:	ef 81       	ldd	r30, Y+7	; 0x07
    2b50:	f8 85       	ldd	r31, Y+8	; 0x08
    2b52:	86 81       	ldd	r24, Z+6	; 0x06
    2b54:	97 81       	ldd	r25, Z+7	; 0x07
    2b56:	28 17       	cp	r18, r24
    2b58:	39 07       	cpc	r19, r25
    2b5a:	d8 f0       	brcs	.+54     	; 0x2b92 <xStreamBufferSend+0x172>
		{
			sbSEND_COMPLETED( pxStreamBuffer );
    2b5c:	0e 94 44 1f 	call	0x3e88	; 0x3e88 <vTaskSuspendAll>
    2b60:	ef 81       	ldd	r30, Y+7	; 0x07
    2b62:	f8 85       	ldd	r31, Y+8	; 0x08
    2b64:	80 85       	ldd	r24, Z+8	; 0x08
    2b66:	91 85       	ldd	r25, Z+9	; 0x09
    2b68:	00 97       	sbiw	r24, 0x00	; 0
    2b6a:	89 f0       	breq	.+34     	; 0x2b8e <xStreamBufferSend+0x16e>
    2b6c:	ef 81       	ldd	r30, Y+7	; 0x07
    2b6e:	f8 85       	ldd	r31, Y+8	; 0x08
    2b70:	80 85       	ldd	r24, Z+8	; 0x08
    2b72:	91 85       	ldd	r25, Z+9	; 0x09
    2b74:	40 e0       	ldi	r20, 0x00	; 0
    2b76:	50 e0       	ldi	r21, 0x00	; 0
    2b78:	60 e0       	ldi	r22, 0x00	; 0
    2b7a:	70 e0       	ldi	r23, 0x00	; 0
    2b7c:	20 e0       	ldi	r18, 0x00	; 0
    2b7e:	00 e0       	ldi	r16, 0x00	; 0
    2b80:	10 e0       	ldi	r17, 0x00	; 0
    2b82:	0e 94 1e 27 	call	0x4e3c	; 0x4e3c <xTaskGenericNotify>
    2b86:	ef 81       	ldd	r30, Y+7	; 0x07
    2b88:	f8 85       	ldd	r31, Y+8	; 0x08
    2b8a:	11 86       	std	Z+9, r1	; 0x09
    2b8c:	10 86       	std	Z+8, r1	; 0x08
    2b8e:	0e 94 50 1f 	call	0x3ea0	; 0x3ea0 <xTaskResumeAll>
	{
		mtCOVERAGE_TEST_MARKER();
		traceSTREAM_BUFFER_SEND_FAILED( xStreamBuffer );
	}

	return xReturn;
    2b92:	8d 81       	ldd	r24, Y+5	; 0x05
    2b94:	9e 81       	ldd	r25, Y+6	; 0x06
}
    2b96:	63 96       	adiw	r28, 0x13	; 19
    2b98:	0f b6       	in	r0, 0x3f	; 63
    2b9a:	f8 94       	cli
    2b9c:	de bf       	out	0x3e, r29	; 62
    2b9e:	0f be       	out	0x3f, r0	; 63
    2ba0:	cd bf       	out	0x3d, r28	; 61
    2ba2:	cf 91       	pop	r28
    2ba4:	df 91       	pop	r29
    2ba6:	1f 91       	pop	r17
    2ba8:	0f 91       	pop	r16
    2baa:	ff 90       	pop	r15
    2bac:	ef 90       	pop	r14
    2bae:	08 95       	ret

00002bb0 <xStreamBufferSendFromISR>:

size_t xStreamBufferSendFromISR( StreamBufferHandle_t xStreamBuffer,
								 const void *pvTxData,
								 size_t xDataLengthBytes,
								 BaseType_t * const pxHigherPriorityTaskWoken )
{
    2bb0:	ef 92       	push	r14
    2bb2:	ff 92       	push	r15
    2bb4:	0f 93       	push	r16
    2bb6:	1f 93       	push	r17
    2bb8:	df 93       	push	r29
    2bba:	cf 93       	push	r28
    2bbc:	cd b7       	in	r28, 0x3d	; 61
    2bbe:	de b7       	in	r29, 0x3e	; 62
    2bc0:	61 97       	sbiw	r28, 0x11	; 17
    2bc2:	0f b6       	in	r0, 0x3f	; 63
    2bc4:	f8 94       	cli
    2bc6:	de bf       	out	0x3e, r29	; 62
    2bc8:	0f be       	out	0x3f, r0	; 63
    2bca:	cd bf       	out	0x3d, r28	; 61
    2bcc:	9b 87       	std	Y+11, r25	; 0x0b
    2bce:	8a 87       	std	Y+10, r24	; 0x0a
    2bd0:	7d 87       	std	Y+13, r23	; 0x0d
    2bd2:	6c 87       	std	Y+12, r22	; 0x0c
    2bd4:	5f 87       	std	Y+15, r21	; 0x0f
    2bd6:	4e 87       	std	Y+14, r20	; 0x0e
    2bd8:	39 8b       	std	Y+17, r19	; 0x11
    2bda:	28 8b       	std	Y+16, r18	; 0x10
StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
    2bdc:	8a 85       	ldd	r24, Y+10	; 0x0a
    2bde:	9b 85       	ldd	r25, Y+11	; 0x0b
    2be0:	99 87       	std	Y+9, r25	; 0x09
    2be2:	88 87       	std	Y+8, r24	; 0x08
size_t xReturn, xSpace;
size_t xRequiredSpace = xDataLengthBytes;
    2be4:	8e 85       	ldd	r24, Y+14	; 0x0e
    2be6:	9f 85       	ldd	r25, Y+15	; 0x0f
    2be8:	9b 83       	std	Y+3, r25	; 0x03
    2bea:	8a 83       	std	Y+2, r24	; 0x02

	/* This send function is used to write to both message buffers and stream
	buffers.  If this is a message buffer then the space needed must be
	increased by the amount of bytes needed to store the length of the
	message. */
	if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_MESSAGE_BUFFER ) != ( uint8_t ) 0 )
    2bec:	e8 85       	ldd	r30, Y+8	; 0x08
    2bee:	f9 85       	ldd	r31, Y+9	; 0x09
    2bf0:	86 85       	ldd	r24, Z+14	; 0x0e
    2bf2:	88 2f       	mov	r24, r24
    2bf4:	90 e0       	ldi	r25, 0x00	; 0
    2bf6:	81 70       	andi	r24, 0x01	; 1
    2bf8:	90 70       	andi	r25, 0x00	; 0
    2bfa:	88 23       	and	r24, r24
    2bfc:	29 f0       	breq	.+10     	; 0x2c08 <xStreamBufferSendFromISR+0x58>
	{
		xRequiredSpace += sbBYTES_TO_STORE_MESSAGE_LENGTH;
    2bfe:	8a 81       	ldd	r24, Y+2	; 0x02
    2c00:	9b 81       	ldd	r25, Y+3	; 0x03
    2c02:	02 96       	adiw	r24, 0x02	; 2
    2c04:	9b 83       	std	Y+3, r25	; 0x03
    2c06:	8a 83       	std	Y+2, r24	; 0x02
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	xSpace = xStreamBufferSpacesAvailable( pxStreamBuffer );
    2c08:	88 85       	ldd	r24, Y+8	; 0x08
    2c0a:	99 85       	ldd	r25, Y+9	; 0x09
    2c0c:	0e 94 ac 14 	call	0x2958	; 0x2958 <xStreamBufferSpacesAvailable>
    2c10:	9d 83       	std	Y+5, r25	; 0x05
    2c12:	8c 83       	std	Y+4, r24	; 0x04
	xReturn = prvWriteMessageToBuffer( pxStreamBuffer, pvTxData, xDataLengthBytes, xSpace, xRequiredSpace );
    2c14:	88 85       	ldd	r24, Y+8	; 0x08
    2c16:	99 85       	ldd	r25, Y+9	; 0x09
    2c18:	2c 85       	ldd	r18, Y+12	; 0x0c
    2c1a:	3d 85       	ldd	r19, Y+13	; 0x0d
    2c1c:	4e 85       	ldd	r20, Y+14	; 0x0e
    2c1e:	5f 85       	ldd	r21, Y+15	; 0x0f
    2c20:	ec 81       	ldd	r30, Y+4	; 0x04
    2c22:	fd 81       	ldd	r31, Y+5	; 0x05
    2c24:	aa 81       	ldd	r26, Y+2	; 0x02
    2c26:	bb 81       	ldd	r27, Y+3	; 0x03
    2c28:	b9 01       	movw	r22, r18
    2c2a:	9f 01       	movw	r18, r30
    2c2c:	8d 01       	movw	r16, r26
    2c2e:	0e 94 55 16 	call	0x2caa	; 0x2caa <prvWriteMessageToBuffer>
    2c32:	9f 83       	std	Y+7, r25	; 0x07
    2c34:	8e 83       	std	Y+6, r24	; 0x06

	if( xReturn > ( size_t ) 0 )
    2c36:	8e 81       	ldd	r24, Y+6	; 0x06
    2c38:	9f 81       	ldd	r25, Y+7	; 0x07
    2c3a:	00 97       	sbiw	r24, 0x00	; 0
    2c3c:	39 f1       	breq	.+78     	; 0x2c8c <xStreamBufferSendFromISR+0xdc>
	{
		/* Was a task waiting for the data? */
		if( prvBytesInBuffer( pxStreamBuffer ) >= pxStreamBuffer->xTriggerLevelBytes )
    2c3e:	88 85       	ldd	r24, Y+8	; 0x08
    2c40:	99 85       	ldd	r25, Y+9	; 0x09
    2c42:	0e 94 dc 1a 	call	0x35b8	; 0x35b8 <prvBytesInBuffer>
    2c46:	9c 01       	movw	r18, r24
    2c48:	e8 85       	ldd	r30, Y+8	; 0x08
    2c4a:	f9 85       	ldd	r31, Y+9	; 0x09
    2c4c:	86 81       	ldd	r24, Z+6	; 0x06
    2c4e:	97 81       	ldd	r25, Z+7	; 0x07
    2c50:	28 17       	cp	r18, r24
    2c52:	39 07       	cpc	r19, r25
    2c54:	d8 f0       	brcs	.+54     	; 0x2c8c <xStreamBufferSendFromISR+0xdc>
		{
			sbSEND_COMPLETE_FROM_ISR( pxStreamBuffer, pxHigherPriorityTaskWoken );
    2c56:	19 82       	std	Y+1, r1	; 0x01
    2c58:	e8 85       	ldd	r30, Y+8	; 0x08
    2c5a:	f9 85       	ldd	r31, Y+9	; 0x09
    2c5c:	80 85       	ldd	r24, Z+8	; 0x08
    2c5e:	91 85       	ldd	r25, Z+9	; 0x09
    2c60:	00 97       	sbiw	r24, 0x00	; 0
    2c62:	a1 f0       	breq	.+40     	; 0x2c8c <xStreamBufferSendFromISR+0xdc>
    2c64:	e8 85       	ldd	r30, Y+8	; 0x08
    2c66:	f9 85       	ldd	r31, Y+9	; 0x09
    2c68:	80 85       	ldd	r24, Z+8	; 0x08
    2c6a:	91 85       	ldd	r25, Z+9	; 0x09
    2c6c:	e8 89       	ldd	r30, Y+16	; 0x10
    2c6e:	f9 89       	ldd	r31, Y+17	; 0x11
    2c70:	40 e0       	ldi	r20, 0x00	; 0
    2c72:	50 e0       	ldi	r21, 0x00	; 0
    2c74:	60 e0       	ldi	r22, 0x00	; 0
    2c76:	70 e0       	ldi	r23, 0x00	; 0
    2c78:	20 e0       	ldi	r18, 0x00	; 0
    2c7a:	00 e0       	ldi	r16, 0x00	; 0
    2c7c:	10 e0       	ldi	r17, 0x00	; 0
    2c7e:	7f 01       	movw	r14, r30
    2c80:	0e 94 fb 27 	call	0x4ff6	; 0x4ff6 <xTaskGenericNotifyFromISR>
    2c84:	e8 85       	ldd	r30, Y+8	; 0x08
    2c86:	f9 85       	ldd	r31, Y+9	; 0x09
    2c88:	11 86       	std	Z+9, r1	; 0x09
    2c8a:	10 86       	std	Z+8, r1	; 0x08
		mtCOVERAGE_TEST_MARKER();
	}

	traceSTREAM_BUFFER_SEND_FROM_ISR( xStreamBuffer, xReturn );

	return xReturn;
    2c8c:	8e 81       	ldd	r24, Y+6	; 0x06
    2c8e:	9f 81       	ldd	r25, Y+7	; 0x07
}
    2c90:	61 96       	adiw	r28, 0x11	; 17
    2c92:	0f b6       	in	r0, 0x3f	; 63
    2c94:	f8 94       	cli
    2c96:	de bf       	out	0x3e, r29	; 62
    2c98:	0f be       	out	0x3f, r0	; 63
    2c9a:	cd bf       	out	0x3d, r28	; 61
    2c9c:	cf 91       	pop	r28
    2c9e:	df 91       	pop	r29
    2ca0:	1f 91       	pop	r17
    2ca2:	0f 91       	pop	r16
    2ca4:	ff 90       	pop	r15
    2ca6:	ef 90       	pop	r14
    2ca8:	08 95       	ret

00002caa <prvWriteMessageToBuffer>:
static size_t prvWriteMessageToBuffer( StreamBuffer_t * const pxStreamBuffer,
									   const void * pvTxData,
									   size_t xDataLengthBytes,
									   size_t xSpace,
									   size_t xRequiredSpace )
{
    2caa:	0f 93       	push	r16
    2cac:	1f 93       	push	r17
    2cae:	df 93       	push	r29
    2cb0:	cf 93       	push	r28
    2cb2:	cd b7       	in	r28, 0x3d	; 61
    2cb4:	de b7       	in	r29, 0x3e	; 62
    2cb6:	61 97       	sbiw	r28, 0x11	; 17
    2cb8:	0f b6       	in	r0, 0x3f	; 63
    2cba:	f8 94       	cli
    2cbc:	de bf       	out	0x3e, r29	; 62
    2cbe:	0f be       	out	0x3f, r0	; 63
    2cc0:	cd bf       	out	0x3d, r28	; 61
    2cc2:	9d 83       	std	Y+5, r25	; 0x05
    2cc4:	8c 83       	std	Y+4, r24	; 0x04
    2cc6:	7f 83       	std	Y+7, r23	; 0x07
    2cc8:	6e 83       	std	Y+6, r22	; 0x06
    2cca:	59 87       	std	Y+9, r21	; 0x09
    2ccc:	48 87       	std	Y+8, r20	; 0x08
    2cce:	3b 87       	std	Y+11, r19	; 0x0b
    2cd0:	2a 87       	std	Y+10, r18	; 0x0a
    2cd2:	1d 87       	std	Y+13, r17	; 0x0d
    2cd4:	0c 87       	std	Y+12, r16	; 0x0c
	BaseType_t xShouldWrite;
	size_t xReturn;

	if( xSpace == ( size_t ) 0 )
    2cd6:	8a 85       	ldd	r24, Y+10	; 0x0a
    2cd8:	9b 85       	ldd	r25, Y+11	; 0x0b
    2cda:	00 97       	sbiw	r24, 0x00	; 0
    2cdc:	11 f4       	brne	.+4      	; 0x2ce2 <prvWriteMessageToBuffer+0x38>
	{
		/* Doesn't matter if this is a stream buffer or a message buffer, there
		is no space to write. */
		xShouldWrite = pdFALSE;
    2cde:	1b 82       	std	Y+3, r1	; 0x03
    2ce0:	38 c0       	rjmp	.+112    	; 0x2d52 <prvWriteMessageToBuffer+0xa8>
	}
	else if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_MESSAGE_BUFFER ) == ( uint8_t ) 0 )
    2ce2:	ec 81       	ldd	r30, Y+4	; 0x04
    2ce4:	fd 81       	ldd	r31, Y+5	; 0x05
    2ce6:	86 85       	ldd	r24, Z+14	; 0x0e
    2ce8:	88 2f       	mov	r24, r24
    2cea:	90 e0       	ldi	r25, 0x00	; 0
    2cec:	81 70       	andi	r24, 0x01	; 1
    2cee:	90 70       	andi	r25, 0x00	; 0
    2cf0:	00 97       	sbiw	r24, 0x00	; 0
    2cf2:	d1 f4       	brne	.+52     	; 0x2d28 <prvWriteMessageToBuffer+0x7e>
	{
		/* This is a stream buffer, as opposed to a message buffer, so writing a
		stream of bytes rather than discrete messages.  Write as many bytes as
		possible. */
		xShouldWrite = pdTRUE;
    2cf4:	81 e0       	ldi	r24, 0x01	; 1
    2cf6:	8b 83       	std	Y+3, r24	; 0x03
		xDataLengthBytes = configMIN( xDataLengthBytes, xSpace );
    2cf8:	28 85       	ldd	r18, Y+8	; 0x08
    2cfa:	39 85       	ldd	r19, Y+9	; 0x09
    2cfc:	39 8b       	std	Y+17, r19	; 0x11
    2cfe:	28 8b       	std	Y+16, r18	; 0x10
    2d00:	8a 85       	ldd	r24, Y+10	; 0x0a
    2d02:	9b 85       	ldd	r25, Y+11	; 0x0b
    2d04:	9f 87       	std	Y+15, r25	; 0x0f
    2d06:	8e 87       	std	Y+14, r24	; 0x0e
    2d08:	2e 85       	ldd	r18, Y+14	; 0x0e
    2d0a:	3f 85       	ldd	r19, Y+15	; 0x0f
    2d0c:	88 89       	ldd	r24, Y+16	; 0x10
    2d0e:	99 89       	ldd	r25, Y+17	; 0x11
    2d10:	82 17       	cp	r24, r18
    2d12:	93 07       	cpc	r25, r19
    2d14:	20 f4       	brcc	.+8      	; 0x2d1e <prvWriteMessageToBuffer+0x74>
    2d16:	28 89       	ldd	r18, Y+16	; 0x10
    2d18:	39 89       	ldd	r19, Y+17	; 0x11
    2d1a:	3f 87       	std	Y+15, r19	; 0x0f
    2d1c:	2e 87       	std	Y+14, r18	; 0x0e
    2d1e:	8e 85       	ldd	r24, Y+14	; 0x0e
    2d20:	9f 85       	ldd	r25, Y+15	; 0x0f
    2d22:	99 87       	std	Y+9, r25	; 0x09
    2d24:	88 87       	std	Y+8, r24	; 0x08
    2d26:	15 c0       	rjmp	.+42     	; 0x2d52 <prvWriteMessageToBuffer+0xa8>
	}
	else if( xSpace >= xRequiredSpace )
    2d28:	2a 85       	ldd	r18, Y+10	; 0x0a
    2d2a:	3b 85       	ldd	r19, Y+11	; 0x0b
    2d2c:	8c 85       	ldd	r24, Y+12	; 0x0c
    2d2e:	9d 85       	ldd	r25, Y+13	; 0x0d
    2d30:	28 17       	cp	r18, r24
    2d32:	39 07       	cpc	r19, r25
    2d34:	68 f0       	brcs	.+26     	; 0x2d50 <prvWriteMessageToBuffer+0xa6>
	{
		/* This is a message buffer, as opposed to a stream buffer, and there
		is enough space to write both the message length and the message itself
		into the buffer.  Start by writing the length of the data, the data
		itself will be written later in this function. */
		xShouldWrite = pdTRUE;
    2d36:	81 e0       	ldi	r24, 0x01	; 1
    2d38:	8b 83       	std	Y+3, r24	; 0x03
		( void ) prvWriteBytesToBuffer( pxStreamBuffer, ( const uint8_t * ) &( xDataLengthBytes ), sbBYTES_TO_STORE_MESSAGE_LENGTH );
    2d3a:	9e 01       	movw	r18, r28
    2d3c:	28 5f       	subi	r18, 0xF8	; 248
    2d3e:	3f 4f       	sbci	r19, 0xFF	; 255
    2d40:	8c 81       	ldd	r24, Y+4	; 0x04
    2d42:	9d 81       	ldd	r25, Y+5	; 0x05
    2d44:	b9 01       	movw	r22, r18
    2d46:	42 e0       	ldi	r20, 0x02	; 2
    2d48:	50 e0       	ldi	r21, 0x00	; 0
    2d4a:	0e 94 a2 19 	call	0x3344	; 0x3344 <prvWriteBytesToBuffer>
    2d4e:	01 c0       	rjmp	.+2      	; 0x2d52 <prvWriteMessageToBuffer+0xa8>
	}
	else
	{
		/* There is space available, but not enough space. */
		xShouldWrite = pdFALSE;
    2d50:	1b 82       	std	Y+3, r1	; 0x03
	}

	if( xShouldWrite != pdFALSE )
    2d52:	8b 81       	ldd	r24, Y+3	; 0x03
    2d54:	88 23       	and	r24, r24
    2d56:	61 f0       	breq	.+24     	; 0x2d70 <prvWriteMessageToBuffer+0xc6>
	{
		/* Writes the data itself. */
		xReturn = prvWriteBytesToBuffer( pxStreamBuffer, ( const uint8_t * ) pvTxData, xDataLengthBytes ); /*lint !e9079 Storage buffer is implemented as uint8_t for ease of sizing, alighment and access. */
    2d58:	2e 81       	ldd	r18, Y+6	; 0x06
    2d5a:	3f 81       	ldd	r19, Y+7	; 0x07
    2d5c:	48 85       	ldd	r20, Y+8	; 0x08
    2d5e:	59 85       	ldd	r21, Y+9	; 0x09
    2d60:	8c 81       	ldd	r24, Y+4	; 0x04
    2d62:	9d 81       	ldd	r25, Y+5	; 0x05
    2d64:	b9 01       	movw	r22, r18
    2d66:	0e 94 a2 19 	call	0x3344	; 0x3344 <prvWriteBytesToBuffer>
    2d6a:	9a 83       	std	Y+2, r25	; 0x02
    2d6c:	89 83       	std	Y+1, r24	; 0x01
    2d6e:	02 c0       	rjmp	.+4      	; 0x2d74 <prvWriteMessageToBuffer+0xca>
	}
	else
	{
		xReturn = 0;
    2d70:	1a 82       	std	Y+2, r1	; 0x02
    2d72:	19 82       	std	Y+1, r1	; 0x01
	}

	return xReturn;
    2d74:	89 81       	ldd	r24, Y+1	; 0x01
    2d76:	9a 81       	ldd	r25, Y+2	; 0x02
}
    2d78:	61 96       	adiw	r28, 0x11	; 17
    2d7a:	0f b6       	in	r0, 0x3f	; 63
    2d7c:	f8 94       	cli
    2d7e:	de bf       	out	0x3e, r29	; 62
    2d80:	0f be       	out	0x3f, r0	; 63
    2d82:	cd bf       	out	0x3d, r28	; 61
    2d84:	cf 91       	pop	r28
    2d86:	df 91       	pop	r29
    2d88:	1f 91       	pop	r17
    2d8a:	0f 91       	pop	r16
    2d8c:	08 95       	ret

00002d8e <xStreamBufferReceive>:

size_t xStreamBufferReceive( StreamBufferHandle_t xStreamBuffer,
							 void *pvRxData,
							 size_t xBufferLengthBytes,
							 TickType_t xTicksToWait )
{
    2d8e:	ef 92       	push	r14
    2d90:	ff 92       	push	r15
    2d92:	0f 93       	push	r16
    2d94:	1f 93       	push	r17
    2d96:	df 93       	push	r29
    2d98:	cf 93       	push	r28
    2d9a:	cd b7       	in	r28, 0x3d	; 61
    2d9c:	de b7       	in	r29, 0x3e	; 62
    2d9e:	60 97       	sbiw	r28, 0x10	; 16
    2da0:	0f b6       	in	r0, 0x3f	; 63
    2da2:	f8 94       	cli
    2da4:	de bf       	out	0x3e, r29	; 62
    2da6:	0f be       	out	0x3f, r0	; 63
    2da8:	cd bf       	out	0x3d, r28	; 61
    2daa:	9a 87       	std	Y+10, r25	; 0x0a
    2dac:	89 87       	std	Y+9, r24	; 0x09
    2dae:	7c 87       	std	Y+12, r23	; 0x0c
    2db0:	6b 87       	std	Y+11, r22	; 0x0b
    2db2:	5e 87       	std	Y+14, r21	; 0x0e
    2db4:	4d 87       	std	Y+13, r20	; 0x0d
    2db6:	38 8b       	std	Y+16, r19	; 0x10
    2db8:	2f 87       	std	Y+15, r18	; 0x0f
StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
    2dba:	89 85       	ldd	r24, Y+9	; 0x09
    2dbc:	9a 85       	ldd	r25, Y+10	; 0x0a
    2dbe:	98 87       	std	Y+8, r25	; 0x08
    2dc0:	8f 83       	std	Y+7, r24	; 0x07
size_t xReceivedLength = 0, xBytesAvailable, xBytesToStoreMessageLength;
    2dc2:	1e 82       	std	Y+6, r1	; 0x06
    2dc4:	1d 82       	std	Y+5, r1	; 0x05
	/* This receive function is used by both message buffers, which store
	discrete messages, and stream buffers, which store a continuous stream of
	bytes.  Discrete messages include an additional
	sbBYTES_TO_STORE_MESSAGE_LENGTH bytes that hold the length of the
	message. */
	if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_MESSAGE_BUFFER ) != ( uint8_t ) 0 )
    2dc6:	ef 81       	ldd	r30, Y+7	; 0x07
    2dc8:	f8 85       	ldd	r31, Y+8	; 0x08
    2dca:	86 85       	ldd	r24, Z+14	; 0x0e
    2dcc:	88 2f       	mov	r24, r24
    2dce:	90 e0       	ldi	r25, 0x00	; 0
    2dd0:	81 70       	andi	r24, 0x01	; 1
    2dd2:	90 70       	andi	r25, 0x00	; 0
    2dd4:	88 23       	and	r24, r24
    2dd6:	29 f0       	breq	.+10     	; 0x2de2 <xStreamBufferReceive+0x54>
	{
		xBytesToStoreMessageLength = sbBYTES_TO_STORE_MESSAGE_LENGTH;
    2dd8:	82 e0       	ldi	r24, 0x02	; 2
    2dda:	90 e0       	ldi	r25, 0x00	; 0
    2ddc:	9a 83       	std	Y+2, r25	; 0x02
    2dde:	89 83       	std	Y+1, r24	; 0x01
    2de0:	02 c0       	rjmp	.+4      	; 0x2de6 <xStreamBufferReceive+0x58>
	}
	else
	{
		xBytesToStoreMessageLength = 0;
    2de2:	1a 82       	std	Y+2, r1	; 0x02
    2de4:	19 82       	std	Y+1, r1	; 0x01
	}

	if( xTicksToWait != ( TickType_t ) 0 )
    2de6:	8f 85       	ldd	r24, Y+15	; 0x0f
    2de8:	98 89       	ldd	r25, Y+16	; 0x10
    2dea:	00 97       	sbiw	r24, 0x00	; 0
    2dec:	09 f4       	brne	.+2      	; 0x2df0 <xStreamBufferReceive+0x62>
    2dee:	3d c0       	rjmp	.+122    	; 0x2e6a <xStreamBufferReceive+0xdc>
	{
		/* Checking if there is data and clearing the notification state must be
		performed atomically. */
		taskENTER_CRITICAL();
    2df0:	0f b6       	in	r0, 0x3f	; 63
    2df2:	f8 94       	cli
    2df4:	0f 92       	push	r0
		{
			xBytesAvailable = prvBytesInBuffer( pxStreamBuffer );
    2df6:	8f 81       	ldd	r24, Y+7	; 0x07
    2df8:	98 85       	ldd	r25, Y+8	; 0x08
    2dfa:	0e 94 dc 1a 	call	0x35b8	; 0x35b8 <prvBytesInBuffer>
    2dfe:	9c 83       	std	Y+4, r25	; 0x04
    2e00:	8b 83       	std	Y+3, r24	; 0x03
			/* If this function was invoked by a message buffer read then
			xBytesToStoreMessageLength holds the number of bytes used to hold
			the length of the next discrete message.  If this function was
			invoked by a stream buffer read then xBytesToStoreMessageLength will
			be 0. */
			if( xBytesAvailable <= xBytesToStoreMessageLength )
    2e02:	2b 81       	ldd	r18, Y+3	; 0x03
    2e04:	3c 81       	ldd	r19, Y+4	; 0x04
    2e06:	89 81       	ldd	r24, Y+1	; 0x01
    2e08:	9a 81       	ldd	r25, Y+2	; 0x02
    2e0a:	82 17       	cp	r24, r18
    2e0c:	93 07       	cpc	r25, r19
    2e0e:	50 f0       	brcs	.+20     	; 0x2e24 <xStreamBufferReceive+0x96>
			{
				/* Clear notification state as going to wait for data. */
				( void ) xTaskNotifyStateClear( NULL );
    2e10:	80 e0       	ldi	r24, 0x00	; 0
    2e12:	90 e0       	ldi	r25, 0x00	; 0
    2e14:	0e 94 79 29 	call	0x52f2	; 0x52f2 <xTaskNotifyStateClear>

				/* Should only be one reader. */
				configASSERT( pxStreamBuffer->xTaskWaitingToReceive == NULL );
				pxStreamBuffer->xTaskWaitingToReceive = xTaskGetCurrentTaskHandle();
    2e18:	0e 94 15 24 	call	0x482a	; 0x482a <xTaskGetCurrentTaskHandle>
    2e1c:	ef 81       	ldd	r30, Y+7	; 0x07
    2e1e:	f8 85       	ldd	r31, Y+8	; 0x08
    2e20:	91 87       	std	Z+9, r25	; 0x09
    2e22:	80 87       	std	Z+8, r24	; 0x08
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		taskEXIT_CRITICAL();
    2e24:	0f 90       	pop	r0
    2e26:	0f be       	out	0x3f, r0	; 63

		if( xBytesAvailable <= xBytesToStoreMessageLength )
    2e28:	2b 81       	ldd	r18, Y+3	; 0x03
    2e2a:	3c 81       	ldd	r19, Y+4	; 0x04
    2e2c:	89 81       	ldd	r24, Y+1	; 0x01
    2e2e:	9a 81       	ldd	r25, Y+2	; 0x02
    2e30:	82 17       	cp	r24, r18
    2e32:	93 07       	cpc	r25, r19
    2e34:	00 f1       	brcs	.+64     	; 0x2e76 <xStreamBufferReceive+0xe8>
		{
			/* Wait for data to be available. */
			traceBLOCKING_ON_STREAM_BUFFER_RECEIVE( xStreamBuffer );
			( void ) xTaskNotifyWait( ( uint32_t ) 0, ( uint32_t ) 0, NULL, xTicksToWait );
    2e36:	ef 85       	ldd	r30, Y+15	; 0x0f
    2e38:	f8 89       	ldd	r31, Y+16	; 0x10
    2e3a:	60 e0       	ldi	r22, 0x00	; 0
    2e3c:	70 e0       	ldi	r23, 0x00	; 0
    2e3e:	80 e0       	ldi	r24, 0x00	; 0
    2e40:	90 e0       	ldi	r25, 0x00	; 0
    2e42:	20 e0       	ldi	r18, 0x00	; 0
    2e44:	30 e0       	ldi	r19, 0x00	; 0
    2e46:	40 e0       	ldi	r20, 0x00	; 0
    2e48:	50 e0       	ldi	r21, 0x00	; 0
    2e4a:	00 e0       	ldi	r16, 0x00	; 0
    2e4c:	10 e0       	ldi	r17, 0x00	; 0
    2e4e:	7f 01       	movw	r14, r30
    2e50:	0e 94 82 26 	call	0x4d04	; 0x4d04 <xTaskNotifyWait>
			pxStreamBuffer->xTaskWaitingToReceive = NULL;
    2e54:	ef 81       	ldd	r30, Y+7	; 0x07
    2e56:	f8 85       	ldd	r31, Y+8	; 0x08
    2e58:	11 86       	std	Z+9, r1	; 0x09
    2e5a:	10 86       	std	Z+8, r1	; 0x08

			/* Recheck the data available after blocking. */
			xBytesAvailable = prvBytesInBuffer( pxStreamBuffer );
    2e5c:	8f 81       	ldd	r24, Y+7	; 0x07
    2e5e:	98 85       	ldd	r25, Y+8	; 0x08
    2e60:	0e 94 dc 1a 	call	0x35b8	; 0x35b8 <prvBytesInBuffer>
    2e64:	9c 83       	std	Y+4, r25	; 0x04
    2e66:	8b 83       	std	Y+3, r24	; 0x03
    2e68:	06 c0       	rjmp	.+12     	; 0x2e76 <xStreamBufferReceive+0xe8>
			mtCOVERAGE_TEST_MARKER();
		}
	}
	else
	{
		xBytesAvailable = prvBytesInBuffer( pxStreamBuffer );
    2e6a:	8f 81       	ldd	r24, Y+7	; 0x07
    2e6c:	98 85       	ldd	r25, Y+8	; 0x08
    2e6e:	0e 94 dc 1a 	call	0x35b8	; 0x35b8 <prvBytesInBuffer>
    2e72:	9c 83       	std	Y+4, r25	; 0x04
    2e74:	8b 83       	std	Y+3, r24	; 0x03
	/* Whether receiving a discrete message (where xBytesToStoreMessageLength
	holds the number of bytes used to store the message length) or a stream of
	bytes (where xBytesToStoreMessageLength is zero), the number of bytes
	available must be greater than xBytesToStoreMessageLength to be able to
	read bytes from the buffer. */
	if( xBytesAvailable > xBytesToStoreMessageLength )
    2e76:	2b 81       	ldd	r18, Y+3	; 0x03
    2e78:	3c 81       	ldd	r19, Y+4	; 0x04
    2e7a:	89 81       	ldd	r24, Y+1	; 0x01
    2e7c:	9a 81       	ldd	r25, Y+2	; 0x02
    2e7e:	82 17       	cp	r24, r18
    2e80:	93 07       	cpc	r25, r19
    2e82:	80 f5       	brcc	.+96     	; 0x2ee4 <xStreamBufferReceive+0x156>
	{
		xReceivedLength = prvReadMessageFromBuffer( pxStreamBuffer, pvRxData, xBufferLengthBytes, xBytesAvailable, xBytesToStoreMessageLength );
    2e84:	8f 81       	ldd	r24, Y+7	; 0x07
    2e86:	98 85       	ldd	r25, Y+8	; 0x08
    2e88:	2b 85       	ldd	r18, Y+11	; 0x0b
    2e8a:	3c 85       	ldd	r19, Y+12	; 0x0c
    2e8c:	4d 85       	ldd	r20, Y+13	; 0x0d
    2e8e:	5e 85       	ldd	r21, Y+14	; 0x0e
    2e90:	eb 81       	ldd	r30, Y+3	; 0x03
    2e92:	fc 81       	ldd	r31, Y+4	; 0x04
    2e94:	a9 81       	ldd	r26, Y+1	; 0x01
    2e96:	ba 81       	ldd	r27, Y+2	; 0x02
    2e98:	b9 01       	movw	r22, r18
    2e9a:	9f 01       	movw	r18, r30
    2e9c:	8d 01       	movw	r16, r26
    2e9e:	0e 94 4b 18 	call	0x3096	; 0x3096 <prvReadMessageFromBuffer>
    2ea2:	9e 83       	std	Y+6, r25	; 0x06
    2ea4:	8d 83       	std	Y+5, r24	; 0x05

		/* Was a task waiting for space in the buffer? */
		if( xReceivedLength != ( size_t ) 0 )
    2ea6:	8d 81       	ldd	r24, Y+5	; 0x05
    2ea8:	9e 81       	ldd	r25, Y+6	; 0x06
    2eaa:	00 97       	sbiw	r24, 0x00	; 0
    2eac:	d9 f0       	breq	.+54     	; 0x2ee4 <xStreamBufferReceive+0x156>
		{
			traceSTREAM_BUFFER_RECEIVE( xStreamBuffer, xReceivedLength );
			sbRECEIVE_COMPLETED( pxStreamBuffer );
    2eae:	0e 94 44 1f 	call	0x3e88	; 0x3e88 <vTaskSuspendAll>
    2eb2:	ef 81       	ldd	r30, Y+7	; 0x07
    2eb4:	f8 85       	ldd	r31, Y+8	; 0x08
    2eb6:	82 85       	ldd	r24, Z+10	; 0x0a
    2eb8:	93 85       	ldd	r25, Z+11	; 0x0b
    2eba:	00 97       	sbiw	r24, 0x00	; 0
    2ebc:	89 f0       	breq	.+34     	; 0x2ee0 <xStreamBufferReceive+0x152>
    2ebe:	ef 81       	ldd	r30, Y+7	; 0x07
    2ec0:	f8 85       	ldd	r31, Y+8	; 0x08
    2ec2:	82 85       	ldd	r24, Z+10	; 0x0a
    2ec4:	93 85       	ldd	r25, Z+11	; 0x0b
    2ec6:	40 e0       	ldi	r20, 0x00	; 0
    2ec8:	50 e0       	ldi	r21, 0x00	; 0
    2eca:	60 e0       	ldi	r22, 0x00	; 0
    2ecc:	70 e0       	ldi	r23, 0x00	; 0
    2ece:	20 e0       	ldi	r18, 0x00	; 0
    2ed0:	00 e0       	ldi	r16, 0x00	; 0
    2ed2:	10 e0       	ldi	r17, 0x00	; 0
    2ed4:	0e 94 1e 27 	call	0x4e3c	; 0x4e3c <xTaskGenericNotify>
    2ed8:	ef 81       	ldd	r30, Y+7	; 0x07
    2eda:	f8 85       	ldd	r31, Y+8	; 0x08
    2edc:	13 86       	std	Z+11, r1	; 0x0b
    2ede:	12 86       	std	Z+10, r1	; 0x0a
    2ee0:	0e 94 50 1f 	call	0x3ea0	; 0x3ea0 <xTaskResumeAll>
	{
		traceSTREAM_BUFFER_RECEIVE_FAILED( xStreamBuffer );
		mtCOVERAGE_TEST_MARKER();
	}

	return xReceivedLength;
    2ee4:	8d 81       	ldd	r24, Y+5	; 0x05
    2ee6:	9e 81       	ldd	r25, Y+6	; 0x06
}
    2ee8:	60 96       	adiw	r28, 0x10	; 16
    2eea:	0f b6       	in	r0, 0x3f	; 63
    2eec:	f8 94       	cli
    2eee:	de bf       	out	0x3e, r29	; 62
    2ef0:	0f be       	out	0x3f, r0	; 63
    2ef2:	cd bf       	out	0x3d, r28	; 61
    2ef4:	cf 91       	pop	r28
    2ef6:	df 91       	pop	r29
    2ef8:	1f 91       	pop	r17
    2efa:	0f 91       	pop	r16
    2efc:	ff 90       	pop	r15
    2efe:	ef 90       	pop	r14
    2f00:	08 95       	ret

00002f02 <xStreamBufferNextMessageLengthBytes>:
/*-----------------------------------------------------------*/

size_t xStreamBufferNextMessageLengthBytes( StreamBufferHandle_t xStreamBuffer )
{
    2f02:	df 93       	push	r29
    2f04:	cf 93       	push	r28
    2f06:	cd b7       	in	r28, 0x3d	; 61
    2f08:	de b7       	in	r29, 0x3e	; 62
    2f0a:	2c 97       	sbiw	r28, 0x0c	; 12
    2f0c:	0f b6       	in	r0, 0x3f	; 63
    2f0e:	f8 94       	cli
    2f10:	de bf       	out	0x3e, r29	; 62
    2f12:	0f be       	out	0x3f, r0	; 63
    2f14:	cd bf       	out	0x3d, r28	; 61
    2f16:	9c 87       	std	Y+12, r25	; 0x0c
    2f18:	8b 87       	std	Y+11, r24	; 0x0b
StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
    2f1a:	8b 85       	ldd	r24, Y+11	; 0x0b
    2f1c:	9c 85       	ldd	r25, Y+12	; 0x0c
    2f1e:	98 87       	std	Y+8, r25	; 0x08
    2f20:	8f 83       	std	Y+7, r24	; 0x07
configMESSAGE_BUFFER_LENGTH_TYPE xTempReturn;

	configASSERT( pxStreamBuffer );

	/* Ensure the stream buffer is being used as a message buffer. */
	if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_MESSAGE_BUFFER ) != ( uint8_t ) 0 )
    2f22:	ef 81       	ldd	r30, Y+7	; 0x07
    2f24:	f8 85       	ldd	r31, Y+8	; 0x08
    2f26:	86 85       	ldd	r24, Z+14	; 0x0e
    2f28:	88 2f       	mov	r24, r24
    2f2a:	90 e0       	ldi	r25, 0x00	; 0
    2f2c:	81 70       	andi	r24, 0x01	; 1
    2f2e:	90 70       	andi	r25, 0x00	; 0
    2f30:	88 23       	and	r24, r24
    2f32:	61 f1       	breq	.+88     	; 0x2f8c <xStreamBufferNextMessageLengthBytes+0x8a>
	{
		xBytesAvailable = prvBytesInBuffer( pxStreamBuffer );
    2f34:	8f 81       	ldd	r24, Y+7	; 0x07
    2f36:	98 85       	ldd	r25, Y+8	; 0x08
    2f38:	0e 94 dc 1a 	call	0x35b8	; 0x35b8 <prvBytesInBuffer>
    2f3c:	9c 83       	std	Y+4, r25	; 0x04
    2f3e:	8b 83       	std	Y+3, r24	; 0x03
		if( xBytesAvailable > sbBYTES_TO_STORE_MESSAGE_LENGTH )
    2f40:	8b 81       	ldd	r24, Y+3	; 0x03
    2f42:	9c 81       	ldd	r25, Y+4	; 0x04
    2f44:	83 30       	cpi	r24, 0x03	; 3
    2f46:	91 05       	cpc	r25, r1
    2f48:	f0 f0       	brcs	.+60     	; 0x2f86 <xStreamBufferNextMessageLengthBytes+0x84>
			required to hold the length of the next message, so another message
			is available.  Return its length without removing the length bytes
			from the buffer.  A copy of the tail is stored so the buffer can be
			returned to its prior state as the message is not actually being
			removed from the buffer. */
			xOriginalTail = pxStreamBuffer->xTail;
    2f4a:	ef 81       	ldd	r30, Y+7	; 0x07
    2f4c:	f8 85       	ldd	r31, Y+8	; 0x08
    2f4e:	80 81       	ld	r24, Z
    2f50:	91 81       	ldd	r25, Z+1	; 0x01
    2f52:	9a 83       	std	Y+2, r25	; 0x02
    2f54:	89 83       	std	Y+1, r24	; 0x01
			( void ) prvReadBytesFromBuffer( pxStreamBuffer, ( uint8_t * ) &xTempReturn, sbBYTES_TO_STORE_MESSAGE_LENGTH, xBytesAvailable );
    2f56:	9e 01       	movw	r18, r28
    2f58:	27 5f       	subi	r18, 0xF7	; 247
    2f5a:	3f 4f       	sbci	r19, 0xFF	; 255
    2f5c:	8f 81       	ldd	r24, Y+7	; 0x07
    2f5e:	98 85       	ldd	r25, Y+8	; 0x08
    2f60:	eb 81       	ldd	r30, Y+3	; 0x03
    2f62:	fc 81       	ldd	r31, Y+4	; 0x04
    2f64:	b9 01       	movw	r22, r18
    2f66:	42 e0       	ldi	r20, 0x02	; 2
    2f68:	50 e0       	ldi	r21, 0x00	; 0
    2f6a:	9f 01       	movw	r18, r30
    2f6c:	0e 94 2f 1a 	call	0x345e	; 0x345e <prvReadBytesFromBuffer>
			xReturn = ( size_t ) xTempReturn;
    2f70:	89 85       	ldd	r24, Y+9	; 0x09
    2f72:	9a 85       	ldd	r25, Y+10	; 0x0a
    2f74:	9e 83       	std	Y+6, r25	; 0x06
    2f76:	8d 83       	std	Y+5, r24	; 0x05
			pxStreamBuffer->xTail = xOriginalTail;
    2f78:	ef 81       	ldd	r30, Y+7	; 0x07
    2f7a:	f8 85       	ldd	r31, Y+8	; 0x08
    2f7c:	89 81       	ldd	r24, Y+1	; 0x01
    2f7e:	9a 81       	ldd	r25, Y+2	; 0x02
    2f80:	91 83       	std	Z+1, r25	; 0x01
    2f82:	80 83       	st	Z, r24
    2f84:	05 c0       	rjmp	.+10     	; 0x2f90 <xStreamBufferNextMessageLengthBytes+0x8e>
			/* The minimum amount of bytes in a message buffer is
			( sbBYTES_TO_STORE_MESSAGE_LENGTH + 1 ), so if xBytesAvailable is
			less than sbBYTES_TO_STORE_MESSAGE_LENGTH the only other valid
			value is 0. */
			configASSERT( xBytesAvailable == 0 );
			xReturn = 0;
    2f86:	1e 82       	std	Y+6, r1	; 0x06
    2f88:	1d 82       	std	Y+5, r1	; 0x05
    2f8a:	02 c0       	rjmp	.+4      	; 0x2f90 <xStreamBufferNextMessageLengthBytes+0x8e>
		}
	}
	else
	{
		xReturn = 0;
    2f8c:	1e 82       	std	Y+6, r1	; 0x06
    2f8e:	1d 82       	std	Y+5, r1	; 0x05
	}

	return xReturn;
    2f90:	8d 81       	ldd	r24, Y+5	; 0x05
    2f92:	9e 81       	ldd	r25, Y+6	; 0x06
}
    2f94:	2c 96       	adiw	r28, 0x0c	; 12
    2f96:	0f b6       	in	r0, 0x3f	; 63
    2f98:	f8 94       	cli
    2f9a:	de bf       	out	0x3e, r29	; 62
    2f9c:	0f be       	out	0x3f, r0	; 63
    2f9e:	cd bf       	out	0x3d, r28	; 61
    2fa0:	cf 91       	pop	r28
    2fa2:	df 91       	pop	r29
    2fa4:	08 95       	ret

00002fa6 <xStreamBufferReceiveFromISR>:

size_t xStreamBufferReceiveFromISR( StreamBufferHandle_t xStreamBuffer,
									void *pvRxData,
									size_t xBufferLengthBytes,
									BaseType_t * const pxHigherPriorityTaskWoken )
{
    2fa6:	ef 92       	push	r14
    2fa8:	ff 92       	push	r15
    2faa:	0f 93       	push	r16
    2fac:	1f 93       	push	r17
    2fae:	df 93       	push	r29
    2fb0:	cf 93       	push	r28
    2fb2:	cd b7       	in	r28, 0x3d	; 61
    2fb4:	de b7       	in	r29, 0x3e	; 62
    2fb6:	61 97       	sbiw	r28, 0x11	; 17
    2fb8:	0f b6       	in	r0, 0x3f	; 63
    2fba:	f8 94       	cli
    2fbc:	de bf       	out	0x3e, r29	; 62
    2fbe:	0f be       	out	0x3f, r0	; 63
    2fc0:	cd bf       	out	0x3d, r28	; 61
    2fc2:	9b 87       	std	Y+11, r25	; 0x0b
    2fc4:	8a 87       	std	Y+10, r24	; 0x0a
    2fc6:	7d 87       	std	Y+13, r23	; 0x0d
    2fc8:	6c 87       	std	Y+12, r22	; 0x0c
    2fca:	5f 87       	std	Y+15, r21	; 0x0f
    2fcc:	4e 87       	std	Y+14, r20	; 0x0e
    2fce:	39 8b       	std	Y+17, r19	; 0x11
    2fd0:	28 8b       	std	Y+16, r18	; 0x10
StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
    2fd2:	8a 85       	ldd	r24, Y+10	; 0x0a
    2fd4:	9b 85       	ldd	r25, Y+11	; 0x0b
    2fd6:	99 87       	std	Y+9, r25	; 0x09
    2fd8:	88 87       	std	Y+8, r24	; 0x08
size_t xReceivedLength = 0, xBytesAvailable, xBytesToStoreMessageLength;
    2fda:	1f 82       	std	Y+7, r1	; 0x07
    2fdc:	1e 82       	std	Y+6, r1	; 0x06
	/* This receive function is used by both message buffers, which store
	discrete messages, and stream buffers, which store a continuous stream of
	bytes.  Discrete messages include an additional
	sbBYTES_TO_STORE_MESSAGE_LENGTH bytes that hold the length of the
	message. */
	if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_MESSAGE_BUFFER ) != ( uint8_t ) 0 )
    2fde:	e8 85       	ldd	r30, Y+8	; 0x08
    2fe0:	f9 85       	ldd	r31, Y+9	; 0x09
    2fe2:	86 85       	ldd	r24, Z+14	; 0x0e
    2fe4:	88 2f       	mov	r24, r24
    2fe6:	90 e0       	ldi	r25, 0x00	; 0
    2fe8:	81 70       	andi	r24, 0x01	; 1
    2fea:	90 70       	andi	r25, 0x00	; 0
    2fec:	88 23       	and	r24, r24
    2fee:	29 f0       	breq	.+10     	; 0x2ffa <xStreamBufferReceiveFromISR+0x54>
	{
		xBytesToStoreMessageLength = sbBYTES_TO_STORE_MESSAGE_LENGTH;
    2ff0:	82 e0       	ldi	r24, 0x02	; 2
    2ff2:	90 e0       	ldi	r25, 0x00	; 0
    2ff4:	9b 83       	std	Y+3, r25	; 0x03
    2ff6:	8a 83       	std	Y+2, r24	; 0x02
    2ff8:	02 c0       	rjmp	.+4      	; 0x2ffe <xStreamBufferReceiveFromISR+0x58>
	}
	else
	{
		xBytesToStoreMessageLength = 0;
    2ffa:	1b 82       	std	Y+3, r1	; 0x03
    2ffc:	1a 82       	std	Y+2, r1	; 0x02
	}

	xBytesAvailable = prvBytesInBuffer( pxStreamBuffer );
    2ffe:	88 85       	ldd	r24, Y+8	; 0x08
    3000:	99 85       	ldd	r25, Y+9	; 0x09
    3002:	0e 94 dc 1a 	call	0x35b8	; 0x35b8 <prvBytesInBuffer>
    3006:	9d 83       	std	Y+5, r25	; 0x05
    3008:	8c 83       	std	Y+4, r24	; 0x04
	/* Whether receiving a discrete message (where xBytesToStoreMessageLength
	holds the number of bytes used to store the message length) or a stream of
	bytes (where xBytesToStoreMessageLength is zero), the number of bytes
	available must be greater than xBytesToStoreMessageLength to be able to
	read bytes from the buffer. */
	if( xBytesAvailable > xBytesToStoreMessageLength )
    300a:	2c 81       	ldd	r18, Y+4	; 0x04
    300c:	3d 81       	ldd	r19, Y+5	; 0x05
    300e:	8a 81       	ldd	r24, Y+2	; 0x02
    3010:	9b 81       	ldd	r25, Y+3	; 0x03
    3012:	82 17       	cp	r24, r18
    3014:	93 07       	cpc	r25, r19
    3016:	80 f5       	brcc	.+96     	; 0x3078 <xStreamBufferReceiveFromISR+0xd2>
	{
		xReceivedLength = prvReadMessageFromBuffer( pxStreamBuffer, pvRxData, xBufferLengthBytes, xBytesAvailable, xBytesToStoreMessageLength );
    3018:	88 85       	ldd	r24, Y+8	; 0x08
    301a:	99 85       	ldd	r25, Y+9	; 0x09
    301c:	2c 85       	ldd	r18, Y+12	; 0x0c
    301e:	3d 85       	ldd	r19, Y+13	; 0x0d
    3020:	4e 85       	ldd	r20, Y+14	; 0x0e
    3022:	5f 85       	ldd	r21, Y+15	; 0x0f
    3024:	ec 81       	ldd	r30, Y+4	; 0x04
    3026:	fd 81       	ldd	r31, Y+5	; 0x05
    3028:	aa 81       	ldd	r26, Y+2	; 0x02
    302a:	bb 81       	ldd	r27, Y+3	; 0x03
    302c:	b9 01       	movw	r22, r18
    302e:	9f 01       	movw	r18, r30
    3030:	8d 01       	movw	r16, r26
    3032:	0e 94 4b 18 	call	0x3096	; 0x3096 <prvReadMessageFromBuffer>
    3036:	9f 83       	std	Y+7, r25	; 0x07
    3038:	8e 83       	std	Y+6, r24	; 0x06

		/* Was a task waiting for space in the buffer? */
		if( xReceivedLength != ( size_t ) 0 )
    303a:	8e 81       	ldd	r24, Y+6	; 0x06
    303c:	9f 81       	ldd	r25, Y+7	; 0x07
    303e:	00 97       	sbiw	r24, 0x00	; 0
    3040:	d9 f0       	breq	.+54     	; 0x3078 <xStreamBufferReceiveFromISR+0xd2>
		{
			sbRECEIVE_COMPLETED_FROM_ISR( pxStreamBuffer, pxHigherPriorityTaskWoken );
    3042:	19 82       	std	Y+1, r1	; 0x01
    3044:	e8 85       	ldd	r30, Y+8	; 0x08
    3046:	f9 85       	ldd	r31, Y+9	; 0x09
    3048:	82 85       	ldd	r24, Z+10	; 0x0a
    304a:	93 85       	ldd	r25, Z+11	; 0x0b
    304c:	00 97       	sbiw	r24, 0x00	; 0
    304e:	a1 f0       	breq	.+40     	; 0x3078 <xStreamBufferReceiveFromISR+0xd2>
    3050:	e8 85       	ldd	r30, Y+8	; 0x08
    3052:	f9 85       	ldd	r31, Y+9	; 0x09
    3054:	82 85       	ldd	r24, Z+10	; 0x0a
    3056:	93 85       	ldd	r25, Z+11	; 0x0b
    3058:	e8 89       	ldd	r30, Y+16	; 0x10
    305a:	f9 89       	ldd	r31, Y+17	; 0x11
    305c:	40 e0       	ldi	r20, 0x00	; 0
    305e:	50 e0       	ldi	r21, 0x00	; 0
    3060:	60 e0       	ldi	r22, 0x00	; 0
    3062:	70 e0       	ldi	r23, 0x00	; 0
    3064:	20 e0       	ldi	r18, 0x00	; 0
    3066:	00 e0       	ldi	r16, 0x00	; 0
    3068:	10 e0       	ldi	r17, 0x00	; 0
    306a:	7f 01       	movw	r14, r30
    306c:	0e 94 fb 27 	call	0x4ff6	; 0x4ff6 <xTaskGenericNotifyFromISR>
    3070:	e8 85       	ldd	r30, Y+8	; 0x08
    3072:	f9 85       	ldd	r31, Y+9	; 0x09
    3074:	13 86       	std	Z+11, r1	; 0x0b
    3076:	12 86       	std	Z+10, r1	; 0x0a
		mtCOVERAGE_TEST_MARKER();
	}

	traceSTREAM_BUFFER_RECEIVE_FROM_ISR( xStreamBuffer, xReceivedLength );

	return xReceivedLength;
    3078:	8e 81       	ldd	r24, Y+6	; 0x06
    307a:	9f 81       	ldd	r25, Y+7	; 0x07
}
    307c:	61 96       	adiw	r28, 0x11	; 17
    307e:	0f b6       	in	r0, 0x3f	; 63
    3080:	f8 94       	cli
    3082:	de bf       	out	0x3e, r29	; 62
    3084:	0f be       	out	0x3f, r0	; 63
    3086:	cd bf       	out	0x3d, r28	; 61
    3088:	cf 91       	pop	r28
    308a:	df 91       	pop	r29
    308c:	1f 91       	pop	r17
    308e:	0f 91       	pop	r16
    3090:	ff 90       	pop	r15
    3092:	ef 90       	pop	r14
    3094:	08 95       	ret

00003096 <prvReadMessageFromBuffer>:
static size_t prvReadMessageFromBuffer( StreamBuffer_t *pxStreamBuffer,
										void *pvRxData,
										size_t xBufferLengthBytes,
										size_t xBytesAvailable,
										size_t xBytesToStoreMessageLength )
{
    3096:	0f 93       	push	r16
    3098:	1f 93       	push	r17
    309a:	df 93       	push	r29
    309c:	cf 93       	push	r28
    309e:	cd b7       	in	r28, 0x3d	; 61
    30a0:	de b7       	in	r29, 0x3e	; 62
    30a2:	62 97       	sbiw	r28, 0x12	; 18
    30a4:	0f b6       	in	r0, 0x3f	; 63
    30a6:	f8 94       	cli
    30a8:	de bf       	out	0x3e, r29	; 62
    30aa:	0f be       	out	0x3f, r0	; 63
    30ac:	cd bf       	out	0x3d, r28	; 61
    30ae:	9a 87       	std	Y+10, r25	; 0x0a
    30b0:	89 87       	std	Y+9, r24	; 0x09
    30b2:	7c 87       	std	Y+12, r23	; 0x0c
    30b4:	6b 87       	std	Y+11, r22	; 0x0b
    30b6:	5e 87       	std	Y+14, r21	; 0x0e
    30b8:	4d 87       	std	Y+13, r20	; 0x0d
    30ba:	38 8b       	std	Y+16, r19	; 0x10
    30bc:	2f 87       	std	Y+15, r18	; 0x0f
    30be:	1a 8b       	std	Y+18, r17	; 0x12
    30c0:	09 8b       	std	Y+17, r16	; 0x11
size_t xOriginalTail, xReceivedLength, xNextMessageLength;
configMESSAGE_BUFFER_LENGTH_TYPE xTempNextMessageLength;

	if( xBytesToStoreMessageLength != ( size_t ) 0 )
    30c2:	89 89       	ldd	r24, Y+17	; 0x11
    30c4:	9a 89       	ldd	r25, Y+18	; 0x12
    30c6:	00 97       	sbiw	r24, 0x00	; 0
    30c8:	91 f1       	breq	.+100    	; 0x312e <prvReadMessageFromBuffer+0x98>
	{
		/* A discrete message is being received.  First receive the length
		of the message.  A copy of the tail is stored so the buffer can be
		returned to its prior state if the length of the message is too
		large for the provided buffer. */
		xOriginalTail = pxStreamBuffer->xTail;
    30ca:	e9 85       	ldd	r30, Y+9	; 0x09
    30cc:	fa 85       	ldd	r31, Y+10	; 0x0a
    30ce:	80 81       	ld	r24, Z
    30d0:	91 81       	ldd	r25, Z+1	; 0x01
    30d2:	9e 83       	std	Y+6, r25	; 0x06
    30d4:	8d 83       	std	Y+5, r24	; 0x05
		( void ) prvReadBytesFromBuffer( pxStreamBuffer, ( uint8_t * ) &xTempNextMessageLength, xBytesToStoreMessageLength, xBytesAvailable );
    30d6:	ae 01       	movw	r20, r28
    30d8:	49 5f       	subi	r20, 0xF9	; 249
    30da:	5f 4f       	sbci	r21, 0xFF	; 255
    30dc:	89 85       	ldd	r24, Y+9	; 0x09
    30de:	9a 85       	ldd	r25, Y+10	; 0x0a
    30e0:	29 89       	ldd	r18, Y+17	; 0x11
    30e2:	3a 89       	ldd	r19, Y+18	; 0x12
    30e4:	ef 85       	ldd	r30, Y+15	; 0x0f
    30e6:	f8 89       	ldd	r31, Y+16	; 0x10
    30e8:	ba 01       	movw	r22, r20
    30ea:	a9 01       	movw	r20, r18
    30ec:	9f 01       	movw	r18, r30
    30ee:	0e 94 2f 1a 	call	0x345e	; 0x345e <prvReadBytesFromBuffer>
		xNextMessageLength = ( size_t ) xTempNextMessageLength;
    30f2:	8f 81       	ldd	r24, Y+7	; 0x07
    30f4:	98 85       	ldd	r25, Y+8	; 0x08
    30f6:	9a 83       	std	Y+2, r25	; 0x02
    30f8:	89 83       	std	Y+1, r24	; 0x01

		/* Reduce the number of bytes available by the number of bytes just
		read out. */
		xBytesAvailable -= xBytesToStoreMessageLength;
    30fa:	2f 85       	ldd	r18, Y+15	; 0x0f
    30fc:	38 89       	ldd	r19, Y+16	; 0x10
    30fe:	89 89       	ldd	r24, Y+17	; 0x11
    3100:	9a 89       	ldd	r25, Y+18	; 0x12
    3102:	a9 01       	movw	r20, r18
    3104:	48 1b       	sub	r20, r24
    3106:	59 0b       	sbc	r21, r25
    3108:	ca 01       	movw	r24, r20
    310a:	98 8b       	std	Y+16, r25	; 0x10
    310c:	8f 87       	std	Y+15, r24	; 0x0f

		/* Check there is enough space in the buffer provided by the
		user. */
		if( xNextMessageLength > xBufferLengthBytes )
    310e:	29 81       	ldd	r18, Y+1	; 0x01
    3110:	3a 81       	ldd	r19, Y+2	; 0x02
    3112:	8d 85       	ldd	r24, Y+13	; 0x0d
    3114:	9e 85       	ldd	r25, Y+14	; 0x0e
    3116:	82 17       	cp	r24, r18
    3118:	93 07       	cpc	r25, r19
    311a:	68 f4       	brcc	.+26     	; 0x3136 <prvReadMessageFromBuffer+0xa0>
		{
			/* The user has provided insufficient space to read the message
			so return the buffer to its previous state (so the length of
			the message is in the buffer again). */
			pxStreamBuffer->xTail = xOriginalTail;
    311c:	e9 85       	ldd	r30, Y+9	; 0x09
    311e:	fa 85       	ldd	r31, Y+10	; 0x0a
    3120:	8d 81       	ldd	r24, Y+5	; 0x05
    3122:	9e 81       	ldd	r25, Y+6	; 0x06
    3124:	91 83       	std	Z+1, r25	; 0x01
    3126:	80 83       	st	Z, r24
			xNextMessageLength = 0;
    3128:	1a 82       	std	Y+2, r1	; 0x02
    312a:	19 82       	std	Y+1, r1	; 0x01
    312c:	04 c0       	rjmp	.+8      	; 0x3136 <prvReadMessageFromBuffer+0xa0>
	}
	else
	{
		/* A stream of bytes is being received (as opposed to a discrete
		message), so read as many bytes as possible. */
		xNextMessageLength = xBufferLengthBytes;
    312e:	8d 85       	ldd	r24, Y+13	; 0x0d
    3130:	9e 85       	ldd	r25, Y+14	; 0x0e
    3132:	9a 83       	std	Y+2, r25	; 0x02
    3134:	89 83       	std	Y+1, r24	; 0x01
	}

	/* Read the actual data. */
	xReceivedLength = prvReadBytesFromBuffer( pxStreamBuffer, ( uint8_t * ) pvRxData, xNextMessageLength, xBytesAvailable ); /*lint !e9079 Data storage area is implemented as uint8_t array for ease of sizing, indexing and alignment. */
    3136:	4b 85       	ldd	r20, Y+11	; 0x0b
    3138:	5c 85       	ldd	r21, Y+12	; 0x0c
    313a:	89 85       	ldd	r24, Y+9	; 0x09
    313c:	9a 85       	ldd	r25, Y+10	; 0x0a
    313e:	29 81       	ldd	r18, Y+1	; 0x01
    3140:	3a 81       	ldd	r19, Y+2	; 0x02
    3142:	ef 85       	ldd	r30, Y+15	; 0x0f
    3144:	f8 89       	ldd	r31, Y+16	; 0x10
    3146:	ba 01       	movw	r22, r20
    3148:	a9 01       	movw	r20, r18
    314a:	9f 01       	movw	r18, r30
    314c:	0e 94 2f 1a 	call	0x345e	; 0x345e <prvReadBytesFromBuffer>
    3150:	9c 83       	std	Y+4, r25	; 0x04
    3152:	8b 83       	std	Y+3, r24	; 0x03

	return xReceivedLength;
    3154:	8b 81       	ldd	r24, Y+3	; 0x03
    3156:	9c 81       	ldd	r25, Y+4	; 0x04
}
    3158:	62 96       	adiw	r28, 0x12	; 18
    315a:	0f b6       	in	r0, 0x3f	; 63
    315c:	f8 94       	cli
    315e:	de bf       	out	0x3e, r29	; 62
    3160:	0f be       	out	0x3f, r0	; 63
    3162:	cd bf       	out	0x3d, r28	; 61
    3164:	cf 91       	pop	r28
    3166:	df 91       	pop	r29
    3168:	1f 91       	pop	r17
    316a:	0f 91       	pop	r16
    316c:	08 95       	ret

0000316e <xStreamBufferIsEmpty>:
/*-----------------------------------------------------------*/

BaseType_t xStreamBufferIsEmpty( StreamBufferHandle_t xStreamBuffer )
{
    316e:	df 93       	push	r29
    3170:	cf 93       	push	r28
    3172:	cd b7       	in	r28, 0x3d	; 61
    3174:	de b7       	in	r29, 0x3e	; 62
    3176:	27 97       	sbiw	r28, 0x07	; 7
    3178:	0f b6       	in	r0, 0x3f	; 63
    317a:	f8 94       	cli
    317c:	de bf       	out	0x3e, r29	; 62
    317e:	0f be       	out	0x3f, r0	; 63
    3180:	cd bf       	out	0x3d, r28	; 61
    3182:	9f 83       	std	Y+7, r25	; 0x07
    3184:	8e 83       	std	Y+6, r24	; 0x06
const StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
    3186:	8e 81       	ldd	r24, Y+6	; 0x06
    3188:	9f 81       	ldd	r25, Y+7	; 0x07
    318a:	9d 83       	std	Y+5, r25	; 0x05
    318c:	8c 83       	std	Y+4, r24	; 0x04
size_t xTail;

	configASSERT( pxStreamBuffer );

	/* True if no bytes are available. */
	xTail = pxStreamBuffer->xTail;
    318e:	ec 81       	ldd	r30, Y+4	; 0x04
    3190:	fd 81       	ldd	r31, Y+5	; 0x05
    3192:	80 81       	ld	r24, Z
    3194:	91 81       	ldd	r25, Z+1	; 0x01
    3196:	9a 83       	std	Y+2, r25	; 0x02
    3198:	89 83       	std	Y+1, r24	; 0x01
	if( pxStreamBuffer->xHead == xTail )
    319a:	ec 81       	ldd	r30, Y+4	; 0x04
    319c:	fd 81       	ldd	r31, Y+5	; 0x05
    319e:	22 81       	ldd	r18, Z+2	; 0x02
    31a0:	33 81       	ldd	r19, Z+3	; 0x03
    31a2:	89 81       	ldd	r24, Y+1	; 0x01
    31a4:	9a 81       	ldd	r25, Y+2	; 0x02
    31a6:	28 17       	cp	r18, r24
    31a8:	39 07       	cpc	r19, r25
    31aa:	19 f4       	brne	.+6      	; 0x31b2 <xStreamBufferIsEmpty+0x44>
	{
		xReturn = pdTRUE;
    31ac:	81 e0       	ldi	r24, 0x01	; 1
    31ae:	8b 83       	std	Y+3, r24	; 0x03
    31b0:	01 c0       	rjmp	.+2      	; 0x31b4 <xStreamBufferIsEmpty+0x46>
	}
	else
	{
		xReturn = pdFALSE;
    31b2:	1b 82       	std	Y+3, r1	; 0x03
	}

	return xReturn;
    31b4:	8b 81       	ldd	r24, Y+3	; 0x03
}
    31b6:	27 96       	adiw	r28, 0x07	; 7
    31b8:	0f b6       	in	r0, 0x3f	; 63
    31ba:	f8 94       	cli
    31bc:	de bf       	out	0x3e, r29	; 62
    31be:	0f be       	out	0x3f, r0	; 63
    31c0:	cd bf       	out	0x3d, r28	; 61
    31c2:	cf 91       	pop	r28
    31c4:	df 91       	pop	r29
    31c6:	08 95       	ret

000031c8 <xStreamBufferIsFull>:
/*-----------------------------------------------------------*/

BaseType_t xStreamBufferIsFull( StreamBufferHandle_t xStreamBuffer )
{
    31c8:	df 93       	push	r29
    31ca:	cf 93       	push	r28
    31cc:	cd b7       	in	r28, 0x3d	; 61
    31ce:	de b7       	in	r29, 0x3e	; 62
    31d0:	27 97       	sbiw	r28, 0x07	; 7
    31d2:	0f b6       	in	r0, 0x3f	; 63
    31d4:	f8 94       	cli
    31d6:	de bf       	out	0x3e, r29	; 62
    31d8:	0f be       	out	0x3f, r0	; 63
    31da:	cd bf       	out	0x3d, r28	; 61
    31dc:	9f 83       	std	Y+7, r25	; 0x07
    31de:	8e 83       	std	Y+6, r24	; 0x06
BaseType_t xReturn;
size_t xBytesToStoreMessageLength;
const StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
    31e0:	8e 81       	ldd	r24, Y+6	; 0x06
    31e2:	9f 81       	ldd	r25, Y+7	; 0x07
    31e4:	9a 83       	std	Y+2, r25	; 0x02
    31e6:	89 83       	std	Y+1, r24	; 0x01

	/* This generic version of the receive function is used by both message
	buffers, which store discrete messages, and stream buffers, which store a
	continuous stream of bytes.  Discrete messages include an additional
	sbBYTES_TO_STORE_MESSAGE_LENGTH bytes that hold the length of the message. */
	if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_MESSAGE_BUFFER ) != ( uint8_t ) 0 )
    31e8:	e9 81       	ldd	r30, Y+1	; 0x01
    31ea:	fa 81       	ldd	r31, Y+2	; 0x02
    31ec:	86 85       	ldd	r24, Z+14	; 0x0e
    31ee:	88 2f       	mov	r24, r24
    31f0:	90 e0       	ldi	r25, 0x00	; 0
    31f2:	81 70       	andi	r24, 0x01	; 1
    31f4:	90 70       	andi	r25, 0x00	; 0
    31f6:	88 23       	and	r24, r24
    31f8:	29 f0       	breq	.+10     	; 0x3204 <xStreamBufferIsFull+0x3c>
	{
		xBytesToStoreMessageLength = sbBYTES_TO_STORE_MESSAGE_LENGTH;
    31fa:	82 e0       	ldi	r24, 0x02	; 2
    31fc:	90 e0       	ldi	r25, 0x00	; 0
    31fe:	9c 83       	std	Y+4, r25	; 0x04
    3200:	8b 83       	std	Y+3, r24	; 0x03
    3202:	02 c0       	rjmp	.+4      	; 0x3208 <xStreamBufferIsFull+0x40>
	}
	else
	{
		xBytesToStoreMessageLength = 0;
    3204:	1c 82       	std	Y+4, r1	; 0x04
    3206:	1b 82       	std	Y+3, r1	; 0x03
	}

	/* True if the available space equals zero. */
	if( xStreamBufferSpacesAvailable( xStreamBuffer ) <= xBytesToStoreMessageLength )
    3208:	8e 81       	ldd	r24, Y+6	; 0x06
    320a:	9f 81       	ldd	r25, Y+7	; 0x07
    320c:	0e 94 ac 14 	call	0x2958	; 0x2958 <xStreamBufferSpacesAvailable>
    3210:	9c 01       	movw	r18, r24
    3212:	8b 81       	ldd	r24, Y+3	; 0x03
    3214:	9c 81       	ldd	r25, Y+4	; 0x04
    3216:	82 17       	cp	r24, r18
    3218:	93 07       	cpc	r25, r19
    321a:	18 f0       	brcs	.+6      	; 0x3222 <xStreamBufferIsFull+0x5a>
	{
		xReturn = pdTRUE;
    321c:	81 e0       	ldi	r24, 0x01	; 1
    321e:	8d 83       	std	Y+5, r24	; 0x05
    3220:	01 c0       	rjmp	.+2      	; 0x3224 <xStreamBufferIsFull+0x5c>
	}
	else
	{
		xReturn = pdFALSE;
    3222:	1d 82       	std	Y+5, r1	; 0x05
	}

	return xReturn;
    3224:	8d 81       	ldd	r24, Y+5	; 0x05
}
    3226:	27 96       	adiw	r28, 0x07	; 7
    3228:	0f b6       	in	r0, 0x3f	; 63
    322a:	f8 94       	cli
    322c:	de bf       	out	0x3e, r29	; 62
    322e:	0f be       	out	0x3f, r0	; 63
    3230:	cd bf       	out	0x3d, r28	; 61
    3232:	cf 91       	pop	r28
    3234:	df 91       	pop	r29
    3236:	08 95       	ret

00003238 <xStreamBufferSendCompletedFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xStreamBufferSendCompletedFromISR( StreamBufferHandle_t xStreamBuffer, BaseType_t *pxHigherPriorityTaskWoken )
{
    3238:	ef 92       	push	r14
    323a:	ff 92       	push	r15
    323c:	0f 93       	push	r16
    323e:	1f 93       	push	r17
    3240:	df 93       	push	r29
    3242:	cf 93       	push	r28
    3244:	cd b7       	in	r28, 0x3d	; 61
    3246:	de b7       	in	r29, 0x3e	; 62
    3248:	28 97       	sbiw	r28, 0x08	; 8
    324a:	0f b6       	in	r0, 0x3f	; 63
    324c:	f8 94       	cli
    324e:	de bf       	out	0x3e, r29	; 62
    3250:	0f be       	out	0x3f, r0	; 63
    3252:	cd bf       	out	0x3d, r28	; 61
    3254:	9e 83       	std	Y+6, r25	; 0x06
    3256:	8d 83       	std	Y+5, r24	; 0x05
    3258:	78 87       	std	Y+8, r23	; 0x08
    325a:	6f 83       	std	Y+7, r22	; 0x07
StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
    325c:	8d 81       	ldd	r24, Y+5	; 0x05
    325e:	9e 81       	ldd	r25, Y+6	; 0x06
    3260:	9c 83       	std	Y+4, r25	; 0x04
    3262:	8b 83       	std	Y+3, r24	; 0x03
BaseType_t xReturn;
UBaseType_t uxSavedInterruptStatus;

	configASSERT( pxStreamBuffer );

	uxSavedInterruptStatus = ( UBaseType_t ) portSET_INTERRUPT_MASK_FROM_ISR();
    3264:	19 82       	std	Y+1, r1	; 0x01
	{
		if( ( pxStreamBuffer )->xTaskWaitingToReceive != NULL )
    3266:	eb 81       	ldd	r30, Y+3	; 0x03
    3268:	fc 81       	ldd	r31, Y+4	; 0x04
    326a:	80 85       	ldd	r24, Z+8	; 0x08
    326c:	91 85       	ldd	r25, Z+9	; 0x09
    326e:	00 97       	sbiw	r24, 0x00	; 0
    3270:	b9 f0       	breq	.+46     	; 0x32a0 <xStreamBufferSendCompletedFromISR+0x68>
		{
			( void ) xTaskNotifyFromISR( ( pxStreamBuffer )->xTaskWaitingToReceive,
    3272:	eb 81       	ldd	r30, Y+3	; 0x03
    3274:	fc 81       	ldd	r31, Y+4	; 0x04
    3276:	80 85       	ldd	r24, Z+8	; 0x08
    3278:	91 85       	ldd	r25, Z+9	; 0x09
    327a:	ef 81       	ldd	r30, Y+7	; 0x07
    327c:	f8 85       	ldd	r31, Y+8	; 0x08
    327e:	40 e0       	ldi	r20, 0x00	; 0
    3280:	50 e0       	ldi	r21, 0x00	; 0
    3282:	60 e0       	ldi	r22, 0x00	; 0
    3284:	70 e0       	ldi	r23, 0x00	; 0
    3286:	20 e0       	ldi	r18, 0x00	; 0
    3288:	00 e0       	ldi	r16, 0x00	; 0
    328a:	10 e0       	ldi	r17, 0x00	; 0
    328c:	7f 01       	movw	r14, r30
    328e:	0e 94 fb 27 	call	0x4ff6	; 0x4ff6 <xTaskGenericNotifyFromISR>
										 ( uint32_t ) 0,
										 eNoAction,
										 pxHigherPriorityTaskWoken );
			( pxStreamBuffer )->xTaskWaitingToReceive = NULL;
    3292:	eb 81       	ldd	r30, Y+3	; 0x03
    3294:	fc 81       	ldd	r31, Y+4	; 0x04
    3296:	11 86       	std	Z+9, r1	; 0x09
    3298:	10 86       	std	Z+8, r1	; 0x08
			xReturn = pdTRUE;
    329a:	81 e0       	ldi	r24, 0x01	; 1
    329c:	8a 83       	std	Y+2, r24	; 0x02
    329e:	01 c0       	rjmp	.+2      	; 0x32a2 <xStreamBufferSendCompletedFromISR+0x6a>
		}
		else
		{
			xReturn = pdFALSE;
    32a0:	1a 82       	std	Y+2, r1	; 0x02
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
    32a2:	8a 81       	ldd	r24, Y+2	; 0x02
}
    32a4:	28 96       	adiw	r28, 0x08	; 8
    32a6:	0f b6       	in	r0, 0x3f	; 63
    32a8:	f8 94       	cli
    32aa:	de bf       	out	0x3e, r29	; 62
    32ac:	0f be       	out	0x3f, r0	; 63
    32ae:	cd bf       	out	0x3d, r28	; 61
    32b0:	cf 91       	pop	r28
    32b2:	df 91       	pop	r29
    32b4:	1f 91       	pop	r17
    32b6:	0f 91       	pop	r16
    32b8:	ff 90       	pop	r15
    32ba:	ef 90       	pop	r14
    32bc:	08 95       	ret

000032be <xStreamBufferReceiveCompletedFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xStreamBufferReceiveCompletedFromISR( StreamBufferHandle_t xStreamBuffer, BaseType_t *pxHigherPriorityTaskWoken )
{
    32be:	ef 92       	push	r14
    32c0:	ff 92       	push	r15
    32c2:	0f 93       	push	r16
    32c4:	1f 93       	push	r17
    32c6:	df 93       	push	r29
    32c8:	cf 93       	push	r28
    32ca:	cd b7       	in	r28, 0x3d	; 61
    32cc:	de b7       	in	r29, 0x3e	; 62
    32ce:	28 97       	sbiw	r28, 0x08	; 8
    32d0:	0f b6       	in	r0, 0x3f	; 63
    32d2:	f8 94       	cli
    32d4:	de bf       	out	0x3e, r29	; 62
    32d6:	0f be       	out	0x3f, r0	; 63
    32d8:	cd bf       	out	0x3d, r28	; 61
    32da:	9e 83       	std	Y+6, r25	; 0x06
    32dc:	8d 83       	std	Y+5, r24	; 0x05
    32de:	78 87       	std	Y+8, r23	; 0x08
    32e0:	6f 83       	std	Y+7, r22	; 0x07
StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
    32e2:	8d 81       	ldd	r24, Y+5	; 0x05
    32e4:	9e 81       	ldd	r25, Y+6	; 0x06
    32e6:	9c 83       	std	Y+4, r25	; 0x04
    32e8:	8b 83       	std	Y+3, r24	; 0x03
BaseType_t xReturn;
UBaseType_t uxSavedInterruptStatus;

	configASSERT( pxStreamBuffer );

	uxSavedInterruptStatus = ( UBaseType_t ) portSET_INTERRUPT_MASK_FROM_ISR();
    32ea:	19 82       	std	Y+1, r1	; 0x01
	{
		if( ( pxStreamBuffer )->xTaskWaitingToSend != NULL )
    32ec:	eb 81       	ldd	r30, Y+3	; 0x03
    32ee:	fc 81       	ldd	r31, Y+4	; 0x04
    32f0:	82 85       	ldd	r24, Z+10	; 0x0a
    32f2:	93 85       	ldd	r25, Z+11	; 0x0b
    32f4:	00 97       	sbiw	r24, 0x00	; 0
    32f6:	b9 f0       	breq	.+46     	; 0x3326 <xStreamBufferReceiveCompletedFromISR+0x68>
		{
			( void ) xTaskNotifyFromISR( ( pxStreamBuffer )->xTaskWaitingToSend,
    32f8:	eb 81       	ldd	r30, Y+3	; 0x03
    32fa:	fc 81       	ldd	r31, Y+4	; 0x04
    32fc:	82 85       	ldd	r24, Z+10	; 0x0a
    32fe:	93 85       	ldd	r25, Z+11	; 0x0b
    3300:	ef 81       	ldd	r30, Y+7	; 0x07
    3302:	f8 85       	ldd	r31, Y+8	; 0x08
    3304:	40 e0       	ldi	r20, 0x00	; 0
    3306:	50 e0       	ldi	r21, 0x00	; 0
    3308:	60 e0       	ldi	r22, 0x00	; 0
    330a:	70 e0       	ldi	r23, 0x00	; 0
    330c:	20 e0       	ldi	r18, 0x00	; 0
    330e:	00 e0       	ldi	r16, 0x00	; 0
    3310:	10 e0       	ldi	r17, 0x00	; 0
    3312:	7f 01       	movw	r14, r30
    3314:	0e 94 fb 27 	call	0x4ff6	; 0x4ff6 <xTaskGenericNotifyFromISR>
										 ( uint32_t ) 0,
										 eNoAction,
										 pxHigherPriorityTaskWoken );
			( pxStreamBuffer )->xTaskWaitingToSend = NULL;
    3318:	eb 81       	ldd	r30, Y+3	; 0x03
    331a:	fc 81       	ldd	r31, Y+4	; 0x04
    331c:	13 86       	std	Z+11, r1	; 0x0b
    331e:	12 86       	std	Z+10, r1	; 0x0a
			xReturn = pdTRUE;
    3320:	81 e0       	ldi	r24, 0x01	; 1
    3322:	8a 83       	std	Y+2, r24	; 0x02
    3324:	01 c0       	rjmp	.+2      	; 0x3328 <xStreamBufferReceiveCompletedFromISR+0x6a>
		}
		else
		{
			xReturn = pdFALSE;
    3326:	1a 82       	std	Y+2, r1	; 0x02
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
    3328:	8a 81       	ldd	r24, Y+2	; 0x02
}
    332a:	28 96       	adiw	r28, 0x08	; 8
    332c:	0f b6       	in	r0, 0x3f	; 63
    332e:	f8 94       	cli
    3330:	de bf       	out	0x3e, r29	; 62
    3332:	0f be       	out	0x3f, r0	; 63
    3334:	cd bf       	out	0x3d, r28	; 61
    3336:	cf 91       	pop	r28
    3338:	df 91       	pop	r29
    333a:	1f 91       	pop	r17
    333c:	0f 91       	pop	r16
    333e:	ff 90       	pop	r15
    3340:	ef 90       	pop	r14
    3342:	08 95       	ret

00003344 <prvWriteBytesToBuffer>:
/*-----------------------------------------------------------*/

static size_t prvWriteBytesToBuffer( StreamBuffer_t * const pxStreamBuffer, const uint8_t *pucData, size_t xCount )
{
    3344:	df 93       	push	r29
    3346:	cf 93       	push	r28
    3348:	cd b7       	in	r28, 0x3d	; 61
    334a:	de b7       	in	r29, 0x3e	; 62
    334c:	2e 97       	sbiw	r28, 0x0e	; 14
    334e:	0f b6       	in	r0, 0x3f	; 63
    3350:	f8 94       	cli
    3352:	de bf       	out	0x3e, r29	; 62
    3354:	0f be       	out	0x3f, r0	; 63
    3356:	cd bf       	out	0x3d, r28	; 61
    3358:	9e 83       	std	Y+6, r25	; 0x06
    335a:	8d 83       	std	Y+5, r24	; 0x05
    335c:	78 87       	std	Y+8, r23	; 0x08
    335e:	6f 83       	std	Y+7, r22	; 0x07
    3360:	5a 87       	std	Y+10, r21	; 0x0a
    3362:	49 87       	std	Y+9, r20	; 0x09
size_t xNextHead, xFirstLength;

	configASSERT( xCount > ( size_t ) 0 );

	xNextHead = pxStreamBuffer->xHead;
    3364:	ed 81       	ldd	r30, Y+5	; 0x05
    3366:	fe 81       	ldd	r31, Y+6	; 0x06
    3368:	82 81       	ldd	r24, Z+2	; 0x02
    336a:	93 81       	ldd	r25, Z+3	; 0x03
    336c:	9c 83       	std	Y+4, r25	; 0x04
    336e:	8b 83       	std	Y+3, r24	; 0x03

	/* Calculate the number of bytes that can be added in the first write -
	which may be less than the total number of bytes that need to be added if
	the buffer will wrap back to the beginning. */
	xFirstLength = configMIN( pxStreamBuffer->xLength - xNextHead, xCount );
    3370:	ed 81       	ldd	r30, Y+5	; 0x05
    3372:	fe 81       	ldd	r31, Y+6	; 0x06
    3374:	24 81       	ldd	r18, Z+4	; 0x04
    3376:	35 81       	ldd	r19, Z+5	; 0x05
    3378:	8b 81       	ldd	r24, Y+3	; 0x03
    337a:	9c 81       	ldd	r25, Y+4	; 0x04
    337c:	a9 01       	movw	r20, r18
    337e:	48 1b       	sub	r20, r24
    3380:	59 0b       	sbc	r21, r25
    3382:	ca 01       	movw	r24, r20
    3384:	29 85       	ldd	r18, Y+9	; 0x09
    3386:	3a 85       	ldd	r19, Y+10	; 0x0a
    3388:	3e 87       	std	Y+14, r19	; 0x0e
    338a:	2d 87       	std	Y+13, r18	; 0x0d
    338c:	9c 87       	std	Y+12, r25	; 0x0c
    338e:	8b 87       	std	Y+11, r24	; 0x0b
    3390:	4b 85       	ldd	r20, Y+11	; 0x0b
    3392:	5c 85       	ldd	r21, Y+12	; 0x0c
    3394:	8d 85       	ldd	r24, Y+13	; 0x0d
    3396:	9e 85       	ldd	r25, Y+14	; 0x0e
    3398:	84 17       	cp	r24, r20
    339a:	95 07       	cpc	r25, r21
    339c:	20 f4       	brcc	.+8      	; 0x33a6 <prvWriteBytesToBuffer+0x62>
    339e:	2d 85       	ldd	r18, Y+13	; 0x0d
    33a0:	3e 85       	ldd	r19, Y+14	; 0x0e
    33a2:	3c 87       	std	Y+12, r19	; 0x0c
    33a4:	2b 87       	std	Y+11, r18	; 0x0b
    33a6:	4b 85       	ldd	r20, Y+11	; 0x0b
    33a8:	5c 85       	ldd	r21, Y+12	; 0x0c
    33aa:	5a 83       	std	Y+2, r21	; 0x02
    33ac:	49 83       	std	Y+1, r20	; 0x01

	/* Write as many bytes as can be written in the first write. */
	configASSERT( ( xNextHead + xFirstLength ) <= pxStreamBuffer->xLength );
	( void ) memcpy( ( void* ) ( &( pxStreamBuffer->pucBuffer[ xNextHead ] ) ), ( const void * ) pucData, xFirstLength ); /*lint !e9087 memcpy() requires void *. */
    33ae:	ed 81       	ldd	r30, Y+5	; 0x05
    33b0:	fe 81       	ldd	r31, Y+6	; 0x06
    33b2:	24 85       	ldd	r18, Z+12	; 0x0c
    33b4:	35 85       	ldd	r19, Z+13	; 0x0d
    33b6:	8b 81       	ldd	r24, Y+3	; 0x03
    33b8:	9c 81       	ldd	r25, Y+4	; 0x04
    33ba:	82 0f       	add	r24, r18
    33bc:	93 1f       	adc	r25, r19
    33be:	2f 81       	ldd	r18, Y+7	; 0x07
    33c0:	38 85       	ldd	r19, Y+8	; 0x08
    33c2:	49 81       	ldd	r20, Y+1	; 0x01
    33c4:	5a 81       	ldd	r21, Y+2	; 0x02
    33c6:	b9 01       	movw	r22, r18
    33c8:	0e 94 2f 2a 	call	0x545e	; 0x545e <memcpy>

	/* If the number of bytes written was less than the number that could be
	written in the first write... */
	if( xCount > xFirstLength )
    33cc:	29 85       	ldd	r18, Y+9	; 0x09
    33ce:	3a 85       	ldd	r19, Y+10	; 0x0a
    33d0:	89 81       	ldd	r24, Y+1	; 0x01
    33d2:	9a 81       	ldd	r25, Y+2	; 0x02
    33d4:	82 17       	cp	r24, r18
    33d6:	93 07       	cpc	r25, r19
    33d8:	b0 f4       	brcc	.+44     	; 0x3406 <prvWriteBytesToBuffer+0xc2>
	{
		/* ...then write the remaining bytes to the start of the buffer. */
		configASSERT( ( xCount - xFirstLength ) <= pxStreamBuffer->xLength );
		( void ) memcpy( ( void * ) pxStreamBuffer->pucBuffer, ( const void * ) &( pucData[ xFirstLength ] ), xCount - xFirstLength ); /*lint !e9087 memcpy() requires void *. */
    33da:	ed 81       	ldd	r30, Y+5	; 0x05
    33dc:	fe 81       	ldd	r31, Y+6	; 0x06
    33de:	64 85       	ldd	r22, Z+12	; 0x0c
    33e0:	75 85       	ldd	r23, Z+13	; 0x0d
    33e2:	2f 81       	ldd	r18, Y+7	; 0x07
    33e4:	38 85       	ldd	r19, Y+8	; 0x08
    33e6:	89 81       	ldd	r24, Y+1	; 0x01
    33e8:	9a 81       	ldd	r25, Y+2	; 0x02
    33ea:	a9 01       	movw	r20, r18
    33ec:	48 0f       	add	r20, r24
    33ee:	59 1f       	adc	r21, r25
    33f0:	29 85       	ldd	r18, Y+9	; 0x09
    33f2:	3a 85       	ldd	r19, Y+10	; 0x0a
    33f4:	89 81       	ldd	r24, Y+1	; 0x01
    33f6:	9a 81       	ldd	r25, Y+2	; 0x02
    33f8:	28 1b       	sub	r18, r24
    33fa:	39 0b       	sbc	r19, r25
    33fc:	cb 01       	movw	r24, r22
    33fe:	ba 01       	movw	r22, r20
    3400:	a9 01       	movw	r20, r18
    3402:	0e 94 2f 2a 	call	0x545e	; 0x545e <memcpy>
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	xNextHead += xCount;
    3406:	2b 81       	ldd	r18, Y+3	; 0x03
    3408:	3c 81       	ldd	r19, Y+4	; 0x04
    340a:	89 85       	ldd	r24, Y+9	; 0x09
    340c:	9a 85       	ldd	r25, Y+10	; 0x0a
    340e:	82 0f       	add	r24, r18
    3410:	93 1f       	adc	r25, r19
    3412:	9c 83       	std	Y+4, r25	; 0x04
    3414:	8b 83       	std	Y+3, r24	; 0x03
	if( xNextHead >= pxStreamBuffer->xLength )
    3416:	ed 81       	ldd	r30, Y+5	; 0x05
    3418:	fe 81       	ldd	r31, Y+6	; 0x06
    341a:	24 81       	ldd	r18, Z+4	; 0x04
    341c:	35 81       	ldd	r19, Z+5	; 0x05
    341e:	8b 81       	ldd	r24, Y+3	; 0x03
    3420:	9c 81       	ldd	r25, Y+4	; 0x04
    3422:	82 17       	cp	r24, r18
    3424:	93 07       	cpc	r25, r19
    3426:	50 f0       	brcs	.+20     	; 0x343c <prvWriteBytesToBuffer+0xf8>
	{
		xNextHead -= pxStreamBuffer->xLength;
    3428:	ed 81       	ldd	r30, Y+5	; 0x05
    342a:	fe 81       	ldd	r31, Y+6	; 0x06
    342c:	24 81       	ldd	r18, Z+4	; 0x04
    342e:	35 81       	ldd	r19, Z+5	; 0x05
    3430:	8b 81       	ldd	r24, Y+3	; 0x03
    3432:	9c 81       	ldd	r25, Y+4	; 0x04
    3434:	82 1b       	sub	r24, r18
    3436:	93 0b       	sbc	r25, r19
    3438:	9c 83       	std	Y+4, r25	; 0x04
    343a:	8b 83       	std	Y+3, r24	; 0x03
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxStreamBuffer->xHead = xNextHead;
    343c:	ed 81       	ldd	r30, Y+5	; 0x05
    343e:	fe 81       	ldd	r31, Y+6	; 0x06
    3440:	8b 81       	ldd	r24, Y+3	; 0x03
    3442:	9c 81       	ldd	r25, Y+4	; 0x04
    3444:	93 83       	std	Z+3, r25	; 0x03
    3446:	82 83       	std	Z+2, r24	; 0x02

	return xCount;
    3448:	89 85       	ldd	r24, Y+9	; 0x09
    344a:	9a 85       	ldd	r25, Y+10	; 0x0a
}
    344c:	2e 96       	adiw	r28, 0x0e	; 14
    344e:	0f b6       	in	r0, 0x3f	; 63
    3450:	f8 94       	cli
    3452:	de bf       	out	0x3e, r29	; 62
    3454:	0f be       	out	0x3f, r0	; 63
    3456:	cd bf       	out	0x3d, r28	; 61
    3458:	cf 91       	pop	r28
    345a:	df 91       	pop	r29
    345c:	08 95       	ret

0000345e <prvReadBytesFromBuffer>:
/*-----------------------------------------------------------*/

static size_t prvReadBytesFromBuffer( StreamBuffer_t *pxStreamBuffer, uint8_t *pucData, size_t xMaxCount, size_t xBytesAvailable )
{
    345e:	df 93       	push	r29
    3460:	cf 93       	push	r28
    3462:	cd b7       	in	r28, 0x3d	; 61
    3464:	de b7       	in	r29, 0x3e	; 62
    3466:	66 97       	sbiw	r28, 0x16	; 22
    3468:	0f b6       	in	r0, 0x3f	; 63
    346a:	f8 94       	cli
    346c:	de bf       	out	0x3e, r29	; 62
    346e:	0f be       	out	0x3f, r0	; 63
    3470:	cd bf       	out	0x3d, r28	; 61
    3472:	98 87       	std	Y+8, r25	; 0x08
    3474:	8f 83       	std	Y+7, r24	; 0x07
    3476:	7a 87       	std	Y+10, r23	; 0x0a
    3478:	69 87       	std	Y+9, r22	; 0x09
    347a:	5c 87       	std	Y+12, r21	; 0x0c
    347c:	4b 87       	std	Y+11, r20	; 0x0b
    347e:	3e 87       	std	Y+14, r19	; 0x0e
    3480:	2d 87       	std	Y+13, r18	; 0x0d
size_t xCount, xFirstLength, xNextTail;

	/* Use the minimum of the wanted bytes and the available bytes. */
	xCount = configMIN( xBytesAvailable, xMaxCount );
    3482:	2d 85       	ldd	r18, Y+13	; 0x0d
    3484:	3e 85       	ldd	r19, Y+14	; 0x0e
    3486:	3a 8b       	std	Y+18, r19	; 0x12
    3488:	29 8b       	std	Y+17, r18	; 0x11
    348a:	4b 85       	ldd	r20, Y+11	; 0x0b
    348c:	5c 85       	ldd	r21, Y+12	; 0x0c
    348e:	58 8b       	std	Y+16, r21	; 0x10
    3490:	4f 87       	std	Y+15, r20	; 0x0f
    3492:	8f 85       	ldd	r24, Y+15	; 0x0f
    3494:	98 89       	ldd	r25, Y+16	; 0x10
    3496:	29 89       	ldd	r18, Y+17	; 0x11
    3498:	3a 89       	ldd	r19, Y+18	; 0x12
    349a:	28 17       	cp	r18, r24
    349c:	39 07       	cpc	r19, r25
    349e:	20 f4       	brcc	.+8      	; 0x34a8 <prvReadBytesFromBuffer+0x4a>
    34a0:	49 89       	ldd	r20, Y+17	; 0x11
    34a2:	5a 89       	ldd	r21, Y+18	; 0x12
    34a4:	58 8b       	std	Y+16, r21	; 0x10
    34a6:	4f 87       	std	Y+15, r20	; 0x0f
    34a8:	8f 85       	ldd	r24, Y+15	; 0x0f
    34aa:	98 89       	ldd	r25, Y+16	; 0x10
    34ac:	9e 83       	std	Y+6, r25	; 0x06
    34ae:	8d 83       	std	Y+5, r24	; 0x05

	if( xCount > ( size_t ) 0 )
    34b0:	8d 81       	ldd	r24, Y+5	; 0x05
    34b2:	9e 81       	ldd	r25, Y+6	; 0x06
    34b4:	00 97       	sbiw	r24, 0x00	; 0
    34b6:	09 f4       	brne	.+2      	; 0x34ba <prvReadBytesFromBuffer+0x5c>
    34b8:	74 c0       	rjmp	.+232    	; 0x35a2 <prvReadBytesFromBuffer+0x144>
	{
		xNextTail = pxStreamBuffer->xTail;
    34ba:	ef 81       	ldd	r30, Y+7	; 0x07
    34bc:	f8 85       	ldd	r31, Y+8	; 0x08
    34be:	80 81       	ld	r24, Z
    34c0:	91 81       	ldd	r25, Z+1	; 0x01
    34c2:	9a 83       	std	Y+2, r25	; 0x02
    34c4:	89 83       	std	Y+1, r24	; 0x01

		/* Calculate the number of bytes that can be read - which may be
		less than the number wanted if the data wraps around to the start of
		the buffer. */
		xFirstLength = configMIN( pxStreamBuffer->xLength - xNextTail, xCount );
    34c6:	ef 81       	ldd	r30, Y+7	; 0x07
    34c8:	f8 85       	ldd	r31, Y+8	; 0x08
    34ca:	24 81       	ldd	r18, Z+4	; 0x04
    34cc:	35 81       	ldd	r19, Z+5	; 0x05
    34ce:	89 81       	ldd	r24, Y+1	; 0x01
    34d0:	9a 81       	ldd	r25, Y+2	; 0x02
    34d2:	a9 01       	movw	r20, r18
    34d4:	48 1b       	sub	r20, r24
    34d6:	59 0b       	sbc	r21, r25
    34d8:	ca 01       	movw	r24, r20
    34da:	2d 81       	ldd	r18, Y+5	; 0x05
    34dc:	3e 81       	ldd	r19, Y+6	; 0x06
    34de:	3e 8b       	std	Y+22, r19	; 0x16
    34e0:	2d 8b       	std	Y+21, r18	; 0x15
    34e2:	9c 8b       	std	Y+20, r25	; 0x14
    34e4:	8b 8b       	std	Y+19, r24	; 0x13
    34e6:	4b 89       	ldd	r20, Y+19	; 0x13
    34e8:	5c 89       	ldd	r21, Y+20	; 0x14
    34ea:	8d 89       	ldd	r24, Y+21	; 0x15
    34ec:	9e 89       	ldd	r25, Y+22	; 0x16
    34ee:	84 17       	cp	r24, r20
    34f0:	95 07       	cpc	r25, r21
    34f2:	20 f4       	brcc	.+8      	; 0x34fc <prvReadBytesFromBuffer+0x9e>
    34f4:	2d 89       	ldd	r18, Y+21	; 0x15
    34f6:	3e 89       	ldd	r19, Y+22	; 0x16
    34f8:	3c 8b       	std	Y+20, r19	; 0x14
    34fa:	2b 8b       	std	Y+19, r18	; 0x13
    34fc:	4b 89       	ldd	r20, Y+19	; 0x13
    34fe:	5c 89       	ldd	r21, Y+20	; 0x14
    3500:	5c 83       	std	Y+4, r21	; 0x04
    3502:	4b 83       	std	Y+3, r20	; 0x03

		/* Obtain the number of bytes it is possible to obtain in the first
		read.  Asserts check bounds of read and write. */
		configASSERT( xFirstLength <= xMaxCount );
		configASSERT( ( xNextTail + xFirstLength ) <= pxStreamBuffer->xLength );
		( void ) memcpy( ( void * ) pucData, ( const void * ) &( pxStreamBuffer->pucBuffer[ xNextTail ] ), xFirstLength ); /*lint !e9087 memcpy() requires void *. */
    3504:	ef 81       	ldd	r30, Y+7	; 0x07
    3506:	f8 85       	ldd	r31, Y+8	; 0x08
    3508:	24 85       	ldd	r18, Z+12	; 0x0c
    350a:	35 85       	ldd	r19, Z+13	; 0x0d
    350c:	89 81       	ldd	r24, Y+1	; 0x01
    350e:	9a 81       	ldd	r25, Y+2	; 0x02
    3510:	a9 01       	movw	r20, r18
    3512:	48 0f       	add	r20, r24
    3514:	59 1f       	adc	r21, r25
    3516:	89 85       	ldd	r24, Y+9	; 0x09
    3518:	9a 85       	ldd	r25, Y+10	; 0x0a
    351a:	2b 81       	ldd	r18, Y+3	; 0x03
    351c:	3c 81       	ldd	r19, Y+4	; 0x04
    351e:	ba 01       	movw	r22, r20
    3520:	a9 01       	movw	r20, r18
    3522:	0e 94 2f 2a 	call	0x545e	; 0x545e <memcpy>

		/* If the total number of wanted bytes is greater than the number
		that could be read in the first read... */
		if( xCount > xFirstLength )
    3526:	2d 81       	ldd	r18, Y+5	; 0x05
    3528:	3e 81       	ldd	r19, Y+6	; 0x06
    352a:	8b 81       	ldd	r24, Y+3	; 0x03
    352c:	9c 81       	ldd	r25, Y+4	; 0x04
    352e:	82 17       	cp	r24, r18
    3530:	93 07       	cpc	r25, r19
    3532:	b0 f4       	brcc	.+44     	; 0x3560 <prvReadBytesFromBuffer+0x102>
		{
			/*...then read the remaining bytes from the start of the buffer. */
			configASSERT( xCount <= xMaxCount );
			( void ) memcpy( ( void * ) &( pucData[ xFirstLength ] ), ( void * ) ( pxStreamBuffer->pucBuffer ), xCount - xFirstLength ); /*lint !e9087 memcpy() requires void *. */
    3534:	29 85       	ldd	r18, Y+9	; 0x09
    3536:	3a 85       	ldd	r19, Y+10	; 0x0a
    3538:	8b 81       	ldd	r24, Y+3	; 0x03
    353a:	9c 81       	ldd	r25, Y+4	; 0x04
    353c:	b9 01       	movw	r22, r18
    353e:	68 0f       	add	r22, r24
    3540:	79 1f       	adc	r23, r25
    3542:	ef 81       	ldd	r30, Y+7	; 0x07
    3544:	f8 85       	ldd	r31, Y+8	; 0x08
    3546:	44 85       	ldd	r20, Z+12	; 0x0c
    3548:	55 85       	ldd	r21, Z+13	; 0x0d
    354a:	2d 81       	ldd	r18, Y+5	; 0x05
    354c:	3e 81       	ldd	r19, Y+6	; 0x06
    354e:	8b 81       	ldd	r24, Y+3	; 0x03
    3550:	9c 81       	ldd	r25, Y+4	; 0x04
    3552:	28 1b       	sub	r18, r24
    3554:	39 0b       	sbc	r19, r25
    3556:	cb 01       	movw	r24, r22
    3558:	ba 01       	movw	r22, r20
    355a:	a9 01       	movw	r20, r18
    355c:	0e 94 2f 2a 	call	0x545e	; 0x545e <memcpy>
			mtCOVERAGE_TEST_MARKER();
		}

		/* Move the tail pointer to effectively remove the data read from
		the buffer. */
		xNextTail += xCount;
    3560:	29 81       	ldd	r18, Y+1	; 0x01
    3562:	3a 81       	ldd	r19, Y+2	; 0x02
    3564:	8d 81       	ldd	r24, Y+5	; 0x05
    3566:	9e 81       	ldd	r25, Y+6	; 0x06
    3568:	82 0f       	add	r24, r18
    356a:	93 1f       	adc	r25, r19
    356c:	9a 83       	std	Y+2, r25	; 0x02
    356e:	89 83       	std	Y+1, r24	; 0x01

		if( xNextTail >= pxStreamBuffer->xLength )
    3570:	ef 81       	ldd	r30, Y+7	; 0x07
    3572:	f8 85       	ldd	r31, Y+8	; 0x08
    3574:	24 81       	ldd	r18, Z+4	; 0x04
    3576:	35 81       	ldd	r19, Z+5	; 0x05
    3578:	89 81       	ldd	r24, Y+1	; 0x01
    357a:	9a 81       	ldd	r25, Y+2	; 0x02
    357c:	82 17       	cp	r24, r18
    357e:	93 07       	cpc	r25, r19
    3580:	50 f0       	brcs	.+20     	; 0x3596 <prvReadBytesFromBuffer+0x138>
		{
			xNextTail -= pxStreamBuffer->xLength;
    3582:	ef 81       	ldd	r30, Y+7	; 0x07
    3584:	f8 85       	ldd	r31, Y+8	; 0x08
    3586:	24 81       	ldd	r18, Z+4	; 0x04
    3588:	35 81       	ldd	r19, Z+5	; 0x05
    358a:	89 81       	ldd	r24, Y+1	; 0x01
    358c:	9a 81       	ldd	r25, Y+2	; 0x02
    358e:	82 1b       	sub	r24, r18
    3590:	93 0b       	sbc	r25, r19
    3592:	9a 83       	std	Y+2, r25	; 0x02
    3594:	89 83       	std	Y+1, r24	; 0x01
		}

		pxStreamBuffer->xTail = xNextTail;
    3596:	ef 81       	ldd	r30, Y+7	; 0x07
    3598:	f8 85       	ldd	r31, Y+8	; 0x08
    359a:	89 81       	ldd	r24, Y+1	; 0x01
    359c:	9a 81       	ldd	r25, Y+2	; 0x02
    359e:	91 83       	std	Z+1, r25	; 0x01
    35a0:	80 83       	st	Z, r24
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	return xCount;
    35a2:	8d 81       	ldd	r24, Y+5	; 0x05
    35a4:	9e 81       	ldd	r25, Y+6	; 0x06
}
    35a6:	66 96       	adiw	r28, 0x16	; 22
    35a8:	0f b6       	in	r0, 0x3f	; 63
    35aa:	f8 94       	cli
    35ac:	de bf       	out	0x3e, r29	; 62
    35ae:	0f be       	out	0x3f, r0	; 63
    35b0:	cd bf       	out	0x3d, r28	; 61
    35b2:	cf 91       	pop	r28
    35b4:	df 91       	pop	r29
    35b6:	08 95       	ret

000035b8 <prvBytesInBuffer>:
/*-----------------------------------------------------------*/

static size_t prvBytesInBuffer( const StreamBuffer_t * const pxStreamBuffer )
{
    35b8:	df 93       	push	r29
    35ba:	cf 93       	push	r28
    35bc:	00 d0       	rcall	.+0      	; 0x35be <prvBytesInBuffer+0x6>
    35be:	00 d0       	rcall	.+0      	; 0x35c0 <prvBytesInBuffer+0x8>
    35c0:	cd b7       	in	r28, 0x3d	; 61
    35c2:	de b7       	in	r29, 0x3e	; 62
    35c4:	9c 83       	std	Y+4, r25	; 0x04
    35c6:	8b 83       	std	Y+3, r24	; 0x03
/* Returns the distance between xTail and xHead. */
size_t xCount;

	xCount = pxStreamBuffer->xLength + pxStreamBuffer->xHead;
    35c8:	eb 81       	ldd	r30, Y+3	; 0x03
    35ca:	fc 81       	ldd	r31, Y+4	; 0x04
    35cc:	24 81       	ldd	r18, Z+4	; 0x04
    35ce:	35 81       	ldd	r19, Z+5	; 0x05
    35d0:	eb 81       	ldd	r30, Y+3	; 0x03
    35d2:	fc 81       	ldd	r31, Y+4	; 0x04
    35d4:	82 81       	ldd	r24, Z+2	; 0x02
    35d6:	93 81       	ldd	r25, Z+3	; 0x03
    35d8:	82 0f       	add	r24, r18
    35da:	93 1f       	adc	r25, r19
    35dc:	9a 83       	std	Y+2, r25	; 0x02
    35de:	89 83       	std	Y+1, r24	; 0x01
	xCount -= pxStreamBuffer->xTail;
    35e0:	eb 81       	ldd	r30, Y+3	; 0x03
    35e2:	fc 81       	ldd	r31, Y+4	; 0x04
    35e4:	20 81       	ld	r18, Z
    35e6:	31 81       	ldd	r19, Z+1	; 0x01
    35e8:	89 81       	ldd	r24, Y+1	; 0x01
    35ea:	9a 81       	ldd	r25, Y+2	; 0x02
    35ec:	82 1b       	sub	r24, r18
    35ee:	93 0b       	sbc	r25, r19
    35f0:	9a 83       	std	Y+2, r25	; 0x02
    35f2:	89 83       	std	Y+1, r24	; 0x01
	if ( xCount >= pxStreamBuffer->xLength )
    35f4:	eb 81       	ldd	r30, Y+3	; 0x03
    35f6:	fc 81       	ldd	r31, Y+4	; 0x04
    35f8:	24 81       	ldd	r18, Z+4	; 0x04
    35fa:	35 81       	ldd	r19, Z+5	; 0x05
    35fc:	89 81       	ldd	r24, Y+1	; 0x01
    35fe:	9a 81       	ldd	r25, Y+2	; 0x02
    3600:	82 17       	cp	r24, r18
    3602:	93 07       	cpc	r25, r19
    3604:	50 f0       	brcs	.+20     	; 0x361a <prvBytesInBuffer+0x62>
	{
		xCount -= pxStreamBuffer->xLength;
    3606:	eb 81       	ldd	r30, Y+3	; 0x03
    3608:	fc 81       	ldd	r31, Y+4	; 0x04
    360a:	24 81       	ldd	r18, Z+4	; 0x04
    360c:	35 81       	ldd	r19, Z+5	; 0x05
    360e:	89 81       	ldd	r24, Y+1	; 0x01
    3610:	9a 81       	ldd	r25, Y+2	; 0x02
    3612:	82 1b       	sub	r24, r18
    3614:	93 0b       	sbc	r25, r19
    3616:	9a 83       	std	Y+2, r25	; 0x02
    3618:	89 83       	std	Y+1, r24	; 0x01
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	return xCount;
    361a:	89 81       	ldd	r24, Y+1	; 0x01
    361c:	9a 81       	ldd	r25, Y+2	; 0x02
}
    361e:	0f 90       	pop	r0
    3620:	0f 90       	pop	r0
    3622:	0f 90       	pop	r0
    3624:	0f 90       	pop	r0
    3626:	cf 91       	pop	r28
    3628:	df 91       	pop	r29
    362a:	08 95       	ret

0000362c <prvInitialiseNewStreamBuffer>:
static void prvInitialiseNewStreamBuffer( StreamBuffer_t * const pxStreamBuffer,
										  uint8_t * const pucBuffer,
										  size_t xBufferSizeBytes,
										  size_t xTriggerLevelBytes,
										  uint8_t ucFlags )
{
    362c:	0f 93       	push	r16
    362e:	df 93       	push	r29
    3630:	cf 93       	push	r28
    3632:	cd b7       	in	r28, 0x3d	; 61
    3634:	de b7       	in	r29, 0x3e	; 62
    3636:	29 97       	sbiw	r28, 0x09	; 9
    3638:	0f b6       	in	r0, 0x3f	; 63
    363a:	f8 94       	cli
    363c:	de bf       	out	0x3e, r29	; 62
    363e:	0f be       	out	0x3f, r0	; 63
    3640:	cd bf       	out	0x3d, r28	; 61
    3642:	9a 83       	std	Y+2, r25	; 0x02
    3644:	89 83       	std	Y+1, r24	; 0x01
    3646:	7c 83       	std	Y+4, r23	; 0x04
    3648:	6b 83       	std	Y+3, r22	; 0x03
    364a:	5e 83       	std	Y+6, r21	; 0x06
    364c:	4d 83       	std	Y+5, r20	; 0x05
    364e:	38 87       	std	Y+8, r19	; 0x08
    3650:	2f 83       	std	Y+7, r18	; 0x07
    3652:	09 87       	std	Y+9, r16	; 0x09
		const BaseType_t xWriteValue = 0x55;
		configASSERT( memset( pucBuffer, ( int ) xWriteValue, xBufferSizeBytes ) == pucBuffer );
	} /*lint !e529 !e438 xWriteValue is only used if configASSERT() is defined. */
	#endif

	( void ) memset( ( void * ) pxStreamBuffer, 0x00, sizeof( StreamBuffer_t ) ); /*lint !e9087 memset() requires void *. */
    3654:	89 81       	ldd	r24, Y+1	; 0x01
    3656:	9a 81       	ldd	r25, Y+2	; 0x02
    3658:	60 e0       	ldi	r22, 0x00	; 0
    365a:	70 e0       	ldi	r23, 0x00	; 0
    365c:	4f e0       	ldi	r20, 0x0F	; 15
    365e:	50 e0       	ldi	r21, 0x00	; 0
    3660:	0e 94 38 2a 	call	0x5470	; 0x5470 <memset>
	pxStreamBuffer->pucBuffer = pucBuffer;
    3664:	e9 81       	ldd	r30, Y+1	; 0x01
    3666:	fa 81       	ldd	r31, Y+2	; 0x02
    3668:	8b 81       	ldd	r24, Y+3	; 0x03
    366a:	9c 81       	ldd	r25, Y+4	; 0x04
    366c:	95 87       	std	Z+13, r25	; 0x0d
    366e:	84 87       	std	Z+12, r24	; 0x0c
	pxStreamBuffer->xLength = xBufferSizeBytes;
    3670:	e9 81       	ldd	r30, Y+1	; 0x01
    3672:	fa 81       	ldd	r31, Y+2	; 0x02
    3674:	8d 81       	ldd	r24, Y+5	; 0x05
    3676:	9e 81       	ldd	r25, Y+6	; 0x06
    3678:	95 83       	std	Z+5, r25	; 0x05
    367a:	84 83       	std	Z+4, r24	; 0x04
	pxStreamBuffer->xTriggerLevelBytes = xTriggerLevelBytes;
    367c:	e9 81       	ldd	r30, Y+1	; 0x01
    367e:	fa 81       	ldd	r31, Y+2	; 0x02
    3680:	8f 81       	ldd	r24, Y+7	; 0x07
    3682:	98 85       	ldd	r25, Y+8	; 0x08
    3684:	97 83       	std	Z+7, r25	; 0x07
    3686:	86 83       	std	Z+6, r24	; 0x06
	pxStreamBuffer->ucFlags = ucFlags;
    3688:	e9 81       	ldd	r30, Y+1	; 0x01
    368a:	fa 81       	ldd	r31, Y+2	; 0x02
    368c:	89 85       	ldd	r24, Y+9	; 0x09
    368e:	86 87       	std	Z+14, r24	; 0x0e
}
    3690:	29 96       	adiw	r28, 0x09	; 9
    3692:	0f b6       	in	r0, 0x3f	; 63
    3694:	f8 94       	cli
    3696:	de bf       	out	0x3e, r29	; 62
    3698:	0f be       	out	0x3f, r0	; 63
    369a:	cd bf       	out	0x3d, r28	; 61
    369c:	cf 91       	pop	r28
    369e:	df 91       	pop	r29
    36a0:	0f 91       	pop	r16
    36a2:	08 95       	ret

000036a4 <xTaskCreate>:
							const char * const pcName,		/*lint !e971 Unqualified char types are allowed for strings and single characters only. */
							const configSTACK_DEPTH_TYPE usStackDepth,
							void * const pvParameters,
							UBaseType_t uxPriority,
							TaskHandle_t * const pxCreatedTask )
	{
    36a4:	8f 92       	push	r8
    36a6:	9f 92       	push	r9
    36a8:	af 92       	push	r10
    36aa:	bf 92       	push	r11
    36ac:	cf 92       	push	r12
    36ae:	df 92       	push	r13
    36b0:	ef 92       	push	r14
    36b2:	ff 92       	push	r15
    36b4:	0f 93       	push	r16
    36b6:	1f 93       	push	r17
    36b8:	df 93       	push	r29
    36ba:	cf 93       	push	r28
    36bc:	cd b7       	in	r28, 0x3d	; 61
    36be:	de b7       	in	r29, 0x3e	; 62
    36c0:	60 97       	sbiw	r28, 0x10	; 16
    36c2:	0f b6       	in	r0, 0x3f	; 63
    36c4:	f8 94       	cli
    36c6:	de bf       	out	0x3e, r29	; 62
    36c8:	0f be       	out	0x3f, r0	; 63
    36ca:	cd bf       	out	0x3d, r28	; 61
    36cc:	9f 83       	std	Y+7, r25	; 0x07
    36ce:	8e 83       	std	Y+6, r24	; 0x06
    36d0:	79 87       	std	Y+9, r23	; 0x09
    36d2:	68 87       	std	Y+8, r22	; 0x08
    36d4:	5b 87       	std	Y+11, r21	; 0x0b
    36d6:	4a 87       	std	Y+10, r20	; 0x0a
    36d8:	3d 87       	std	Y+13, r19	; 0x0d
    36da:	2c 87       	std	Y+12, r18	; 0x0c
    36dc:	0e 87       	std	Y+14, r16	; 0x0e
    36de:	f8 8a       	std	Y+16, r15	; 0x10
    36e0:	ef 86       	std	Y+15, r14	; 0x0f
		#else /* portSTACK_GROWTH */
		{
		StackType_t *pxStack;

			/* Allocate space for the stack used by the task being created. */
			pxStack = pvPortMalloc( ( ( ( size_t ) usStackDepth ) * sizeof( StackType_t ) ) ); /*lint !e9079 All values returned by pvPortMalloc() have at least the alignment required by the MCU's stack and this allocation is the stack. */
    36e2:	8a 85       	ldd	r24, Y+10	; 0x0a
    36e4:	9b 85       	ldd	r25, Y+11	; 0x0b
    36e6:	0e 94 2a 06 	call	0xc54	; 0xc54 <pvPortMalloc>
    36ea:	9a 83       	std	Y+2, r25	; 0x02
    36ec:	89 83       	std	Y+1, r24	; 0x01

			if( pxStack != NULL )
    36ee:	89 81       	ldd	r24, Y+1	; 0x01
    36f0:	9a 81       	ldd	r25, Y+2	; 0x02
    36f2:	00 97       	sbiw	r24, 0x00	; 0
    36f4:	b1 f0       	breq	.+44     	; 0x3722 <xTaskCreate+0x7e>
			{
				/* Allocate space for the TCB. */
				pxNewTCB = ( TCB_t * ) pvPortMalloc( sizeof( TCB_t ) ); /*lint !e9087 !e9079 All values returned by pvPortMalloc() have at least the alignment required by the MCU's stack, and the first member of TCB_t is always a pointer to the task's stack. */
    36f6:	8a e2       	ldi	r24, 0x2A	; 42
    36f8:	90 e0       	ldi	r25, 0x00	; 0
    36fa:	0e 94 2a 06 	call	0xc54	; 0xc54 <pvPortMalloc>
    36fe:	9d 83       	std	Y+5, r25	; 0x05
    3700:	8c 83       	std	Y+4, r24	; 0x04

				if( pxNewTCB != NULL )
    3702:	8c 81       	ldd	r24, Y+4	; 0x04
    3704:	9d 81       	ldd	r25, Y+5	; 0x05
    3706:	00 97       	sbiw	r24, 0x00	; 0
    3708:	39 f0       	breq	.+14     	; 0x3718 <xTaskCreate+0x74>
				{
					/* Store the stack location in the TCB. */
					pxNewTCB->pxStack = pxStack;
    370a:	ec 81       	ldd	r30, Y+4	; 0x04
    370c:	fd 81       	ldd	r31, Y+5	; 0x05
    370e:	89 81       	ldd	r24, Y+1	; 0x01
    3710:	9a 81       	ldd	r25, Y+2	; 0x02
    3712:	90 8f       	std	Z+24, r25	; 0x18
    3714:	87 8b       	std	Z+23, r24	; 0x17
    3716:	07 c0       	rjmp	.+14     	; 0x3726 <xTaskCreate+0x82>
				}
				else
				{
					/* The stack cannot be used as the TCB was not created.  Free
					it again. */
					vPortFree( pxStack );
    3718:	89 81       	ldd	r24, Y+1	; 0x01
    371a:	9a 81       	ldd	r25, Y+2	; 0x02
    371c:	0e 94 80 06 	call	0xd00	; 0xd00 <vPortFree>
    3720:	02 c0       	rjmp	.+4      	; 0x3726 <xTaskCreate+0x82>
				}
			}
			else
			{
				pxNewTCB = NULL;
    3722:	1d 82       	std	Y+5, r1	; 0x05
    3724:	1c 82       	std	Y+4, r1	; 0x04
			}
		}
		#endif /* portSTACK_GROWTH */

		if( pxNewTCB != NULL )
    3726:	8c 81       	ldd	r24, Y+4	; 0x04
    3728:	9d 81       	ldd	r25, Y+5	; 0x05
    372a:	00 97       	sbiw	r24, 0x00	; 0
    372c:	e9 f0       	breq	.+58     	; 0x3768 <xTaskCreate+0xc4>
				task was created dynamically in case it is later deleted. */
				pxNewTCB->ucStaticallyAllocated = tskDYNAMICALLY_ALLOCATED_STACK_AND_TCB;
			}
			#endif /* tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE */

			prvInitialiseNewTask( pxTaskCode, pcName, ( uint32_t ) usStackDepth, pvParameters, uxPriority, pxCreatedTask, pxNewTCB, NULL );
    372e:	8a 85       	ldd	r24, Y+10	; 0x0a
    3730:	9b 85       	ldd	r25, Y+11	; 0x0b
    3732:	9c 01       	movw	r18, r24
    3734:	40 e0       	ldi	r20, 0x00	; 0
    3736:	50 e0       	ldi	r21, 0x00	; 0
    3738:	8e 81       	ldd	r24, Y+6	; 0x06
    373a:	9f 81       	ldd	r25, Y+7	; 0x07
    373c:	68 85       	ldd	r22, Y+8	; 0x08
    373e:	79 85       	ldd	r23, Y+9	; 0x09
    3740:	ec 85       	ldd	r30, Y+12	; 0x0c
    3742:	fd 85       	ldd	r31, Y+13	; 0x0d
    3744:	af 85       	ldd	r26, Y+15	; 0x0f
    3746:	b8 89       	ldd	r27, Y+16	; 0x10
    3748:	ac 80       	ldd	r10, Y+4	; 0x04
    374a:	bd 80       	ldd	r11, Y+5	; 0x05
    374c:	8f 01       	movw	r16, r30
    374e:	ee 84       	ldd	r14, Y+14	; 0x0e
    3750:	6d 01       	movw	r12, r26
    3752:	88 24       	eor	r8, r8
    3754:	99 24       	eor	r9, r9
    3756:	0e 94 ca 1b 	call	0x3794	; 0x3794 <prvInitialiseNewTask>
			prvAddNewTaskToReadyList( pxNewTCB );
    375a:	8c 81       	ldd	r24, Y+4	; 0x04
    375c:	9d 81       	ldd	r25, Y+5	; 0x05
    375e:	0e 94 8d 1c 	call	0x391a	; 0x391a <prvAddNewTaskToReadyList>
			xReturn = pdPASS;
    3762:	81 e0       	ldi	r24, 0x01	; 1
    3764:	8b 83       	std	Y+3, r24	; 0x03
    3766:	02 c0       	rjmp	.+4      	; 0x376c <xTaskCreate+0xc8>
		}
		else
		{
			xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
    3768:	8f ef       	ldi	r24, 0xFF	; 255
    376a:	8b 83       	std	Y+3, r24	; 0x03
		}

		return xReturn;
    376c:	8b 81       	ldd	r24, Y+3	; 0x03
	}
    376e:	60 96       	adiw	r28, 0x10	; 16
    3770:	0f b6       	in	r0, 0x3f	; 63
    3772:	f8 94       	cli
    3774:	de bf       	out	0x3e, r29	; 62
    3776:	0f be       	out	0x3f, r0	; 63
    3778:	cd bf       	out	0x3d, r28	; 61
    377a:	cf 91       	pop	r28
    377c:	df 91       	pop	r29
    377e:	1f 91       	pop	r17
    3780:	0f 91       	pop	r16
    3782:	ff 90       	pop	r15
    3784:	ef 90       	pop	r14
    3786:	df 90       	pop	r13
    3788:	cf 90       	pop	r12
    378a:	bf 90       	pop	r11
    378c:	af 90       	pop	r10
    378e:	9f 90       	pop	r9
    3790:	8f 90       	pop	r8
    3792:	08 95       	ret

00003794 <prvInitialiseNewTask>:
									void * const pvParameters,
									UBaseType_t uxPriority,
									TaskHandle_t * const pxCreatedTask,
									TCB_t *pxNewTCB,
									const MemoryRegion_t * const xRegions )
{
    3794:	8f 92       	push	r8
    3796:	9f 92       	push	r9
    3798:	af 92       	push	r10
    379a:	bf 92       	push	r11
    379c:	cf 92       	push	r12
    379e:	df 92       	push	r13
    37a0:	ef 92       	push	r14
    37a2:	0f 93       	push	r16
    37a4:	1f 93       	push	r17
    37a6:	df 93       	push	r29
    37a8:	cf 93       	push	r28
    37aa:	cd b7       	in	r28, 0x3d	; 61
    37ac:	de b7       	in	r29, 0x3e	; 62
    37ae:	64 97       	sbiw	r28, 0x14	; 20
    37b0:	0f b6       	in	r0, 0x3f	; 63
    37b2:	f8 94       	cli
    37b4:	de bf       	out	0x3e, r29	; 62
    37b6:	0f be       	out	0x3f, r0	; 63
    37b8:	cd bf       	out	0x3d, r28	; 61
    37ba:	9d 83       	std	Y+5, r25	; 0x05
    37bc:	8c 83       	std	Y+4, r24	; 0x04
    37be:	7f 83       	std	Y+7, r23	; 0x07
    37c0:	6e 83       	std	Y+6, r22	; 0x06
    37c2:	28 87       	std	Y+8, r18	; 0x08
    37c4:	39 87       	std	Y+9, r19	; 0x09
    37c6:	4a 87       	std	Y+10, r20	; 0x0a
    37c8:	5b 87       	std	Y+11, r21	; 0x0b
    37ca:	1d 87       	std	Y+13, r17	; 0x0d
    37cc:	0c 87       	std	Y+12, r16	; 0x0c
    37ce:	ee 86       	std	Y+14, r14	; 0x0e
    37d0:	d8 8a       	std	Y+16, r13	; 0x10
    37d2:	cf 86       	std	Y+15, r12	; 0x0f
    37d4:	ba 8a       	std	Y+18, r11	; 0x12
    37d6:	a9 8a       	std	Y+17, r10	; 0x11
    37d8:	9c 8a       	std	Y+20, r9	; 0x14
    37da:	8b 8a       	std	Y+19, r8	; 0x13
	grows from high memory to low (as per the 80x86) or vice versa.
	portSTACK_GROWTH is used to make the result positive or negative as required
	by the port. */
	#if( portSTACK_GROWTH < 0 )
	{
		pxTopOfStack = &( pxNewTCB->pxStack[ ulStackDepth - ( uint32_t ) 1 ] );
    37dc:	e9 89       	ldd	r30, Y+17	; 0x11
    37de:	fa 89       	ldd	r31, Y+18	; 0x12
    37e0:	27 89       	ldd	r18, Z+23	; 0x17
    37e2:	30 8d       	ldd	r19, Z+24	; 0x18
    37e4:	88 85       	ldd	r24, Y+8	; 0x08
    37e6:	99 85       	ldd	r25, Y+9	; 0x09
    37e8:	01 97       	sbiw	r24, 0x01	; 1
    37ea:	82 0f       	add	r24, r18
    37ec:	93 1f       	adc	r25, r19
    37ee:	9b 83       	std	Y+3, r25	; 0x03
    37f0:	8a 83       	std	Y+2, r24	; 0x02
		pxNewTCB->pxEndOfStack = pxNewTCB->pxStack + ( ulStackDepth - ( uint32_t ) 1 );
	}
	#endif /* portSTACK_GROWTH */

	/* Store the task name in the TCB. */
	if( pcName != NULL )
    37f2:	8e 81       	ldd	r24, Y+6	; 0x06
    37f4:	9f 81       	ldd	r25, Y+7	; 0x07
    37f6:	00 97       	sbiw	r24, 0x00	; 0
    37f8:	51 f1       	breq	.+84     	; 0x384e <prvInitialiseNewTask+0xba>
	{
		for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
    37fa:	19 82       	std	Y+1, r1	; 0x01
    37fc:	21 c0       	rjmp	.+66     	; 0x3840 <prvInitialiseNewTask+0xac>
		{
			pxNewTCB->pcTaskName[ x ] = pcName[ x ];
    37fe:	89 81       	ldd	r24, Y+1	; 0x01
    3800:	48 2f       	mov	r20, r24
    3802:	50 e0       	ldi	r21, 0x00	; 0
    3804:	89 81       	ldd	r24, Y+1	; 0x01
    3806:	28 2f       	mov	r18, r24
    3808:	30 e0       	ldi	r19, 0x00	; 0
    380a:	8e 81       	ldd	r24, Y+6	; 0x06
    380c:	9f 81       	ldd	r25, Y+7	; 0x07
    380e:	fc 01       	movw	r30, r24
    3810:	e2 0f       	add	r30, r18
    3812:	f3 1f       	adc	r31, r19
    3814:	20 81       	ld	r18, Z
    3816:	89 89       	ldd	r24, Y+17	; 0x11
    3818:	9a 89       	ldd	r25, Y+18	; 0x12
    381a:	84 0f       	add	r24, r20
    381c:	95 1f       	adc	r25, r21
    381e:	fc 01       	movw	r30, r24
    3820:	79 96       	adiw	r30, 0x19	; 25
    3822:	20 83       	st	Z, r18

			/* Don't copy all configMAX_TASK_NAME_LEN if the string is shorter than
			configMAX_TASK_NAME_LEN characters just in case the memory after the
			string is not accessible (extremely unlikely). */
			if( pcName[ x ] == ( char ) 0x00 )
    3824:	89 81       	ldd	r24, Y+1	; 0x01
    3826:	28 2f       	mov	r18, r24
    3828:	30 e0       	ldi	r19, 0x00	; 0
    382a:	8e 81       	ldd	r24, Y+6	; 0x06
    382c:	9f 81       	ldd	r25, Y+7	; 0x07
    382e:	fc 01       	movw	r30, r24
    3830:	e2 0f       	add	r30, r18
    3832:	f3 1f       	adc	r31, r19
    3834:	80 81       	ld	r24, Z
    3836:	88 23       	and	r24, r24
    3838:	31 f0       	breq	.+12     	; 0x3846 <prvInitialiseNewTask+0xb2>
	#endif /* portSTACK_GROWTH */

	/* Store the task name in the TCB. */
	if( pcName != NULL )
	{
		for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
    383a:	89 81       	ldd	r24, Y+1	; 0x01
    383c:	8f 5f       	subi	r24, 0xFF	; 255
    383e:	89 83       	std	Y+1, r24	; 0x01
    3840:	89 81       	ldd	r24, Y+1	; 0x01
    3842:	8a 30       	cpi	r24, 0x0A	; 10
    3844:	e0 f2       	brcs	.-72     	; 0x37fe <prvInitialiseNewTask+0x6a>
			}
		}

		/* Ensure the name string is terminated in the case that the string length
		was greater or equal to configMAX_TASK_NAME_LEN. */
		pxNewTCB->pcTaskName[ configMAX_TASK_NAME_LEN - 1 ] = '\0';
    3846:	e9 89       	ldd	r30, Y+17	; 0x11
    3848:	fa 89       	ldd	r31, Y+18	; 0x12
    384a:	12 a2       	std	Z+34, r1	; 0x22
    384c:	03 c0       	rjmp	.+6      	; 0x3854 <prvInitialiseNewTask+0xc0>
	}
	else
	{
		/* The task has not been given a name, so just ensure there is a NULL
		terminator when it is read out. */
		pxNewTCB->pcTaskName[ 0 ] = 0x00;
    384e:	e9 89       	ldd	r30, Y+17	; 0x11
    3850:	fa 89       	ldd	r31, Y+18	; 0x12
    3852:	11 8e       	std	Z+25, r1	; 0x19
	}

	/* This is used as an array index so must ensure it's not too large.  First
	remove the privilege bit if one is present. */
	if( uxPriority >= ( UBaseType_t ) configMAX_PRIORITIES )
    3854:	8e 85       	ldd	r24, Y+14	; 0x0e
    3856:	84 30       	cpi	r24, 0x04	; 4
    3858:	10 f0       	brcs	.+4      	; 0x385e <prvInitialiseNewTask+0xca>
	{
		uxPriority = ( UBaseType_t ) configMAX_PRIORITIES - ( UBaseType_t ) 1U;
    385a:	83 e0       	ldi	r24, 0x03	; 3
    385c:	8e 87       	std	Y+14, r24	; 0x0e
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxNewTCB->uxPriority = uxPriority;
    385e:	e9 89       	ldd	r30, Y+17	; 0x11
    3860:	fa 89       	ldd	r31, Y+18	; 0x12
    3862:	8e 85       	ldd	r24, Y+14	; 0x0e
    3864:	86 8b       	std	Z+22, r24	; 0x16
	#if ( configUSE_MUTEXES == 1 )
	{
		pxNewTCB->uxBasePriority = uxPriority;
    3866:	e9 89       	ldd	r30, Y+17	; 0x11
    3868:	fa 89       	ldd	r31, Y+18	; 0x12
    386a:	8e 85       	ldd	r24, Y+14	; 0x0e
    386c:	83 a3       	std	Z+35, r24	; 0x23
		pxNewTCB->uxMutexesHeld = 0;
    386e:	e9 89       	ldd	r30, Y+17	; 0x11
    3870:	fa 89       	ldd	r31, Y+18	; 0x12
    3872:	14 a2       	std	Z+36, r1	; 0x24
	}
	#endif /* configUSE_MUTEXES */

	vListInitialiseItem( &( pxNewTCB->xStateListItem ) );
    3874:	89 89       	ldd	r24, Y+17	; 0x11
    3876:	9a 89       	ldd	r25, Y+18	; 0x12
    3878:	02 96       	adiw	r24, 0x02	; 2
    387a:	0e 94 d0 06 	call	0xda0	; 0xda0 <vListInitialiseItem>
	vListInitialiseItem( &( pxNewTCB->xEventListItem ) );
    387e:	89 89       	ldd	r24, Y+17	; 0x11
    3880:	9a 89       	ldd	r25, Y+18	; 0x12
    3882:	0c 96       	adiw	r24, 0x0c	; 12
    3884:	0e 94 d0 06 	call	0xda0	; 0xda0 <vListInitialiseItem>

	/* Set the pxNewTCB as a link back from the ListItem_t.  This is so we can get
	back to	the containing TCB from a generic item in a list. */
	listSET_LIST_ITEM_OWNER( &( pxNewTCB->xStateListItem ), pxNewTCB );
    3888:	e9 89       	ldd	r30, Y+17	; 0x11
    388a:	fa 89       	ldd	r31, Y+18	; 0x12
    388c:	89 89       	ldd	r24, Y+17	; 0x11
    388e:	9a 89       	ldd	r25, Y+18	; 0x12
    3890:	91 87       	std	Z+9, r25	; 0x09
    3892:	80 87       	std	Z+8, r24	; 0x08

	/* Event lists are always in priority order. */
	listSET_LIST_ITEM_VALUE( &( pxNewTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    3894:	8e 85       	ldd	r24, Y+14	; 0x0e
    3896:	28 2f       	mov	r18, r24
    3898:	30 e0       	ldi	r19, 0x00	; 0
    389a:	84 e0       	ldi	r24, 0x04	; 4
    389c:	90 e0       	ldi	r25, 0x00	; 0
    389e:	82 1b       	sub	r24, r18
    38a0:	93 0b       	sbc	r25, r19
    38a2:	e9 89       	ldd	r30, Y+17	; 0x11
    38a4:	fa 89       	ldd	r31, Y+18	; 0x12
    38a6:	95 87       	std	Z+13, r25	; 0x0d
    38a8:	84 87       	std	Z+12, r24	; 0x0c
	listSET_LIST_ITEM_OWNER( &( pxNewTCB->xEventListItem ), pxNewTCB );
    38aa:	e9 89       	ldd	r30, Y+17	; 0x11
    38ac:	fa 89       	ldd	r31, Y+18	; 0x12
    38ae:	89 89       	ldd	r24, Y+17	; 0x11
    38b0:	9a 89       	ldd	r25, Y+18	; 0x12
    38b2:	93 8b       	std	Z+19, r25	; 0x13
    38b4:	82 8b       	std	Z+18, r24	; 0x12
	}
	#endif

	#if ( configUSE_TASK_NOTIFICATIONS == 1 )
	{
		pxNewTCB->ulNotifiedValue = 0;
    38b6:	e9 89       	ldd	r30, Y+17	; 0x11
    38b8:	fa 89       	ldd	r31, Y+18	; 0x12
    38ba:	15 a2       	std	Z+37, r1	; 0x25
    38bc:	16 a2       	std	Z+38, r1	; 0x26
    38be:	17 a2       	std	Z+39, r1	; 0x27
    38c0:	10 a6       	std	Z+40, r1	; 0x28
		pxNewTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
    38c2:	e9 89       	ldd	r30, Y+17	; 0x11
    38c4:	fa 89       	ldd	r31, Y+18	; 0x12
    38c6:	11 a6       	std	Z+41, r1	; 0x29
			}
			#endif /* portSTACK_GROWTH */
		}
		#else /* portHAS_STACK_OVERFLOW_CHECKING */
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
    38c8:	8a 81       	ldd	r24, Y+2	; 0x02
    38ca:	9b 81       	ldd	r25, Y+3	; 0x03
    38cc:	2c 81       	ldd	r18, Y+4	; 0x04
    38ce:	3d 81       	ldd	r19, Y+5	; 0x05
    38d0:	4c 85       	ldd	r20, Y+12	; 0x0c
    38d2:	5d 85       	ldd	r21, Y+13	; 0x0d
    38d4:	b9 01       	movw	r22, r18
    38d6:	0e 94 7d 08 	call	0x10fa	; 0x10fa <pxPortInitialiseStack>
    38da:	e9 89       	ldd	r30, Y+17	; 0x11
    38dc:	fa 89       	ldd	r31, Y+18	; 0x12
    38de:	91 83       	std	Z+1, r25	; 0x01
    38e0:	80 83       	st	Z, r24
		}
		#endif /* portHAS_STACK_OVERFLOW_CHECKING */
	}
	#endif /* portUSING_MPU_WRAPPERS */

	if( pxCreatedTask != NULL )
    38e2:	8f 85       	ldd	r24, Y+15	; 0x0f
    38e4:	98 89       	ldd	r25, Y+16	; 0x10
    38e6:	00 97       	sbiw	r24, 0x00	; 0
    38e8:	31 f0       	breq	.+12     	; 0x38f6 <prvInitialiseNewTask+0x162>
	{
		/* Pass the handle out in an anonymous way.  The handle can be used to
		change the created task's priority, delete the created task, etc.*/
		*pxCreatedTask = ( TaskHandle_t ) pxNewTCB;
    38ea:	ef 85       	ldd	r30, Y+15	; 0x0f
    38ec:	f8 89       	ldd	r31, Y+16	; 0x10
    38ee:	89 89       	ldd	r24, Y+17	; 0x11
    38f0:	9a 89       	ldd	r25, Y+18	; 0x12
    38f2:	91 83       	std	Z+1, r25	; 0x01
    38f4:	80 83       	st	Z, r24
	}
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}
}
    38f6:	64 96       	adiw	r28, 0x14	; 20
    38f8:	0f b6       	in	r0, 0x3f	; 63
    38fa:	f8 94       	cli
    38fc:	de bf       	out	0x3e, r29	; 62
    38fe:	0f be       	out	0x3f, r0	; 63
    3900:	cd bf       	out	0x3d, r28	; 61
    3902:	cf 91       	pop	r28
    3904:	df 91       	pop	r29
    3906:	1f 91       	pop	r17
    3908:	0f 91       	pop	r16
    390a:	ef 90       	pop	r14
    390c:	df 90       	pop	r13
    390e:	cf 90       	pop	r12
    3910:	bf 90       	pop	r11
    3912:	af 90       	pop	r10
    3914:	9f 90       	pop	r9
    3916:	8f 90       	pop	r8
    3918:	08 95       	ret

0000391a <prvAddNewTaskToReadyList>:
/*-----------------------------------------------------------*/

static void prvAddNewTaskToReadyList( TCB_t *pxNewTCB )
{
    391a:	df 93       	push	r29
    391c:	cf 93       	push	r28
    391e:	00 d0       	rcall	.+0      	; 0x3920 <prvAddNewTaskToReadyList+0x6>
    3920:	cd b7       	in	r28, 0x3d	; 61
    3922:	de b7       	in	r29, 0x3e	; 62
    3924:	9a 83       	std	Y+2, r25	; 0x02
    3926:	89 83       	std	Y+1, r24	; 0x01
	/* Ensure interrupts don't access the task lists while the lists are being
	updated. */
	taskENTER_CRITICAL();
    3928:	0f b6       	in	r0, 0x3f	; 63
    392a:	f8 94       	cli
    392c:	0f 92       	push	r0
	{
		uxCurrentNumberOfTasks++;
    392e:	80 91 4b 06 	lds	r24, 0x064B
    3932:	8f 5f       	subi	r24, 0xFF	; 255
    3934:	80 93 4b 06 	sts	0x064B, r24
		if( pxCurrentTCB == NULL )
    3938:	80 91 48 06 	lds	r24, 0x0648
    393c:	90 91 49 06 	lds	r25, 0x0649
    3940:	00 97       	sbiw	r24, 0x00	; 0
    3942:	69 f4       	brne	.+26     	; 0x395e <prvAddNewTaskToReadyList+0x44>
		{
			/* There are no other tasks, or all the other tasks are in
			the suspended state - make this the current task. */
			pxCurrentTCB = pxNewTCB;
    3944:	89 81       	ldd	r24, Y+1	; 0x01
    3946:	9a 81       	ldd	r25, Y+2	; 0x02
    3948:	90 93 49 06 	sts	0x0649, r25
    394c:	80 93 48 06 	sts	0x0648, r24

			if( uxCurrentNumberOfTasks == ( UBaseType_t ) 1 )
    3950:	80 91 4b 06 	lds	r24, 0x064B
    3954:	81 30       	cpi	r24, 0x01	; 1
    3956:	b9 f4       	brne	.+46     	; 0x3986 <prvAddNewTaskToReadyList+0x6c>
			{
				/* This is the first task to be created so do the preliminary
				initialisation required.  We will not recover if this call
				fails, but we will report the failure. */
				prvInitialiseTaskLists();
    3958:	0e 94 64 23 	call	0x46c8	; 0x46c8 <prvInitialiseTaskLists>
    395c:	14 c0       	rjmp	.+40     	; 0x3986 <prvAddNewTaskToReadyList+0x6c>
		else
		{
			/* If the scheduler is not already running, make this task the
			current task if it is the highest priority task to be created
			so far. */
			if( xSchedulerRunning == pdFALSE )
    395e:	80 91 4f 06 	lds	r24, 0x064F
    3962:	88 23       	and	r24, r24
    3964:	81 f4       	brne	.+32     	; 0x3986 <prvAddNewTaskToReadyList+0x6c>
			{
				if( pxCurrentTCB->uxPriority <= pxNewTCB->uxPriority )
    3966:	e0 91 48 06 	lds	r30, 0x0648
    396a:	f0 91 49 06 	lds	r31, 0x0649
    396e:	96 89       	ldd	r25, Z+22	; 0x16
    3970:	e9 81       	ldd	r30, Y+1	; 0x01
    3972:	fa 81       	ldd	r31, Y+2	; 0x02
    3974:	86 89       	ldd	r24, Z+22	; 0x16
    3976:	89 17       	cp	r24, r25
    3978:	30 f0       	brcs	.+12     	; 0x3986 <prvAddNewTaskToReadyList+0x6c>
				{
					pxCurrentTCB = pxNewTCB;
    397a:	89 81       	ldd	r24, Y+1	; 0x01
    397c:	9a 81       	ldd	r25, Y+2	; 0x02
    397e:	90 93 49 06 	sts	0x0649, r25
    3982:	80 93 48 06 	sts	0x0648, r24
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}

		uxTaskNumber++;
    3986:	80 91 53 06 	lds	r24, 0x0653
    398a:	8f 5f       	subi	r24, 0xFF	; 255
    398c:	80 93 53 06 	sts	0x0653, r24
			pxNewTCB->uxTCBNumber = uxTaskNumber;
		}
		#endif /* configUSE_TRACE_FACILITY */
		traceTASK_CREATE( pxNewTCB );

		prvAddTaskToReadyList( pxNewTCB );
    3990:	e9 81       	ldd	r30, Y+1	; 0x01
    3992:	fa 81       	ldd	r31, Y+2	; 0x02
    3994:	96 89       	ldd	r25, Z+22	; 0x16
    3996:	80 91 4e 06 	lds	r24, 0x064E
    399a:	89 17       	cp	r24, r25
    399c:	28 f4       	brcc	.+10     	; 0x39a8 <prvAddNewTaskToReadyList+0x8e>
    399e:	e9 81       	ldd	r30, Y+1	; 0x01
    39a0:	fa 81       	ldd	r31, Y+2	; 0x02
    39a2:	86 89       	ldd	r24, Z+22	; 0x16
    39a4:	80 93 4e 06 	sts	0x064E, r24
    39a8:	e9 81       	ldd	r30, Y+1	; 0x01
    39aa:	fa 81       	ldd	r31, Y+2	; 0x02
    39ac:	86 89       	ldd	r24, Z+22	; 0x16
    39ae:	28 2f       	mov	r18, r24
    39b0:	30 e0       	ldi	r19, 0x00	; 0
    39b2:	c9 01       	movw	r24, r18
    39b4:	88 0f       	add	r24, r24
    39b6:	99 1f       	adc	r25, r25
    39b8:	88 0f       	add	r24, r24
    39ba:	99 1f       	adc	r25, r25
    39bc:	88 0f       	add	r24, r24
    39be:	99 1f       	adc	r25, r25
    39c0:	82 0f       	add	r24, r18
    39c2:	93 1f       	adc	r25, r19
    39c4:	ac 01       	movw	r20, r24
    39c6:	47 5a       	subi	r20, 0xA7	; 167
    39c8:	59 4f       	sbci	r21, 0xF9	; 249
    39ca:	89 81       	ldd	r24, Y+1	; 0x01
    39cc:	9a 81       	ldd	r25, Y+2	; 0x02
    39ce:	9c 01       	movw	r18, r24
    39d0:	2e 5f       	subi	r18, 0xFE	; 254
    39d2:	3f 4f       	sbci	r19, 0xFF	; 255
    39d4:	ca 01       	movw	r24, r20
    39d6:	b9 01       	movw	r22, r18
    39d8:	0e 94 e0 06 	call	0xdc0	; 0xdc0 <vListInsertEnd>

		portSETUP_TCB( pxNewTCB );
	}
	taskEXIT_CRITICAL();
    39dc:	0f 90       	pop	r0
    39de:	0f be       	out	0x3f, r0	; 63

	if( xSchedulerRunning != pdFALSE )
    39e0:	80 91 4f 06 	lds	r24, 0x064F
    39e4:	88 23       	and	r24, r24
    39e6:	61 f0       	breq	.+24     	; 0x3a00 <prvAddNewTaskToReadyList+0xe6>
	{
		/* If the created task is of a higher priority than the current task
		then it should run now. */
		if( pxCurrentTCB->uxPriority < pxNewTCB->uxPriority )
    39e8:	e0 91 48 06 	lds	r30, 0x0648
    39ec:	f0 91 49 06 	lds	r31, 0x0649
    39f0:	96 89       	ldd	r25, Z+22	; 0x16
    39f2:	e9 81       	ldd	r30, Y+1	; 0x01
    39f4:	fa 81       	ldd	r31, Y+2	; 0x02
    39f6:	86 89       	ldd	r24, Z+22	; 0x16
    39f8:	98 17       	cp	r25, r24
    39fa:	10 f4       	brcc	.+4      	; 0x3a00 <prvAddNewTaskToReadyList+0xe6>
		{
			taskYIELD_IF_USING_PREEMPTION();
    39fc:	0e 94 3c 0a 	call	0x1478	; 0x1478 <vPortYield>
	}
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}
}
    3a00:	0f 90       	pop	r0
    3a02:	0f 90       	pop	r0
    3a04:	cf 91       	pop	r28
    3a06:	df 91       	pop	r29
    3a08:	08 95       	ret

00003a0a <vTaskDelete>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelete == 1 )

	void vTaskDelete( TaskHandle_t xTaskToDelete )
	{
    3a0a:	df 93       	push	r29
    3a0c:	cf 93       	push	r28
    3a0e:	00 d0       	rcall	.+0      	; 0x3a10 <vTaskDelete+0x6>
    3a10:	00 d0       	rcall	.+0      	; 0x3a12 <vTaskDelete+0x8>
    3a12:	00 d0       	rcall	.+0      	; 0x3a14 <vTaskDelete+0xa>
    3a14:	cd b7       	in	r28, 0x3d	; 61
    3a16:	de b7       	in	r29, 0x3e	; 62
    3a18:	9c 83       	std	Y+4, r25	; 0x04
    3a1a:	8b 83       	std	Y+3, r24	; 0x03
	TCB_t *pxTCB;

		taskENTER_CRITICAL();
    3a1c:	0f b6       	in	r0, 0x3f	; 63
    3a1e:	f8 94       	cli
    3a20:	0f 92       	push	r0
		{
			/* If null is passed in here then it is the calling task that is
			being deleted. */
			pxTCB = prvGetTCBFromHandle( xTaskToDelete );
    3a22:	8b 81       	ldd	r24, Y+3	; 0x03
    3a24:	9c 81       	ldd	r25, Y+4	; 0x04
    3a26:	00 97       	sbiw	r24, 0x00	; 0
    3a28:	39 f4       	brne	.+14     	; 0x3a38 <vTaskDelete+0x2e>
    3a2a:	80 91 48 06 	lds	r24, 0x0648
    3a2e:	90 91 49 06 	lds	r25, 0x0649
    3a32:	9e 83       	std	Y+6, r25	; 0x06
    3a34:	8d 83       	std	Y+5, r24	; 0x05
    3a36:	04 c0       	rjmp	.+8      	; 0x3a40 <vTaskDelete+0x36>
    3a38:	8b 81       	ldd	r24, Y+3	; 0x03
    3a3a:	9c 81       	ldd	r25, Y+4	; 0x04
    3a3c:	9e 83       	std	Y+6, r25	; 0x06
    3a3e:	8d 83       	std	Y+5, r24	; 0x05
    3a40:	8d 81       	ldd	r24, Y+5	; 0x05
    3a42:	9e 81       	ldd	r25, Y+6	; 0x06
    3a44:	9a 83       	std	Y+2, r25	; 0x02
    3a46:	89 83       	std	Y+1, r24	; 0x01

			/* Remove task from the ready list. */
			if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
    3a48:	89 81       	ldd	r24, Y+1	; 0x01
    3a4a:	9a 81       	ldd	r25, Y+2	; 0x02
    3a4c:	02 96       	adiw	r24, 0x02	; 2
    3a4e:	0e 94 90 07 	call	0xf20	; 0xf20 <uxListRemove>
			{
				mtCOVERAGE_TEST_MARKER();
			}

			/* Is the task waiting on an event also? */
			if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
    3a52:	e9 81       	ldd	r30, Y+1	; 0x01
    3a54:	fa 81       	ldd	r31, Y+2	; 0x02
    3a56:	84 89       	ldd	r24, Z+20	; 0x14
    3a58:	95 89       	ldd	r25, Z+21	; 0x15
    3a5a:	00 97       	sbiw	r24, 0x00	; 0
    3a5c:	29 f0       	breq	.+10     	; 0x3a68 <vTaskDelete+0x5e>
			{
				( void ) uxListRemove( &( pxTCB->xEventListItem ) );
    3a5e:	89 81       	ldd	r24, Y+1	; 0x01
    3a60:	9a 81       	ldd	r25, Y+2	; 0x02
    3a62:	0c 96       	adiw	r24, 0x0c	; 12
    3a64:	0e 94 90 07 	call	0xf20	; 0xf20 <uxListRemove>

			/* Increment the uxTaskNumber also so kernel aware debuggers can
			detect that the task lists need re-generating.  This is done before
			portPRE_TASK_DELETE_HOOK() as in the Windows port that macro will
			not return. */
			uxTaskNumber++;
    3a68:	80 91 53 06 	lds	r24, 0x0653
    3a6c:	8f 5f       	subi	r24, 0xFF	; 255
    3a6e:	80 93 53 06 	sts	0x0653, r24

			if( pxTCB == pxCurrentTCB )
    3a72:	20 91 48 06 	lds	r18, 0x0648
    3a76:	30 91 49 06 	lds	r19, 0x0649
    3a7a:	89 81       	ldd	r24, Y+1	; 0x01
    3a7c:	9a 81       	ldd	r25, Y+2	; 0x02
    3a7e:	82 17       	cp	r24, r18
    3a80:	93 07       	cpc	r25, r19
    3a82:	81 f4       	brne	.+32     	; 0x3aa4 <vTaskDelete+0x9a>
				/* A task is deleting itself.  This cannot complete within the
				task itself, as a context switch to another task is required.
				Place the task in the termination list.  The idle task will
				check the termination list and free up any memory allocated by
				the scheduler for the TCB and stack of the deleted task. */
				vListInsertEnd( &xTasksWaitingTermination, &( pxTCB->xStateListItem ) );
    3a84:	89 81       	ldd	r24, Y+1	; 0x01
    3a86:	9a 81       	ldd	r25, Y+2	; 0x02
    3a88:	9c 01       	movw	r18, r24
    3a8a:	2e 5f       	subi	r18, 0xFE	; 254
    3a8c:	3f 4f       	sbci	r19, 0xFF	; 255
    3a8e:	8c e9       	ldi	r24, 0x9C	; 156
    3a90:	96 e0       	ldi	r25, 0x06	; 6
    3a92:	b9 01       	movw	r22, r18
    3a94:	0e 94 e0 06 	call	0xdc0	; 0xdc0 <vListInsertEnd>

				/* Increment the ucTasksDeleted variable so the idle task knows
				there is a task that has been deleted and that it should therefore
				check the xTasksWaitingTermination list. */
				++uxDeletedTasksWaitingCleanUp;
    3a98:	80 91 4a 06 	lds	r24, 0x064A
    3a9c:	8f 5f       	subi	r24, 0xFF	; 255
    3a9e:	80 93 4a 06 	sts	0x064A, r24
    3aa2:	0b c0       	rjmp	.+22     	; 0x3aba <vTaskDelete+0xb0>
				required. */
				portPRE_TASK_DELETE_HOOK( pxTCB, &xYieldPending );
			}
			else
			{
				--uxCurrentNumberOfTasks;
    3aa4:	80 91 4b 06 	lds	r24, 0x064B
    3aa8:	81 50       	subi	r24, 0x01	; 1
    3aaa:	80 93 4b 06 	sts	0x064B, r24
				prvDeleteTCB( pxTCB );
    3aae:	89 81       	ldd	r24, Y+1	; 0x01
    3ab0:	9a 81       	ldd	r25, Y+2	; 0x02
    3ab2:	0e 94 d4 23 	call	0x47a8	; 0x47a8 <prvDeleteTCB>

				/* Reset the next expected unblock time in case it referred to
				the task that has just been deleted. */
				prvResetNextTaskUnblockTime();
    3ab6:	0e 94 ea 23 	call	0x47d4	; 0x47d4 <prvResetNextTaskUnblockTime>
			}

			traceTASK_DELETE( pxTCB );
		}
		taskEXIT_CRITICAL();
    3aba:	0f 90       	pop	r0
    3abc:	0f be       	out	0x3f, r0	; 63

		/* Force a reschedule if it is the currently running task that has just
		been deleted. */
		if( xSchedulerRunning != pdFALSE )
    3abe:	80 91 4f 06 	lds	r24, 0x064F
    3ac2:	88 23       	and	r24, r24
    3ac4:	59 f0       	breq	.+22     	; 0x3adc <vTaskDelete+0xd2>
		{
			if( pxTCB == pxCurrentTCB )
    3ac6:	20 91 48 06 	lds	r18, 0x0648
    3aca:	30 91 49 06 	lds	r19, 0x0649
    3ace:	89 81       	ldd	r24, Y+1	; 0x01
    3ad0:	9a 81       	ldd	r25, Y+2	; 0x02
    3ad2:	82 17       	cp	r24, r18
    3ad4:	93 07       	cpc	r25, r19
    3ad6:	11 f4       	brne	.+4      	; 0x3adc <vTaskDelete+0xd2>
			{
				configASSERT( uxSchedulerSuspended == 0 );
				portYIELD_WITHIN_API();
    3ad8:	0e 94 3c 0a 	call	0x1478	; 0x1478 <vPortYield>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
	}
    3adc:	26 96       	adiw	r28, 0x06	; 6
    3ade:	0f b6       	in	r0, 0x3f	; 63
    3ae0:	f8 94       	cli
    3ae2:	de bf       	out	0x3e, r29	; 62
    3ae4:	0f be       	out	0x3f, r0	; 63
    3ae6:	cd bf       	out	0x3d, r28	; 61
    3ae8:	cf 91       	pop	r28
    3aea:	df 91       	pop	r29
    3aec:	08 95       	ret

00003aee <vTaskDelay>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelay == 1 )

	void vTaskDelay( const TickType_t xTicksToDelay )
	{
    3aee:	df 93       	push	r29
    3af0:	cf 93       	push	r28
    3af2:	00 d0       	rcall	.+0      	; 0x3af4 <vTaskDelay+0x6>
    3af4:	0f 92       	push	r0
    3af6:	cd b7       	in	r28, 0x3d	; 61
    3af8:	de b7       	in	r29, 0x3e	; 62
    3afa:	9b 83       	std	Y+3, r25	; 0x03
    3afc:	8a 83       	std	Y+2, r24	; 0x02
	BaseType_t xAlreadyYielded = pdFALSE;
    3afe:	19 82       	std	Y+1, r1	; 0x01

		/* A delay time of zero just forces a reschedule. */
		if( xTicksToDelay > ( TickType_t ) 0U )
    3b00:	8a 81       	ldd	r24, Y+2	; 0x02
    3b02:	9b 81       	ldd	r25, Y+3	; 0x03
    3b04:	00 97       	sbiw	r24, 0x00	; 0
    3b06:	51 f0       	breq	.+20     	; 0x3b1c <vTaskDelay+0x2e>
		{
			configASSERT( uxSchedulerSuspended == 0 );
			vTaskSuspendAll();
    3b08:	0e 94 44 1f 	call	0x3e88	; 0x3e88 <vTaskSuspendAll>
				list or removed from the blocked list until the scheduler
				is resumed.

				This task cannot be in an event list as it is the currently
				executing task. */
				prvAddCurrentTaskToDelayedList( xTicksToDelay, pdFALSE );
    3b0c:	8a 81       	ldd	r24, Y+2	; 0x02
    3b0e:	9b 81       	ldd	r25, Y+3	; 0x03
    3b10:	60 e0       	ldi	r22, 0x00	; 0
    3b12:	0e 94 b3 29 	call	0x5366	; 0x5366 <prvAddCurrentTaskToDelayedList>
			}
			xAlreadyYielded = xTaskResumeAll();
    3b16:	0e 94 50 1f 	call	0x3ea0	; 0x3ea0 <xTaskResumeAll>
    3b1a:	89 83       	std	Y+1, r24	; 0x01
			mtCOVERAGE_TEST_MARKER();
		}

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
    3b1c:	89 81       	ldd	r24, Y+1	; 0x01
    3b1e:	88 23       	and	r24, r24
    3b20:	11 f4       	brne	.+4      	; 0x3b26 <vTaskDelay+0x38>
		{
			portYIELD_WITHIN_API();
    3b22:	0e 94 3c 0a 	call	0x1478	; 0x1478 <vPortYield>
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
    3b26:	0f 90       	pop	r0
    3b28:	0f 90       	pop	r0
    3b2a:	0f 90       	pop	r0
    3b2c:	cf 91       	pop	r28
    3b2e:	df 91       	pop	r29
    3b30:	08 95       	ret

00003b32 <vTaskSuspend>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskSuspend == 1 )

	void vTaskSuspend( TaskHandle_t xTaskToSuspend )
	{
    3b32:	df 93       	push	r29
    3b34:	cf 93       	push	r28
    3b36:	00 d0       	rcall	.+0      	; 0x3b38 <vTaskSuspend+0x6>
    3b38:	00 d0       	rcall	.+0      	; 0x3b3a <vTaskSuspend+0x8>
    3b3a:	00 d0       	rcall	.+0      	; 0x3b3c <vTaskSuspend+0xa>
    3b3c:	cd b7       	in	r28, 0x3d	; 61
    3b3e:	de b7       	in	r29, 0x3e	; 62
    3b40:	9c 83       	std	Y+4, r25	; 0x04
    3b42:	8b 83       	std	Y+3, r24	; 0x03
	TCB_t *pxTCB;

		taskENTER_CRITICAL();
    3b44:	0f b6       	in	r0, 0x3f	; 63
    3b46:	f8 94       	cli
    3b48:	0f 92       	push	r0
		{
			/* If null is passed in here then it is the running task that is
			being suspended. */
			pxTCB = prvGetTCBFromHandle( xTaskToSuspend );
    3b4a:	8b 81       	ldd	r24, Y+3	; 0x03
    3b4c:	9c 81       	ldd	r25, Y+4	; 0x04
    3b4e:	00 97       	sbiw	r24, 0x00	; 0
    3b50:	39 f4       	brne	.+14     	; 0x3b60 <vTaskSuspend+0x2e>
    3b52:	80 91 48 06 	lds	r24, 0x0648
    3b56:	90 91 49 06 	lds	r25, 0x0649
    3b5a:	9e 83       	std	Y+6, r25	; 0x06
    3b5c:	8d 83       	std	Y+5, r24	; 0x05
    3b5e:	04 c0       	rjmp	.+8      	; 0x3b68 <vTaskSuspend+0x36>
    3b60:	8b 81       	ldd	r24, Y+3	; 0x03
    3b62:	9c 81       	ldd	r25, Y+4	; 0x04
    3b64:	9e 83       	std	Y+6, r25	; 0x06
    3b66:	8d 83       	std	Y+5, r24	; 0x05
    3b68:	8d 81       	ldd	r24, Y+5	; 0x05
    3b6a:	9e 81       	ldd	r25, Y+6	; 0x06
    3b6c:	9a 83       	std	Y+2, r25	; 0x02
    3b6e:	89 83       	std	Y+1, r24	; 0x01

			traceTASK_SUSPEND( pxTCB );

			/* Remove task from the ready/delayed list and place in the
			suspended list. */
			if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
    3b70:	89 81       	ldd	r24, Y+1	; 0x01
    3b72:	9a 81       	ldd	r25, Y+2	; 0x02
    3b74:	02 96       	adiw	r24, 0x02	; 2
    3b76:	0e 94 90 07 	call	0xf20	; 0xf20 <uxListRemove>
			{
				mtCOVERAGE_TEST_MARKER();
			}

			/* Is the task waiting on an event also? */
			if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
    3b7a:	e9 81       	ldd	r30, Y+1	; 0x01
    3b7c:	fa 81       	ldd	r31, Y+2	; 0x02
    3b7e:	84 89       	ldd	r24, Z+20	; 0x14
    3b80:	95 89       	ldd	r25, Z+21	; 0x15
    3b82:	00 97       	sbiw	r24, 0x00	; 0
    3b84:	29 f0       	breq	.+10     	; 0x3b90 <vTaskSuspend+0x5e>
			{
				( void ) uxListRemove( &( pxTCB->xEventListItem ) );
    3b86:	89 81       	ldd	r24, Y+1	; 0x01
    3b88:	9a 81       	ldd	r25, Y+2	; 0x02
    3b8a:	0c 96       	adiw	r24, 0x0c	; 12
    3b8c:	0e 94 90 07 	call	0xf20	; 0xf20 <uxListRemove>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}

			vListInsertEnd( &xSuspendedTaskList, &( pxTCB->xStateListItem ) );
    3b90:	89 81       	ldd	r24, Y+1	; 0x01
    3b92:	9a 81       	ldd	r25, Y+2	; 0x02
    3b94:	9c 01       	movw	r18, r24
    3b96:	2e 5f       	subi	r18, 0xFE	; 254
    3b98:	3f 4f       	sbci	r19, 0xFF	; 255
    3b9a:	85 ea       	ldi	r24, 0xA5	; 165
    3b9c:	96 e0       	ldi	r25, 0x06	; 6
    3b9e:	b9 01       	movw	r22, r18
    3ba0:	0e 94 e0 06 	call	0xdc0	; 0xdc0 <vListInsertEnd>

			#if( configUSE_TASK_NOTIFICATIONS == 1 )
			{
				if( pxTCB->ucNotifyState == taskWAITING_NOTIFICATION )
    3ba4:	e9 81       	ldd	r30, Y+1	; 0x01
    3ba6:	fa 81       	ldd	r31, Y+2	; 0x02
    3ba8:	81 a5       	ldd	r24, Z+41	; 0x29
    3baa:	81 30       	cpi	r24, 0x01	; 1
    3bac:	19 f4       	brne	.+6      	; 0x3bb4 <vTaskSuspend+0x82>
				{
					/* The task was blocked to wait for a notification, but is
					now suspended, so no notification was received. */
					pxTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
    3bae:	e9 81       	ldd	r30, Y+1	; 0x01
    3bb0:	fa 81       	ldd	r31, Y+2	; 0x02
    3bb2:	11 a6       	std	Z+41, r1	; 0x29
				}
			}
			#endif
		}
		taskEXIT_CRITICAL();
    3bb4:	0f 90       	pop	r0
    3bb6:	0f be       	out	0x3f, r0	; 63

		if( xSchedulerRunning != pdFALSE )
    3bb8:	80 91 4f 06 	lds	r24, 0x064F
    3bbc:	88 23       	and	r24, r24
    3bbe:	39 f0       	breq	.+14     	; 0x3bce <vTaskSuspend+0x9c>
		{
			/* Reset the next expected unblock time in case it referred to the
			task that is now in the Suspended state. */
			taskENTER_CRITICAL();
    3bc0:	0f b6       	in	r0, 0x3f	; 63
    3bc2:	f8 94       	cli
    3bc4:	0f 92       	push	r0
			{
				prvResetNextTaskUnblockTime();
    3bc6:	0e 94 ea 23 	call	0x47d4	; 0x47d4 <prvResetNextTaskUnblockTime>
			}
			taskEXIT_CRITICAL();
    3bca:	0f 90       	pop	r0
    3bcc:	0f be       	out	0x3f, r0	; 63
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}

		if( pxTCB == pxCurrentTCB )
    3bce:	20 91 48 06 	lds	r18, 0x0648
    3bd2:	30 91 49 06 	lds	r19, 0x0649
    3bd6:	89 81       	ldd	r24, Y+1	; 0x01
    3bd8:	9a 81       	ldd	r25, Y+2	; 0x02
    3bda:	82 17       	cp	r24, r18
    3bdc:	93 07       	cpc	r25, r19
    3bde:	a1 f4       	brne	.+40     	; 0x3c08 <vTaskSuspend+0xd6>
		{
			if( xSchedulerRunning != pdFALSE )
    3be0:	80 91 4f 06 	lds	r24, 0x064F
    3be4:	88 23       	and	r24, r24
    3be6:	19 f0       	breq	.+6      	; 0x3bee <vTaskSuspend+0xbc>
			{
				/* The current task has just been suspended. */
				configASSERT( uxSchedulerSuspended == 0 );
				portYIELD_WITHIN_API();
    3be8:	0e 94 3c 0a 	call	0x1478	; 0x1478 <vPortYield>
    3bec:	0d c0       	rjmp	.+26     	; 0x3c08 <vTaskSuspend+0xd6>
			else
			{
				/* The scheduler is not running, but the task that was pointed
				to by pxCurrentTCB has just been suspended and pxCurrentTCB
				must be adjusted to point to a different task. */
				if( listCURRENT_LIST_LENGTH( &xSuspendedTaskList ) == uxCurrentNumberOfTasks ) /*lint !e931 Right has no side effect, just volatile. */
    3bee:	90 91 a5 06 	lds	r25, 0x06A5
    3bf2:	80 91 4b 06 	lds	r24, 0x064B
    3bf6:	98 17       	cp	r25, r24
    3bf8:	29 f4       	brne	.+10     	; 0x3c04 <vTaskSuspend+0xd2>
				{
					/* No other tasks are ready, so set pxCurrentTCB back to
					NULL so when the next task is created pxCurrentTCB will
					be set to point to it no matter what its relative priority
					is. */
					pxCurrentTCB = NULL;
    3bfa:	10 92 49 06 	sts	0x0649, r1
    3bfe:	10 92 48 06 	sts	0x0648, r1
    3c02:	02 c0       	rjmp	.+4      	; 0x3c08 <vTaskSuspend+0xd6>
				}
				else
				{
					vTaskSwitchContext();
    3c04:	0e 94 25 21 	call	0x424a	; 0x424a <vTaskSwitchContext>
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
    3c08:	26 96       	adiw	r28, 0x06	; 6
    3c0a:	0f b6       	in	r0, 0x3f	; 63
    3c0c:	f8 94       	cli
    3c0e:	de bf       	out	0x3e, r29	; 62
    3c10:	0f be       	out	0x3f, r0	; 63
    3c12:	cd bf       	out	0x3d, r28	; 61
    3c14:	cf 91       	pop	r28
    3c16:	df 91       	pop	r29
    3c18:	08 95       	ret

00003c1a <prvTaskIsTaskSuspended>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskSuspend == 1 )

	static BaseType_t prvTaskIsTaskSuspended( const TaskHandle_t xTask )
	{
    3c1a:	df 93       	push	r29
    3c1c:	cf 93       	push	r28
    3c1e:	00 d0       	rcall	.+0      	; 0x3c20 <prvTaskIsTaskSuspended+0x6>
    3c20:	00 d0       	rcall	.+0      	; 0x3c22 <prvTaskIsTaskSuspended+0x8>
    3c22:	0f 92       	push	r0
    3c24:	cd b7       	in	r28, 0x3d	; 61
    3c26:	de b7       	in	r29, 0x3e	; 62
    3c28:	9d 83       	std	Y+5, r25	; 0x05
    3c2a:	8c 83       	std	Y+4, r24	; 0x04
	BaseType_t xReturn = pdFALSE;
    3c2c:	1b 82       	std	Y+3, r1	; 0x03
	const TCB_t * const pxTCB = xTask;
    3c2e:	8c 81       	ldd	r24, Y+4	; 0x04
    3c30:	9d 81       	ldd	r25, Y+5	; 0x05
    3c32:	9a 83       	std	Y+2, r25	; 0x02
    3c34:	89 83       	std	Y+1, r24	; 0x01

		/* It does not make sense to check if the calling task is suspended. */
		configASSERT( xTask );

		/* Is the task being resumed actually in the suspended list? */
		if( listIS_CONTAINED_WITHIN( &xSuspendedTaskList, &( pxTCB->xStateListItem ) ) != pdFALSE )
    3c36:	e9 81       	ldd	r30, Y+1	; 0x01
    3c38:	fa 81       	ldd	r31, Y+2	; 0x02
    3c3a:	82 85       	ldd	r24, Z+10	; 0x0a
    3c3c:	93 85       	ldd	r25, Z+11	; 0x0b
    3c3e:	26 e0       	ldi	r18, 0x06	; 6
    3c40:	85 3a       	cpi	r24, 0xA5	; 165
    3c42:	92 07       	cpc	r25, r18
    3c44:	81 f4       	brne	.+32     	; 0x3c66 <prvTaskIsTaskSuspended+0x4c>
		{
			/* Has the task already been resumed from within an ISR? */
			if( listIS_CONTAINED_WITHIN( &xPendingReadyList, &( pxTCB->xEventListItem ) ) == pdFALSE )
    3c46:	e9 81       	ldd	r30, Y+1	; 0x01
    3c48:	fa 81       	ldd	r31, Y+2	; 0x02
    3c4a:	84 89       	ldd	r24, Z+20	; 0x14
    3c4c:	95 89       	ldd	r25, Z+21	; 0x15
    3c4e:	26 e0       	ldi	r18, 0x06	; 6
    3c50:	83 39       	cpi	r24, 0x93	; 147
    3c52:	92 07       	cpc	r25, r18
    3c54:	41 f0       	breq	.+16     	; 0x3c66 <prvTaskIsTaskSuspended+0x4c>
			{
				/* Is it in the suspended list because it is in the	Suspended
				state, or because is is blocked with no timeout? */
				if( listIS_CONTAINED_WITHIN( NULL, &( pxTCB->xEventListItem ) ) != pdFALSE ) /*lint !e961.  The cast is only redundant when NULL is used. */
    3c56:	e9 81       	ldd	r30, Y+1	; 0x01
    3c58:	fa 81       	ldd	r31, Y+2	; 0x02
    3c5a:	84 89       	ldd	r24, Z+20	; 0x14
    3c5c:	95 89       	ldd	r25, Z+21	; 0x15
    3c5e:	00 97       	sbiw	r24, 0x00	; 0
    3c60:	11 f4       	brne	.+4      	; 0x3c66 <prvTaskIsTaskSuspended+0x4c>
				{
					xReturn = pdTRUE;
    3c62:	81 e0       	ldi	r24, 0x01	; 1
    3c64:	8b 83       	std	Y+3, r24	; 0x03
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}

		return xReturn;
    3c66:	8b 81       	ldd	r24, Y+3	; 0x03
	} /*lint !e818 xTask cannot be a pointer to const because it is a typedef. */
    3c68:	0f 90       	pop	r0
    3c6a:	0f 90       	pop	r0
    3c6c:	0f 90       	pop	r0
    3c6e:	0f 90       	pop	r0
    3c70:	0f 90       	pop	r0
    3c72:	cf 91       	pop	r28
    3c74:	df 91       	pop	r29
    3c76:	08 95       	ret

00003c78 <vTaskResume>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskSuspend == 1 )

	void vTaskResume( TaskHandle_t xTaskToResume )
	{
    3c78:	df 93       	push	r29
    3c7a:	cf 93       	push	r28
    3c7c:	00 d0       	rcall	.+0      	; 0x3c7e <vTaskResume+0x6>
    3c7e:	00 d0       	rcall	.+0      	; 0x3c80 <vTaskResume+0x8>
    3c80:	cd b7       	in	r28, 0x3d	; 61
    3c82:	de b7       	in	r29, 0x3e	; 62
    3c84:	9c 83       	std	Y+4, r25	; 0x04
    3c86:	8b 83       	std	Y+3, r24	; 0x03
	TCB_t * const pxTCB = xTaskToResume;
    3c88:	8b 81       	ldd	r24, Y+3	; 0x03
    3c8a:	9c 81       	ldd	r25, Y+4	; 0x04
    3c8c:	9a 83       	std	Y+2, r25	; 0x02
    3c8e:	89 83       	std	Y+1, r24	; 0x01
		/* It does not make sense to resume the calling task. */
		configASSERT( xTaskToResume );

		/* The parameter cannot be NULL as it is impossible to resume the
		currently executing task. */
		if( ( pxTCB != pxCurrentTCB ) && ( pxTCB != NULL ) )
    3c90:	20 91 48 06 	lds	r18, 0x0648
    3c94:	30 91 49 06 	lds	r19, 0x0649
    3c98:	89 81       	ldd	r24, Y+1	; 0x01
    3c9a:	9a 81       	ldd	r25, Y+2	; 0x02
    3c9c:	82 17       	cp	r24, r18
    3c9e:	93 07       	cpc	r25, r19
    3ca0:	09 f4       	brne	.+2      	; 0x3ca4 <vTaskResume+0x2c>
    3ca2:	47 c0       	rjmp	.+142    	; 0x3d32 <vTaskResume+0xba>
    3ca4:	89 81       	ldd	r24, Y+1	; 0x01
    3ca6:	9a 81       	ldd	r25, Y+2	; 0x02
    3ca8:	00 97       	sbiw	r24, 0x00	; 0
    3caa:	09 f4       	brne	.+2      	; 0x3cae <vTaskResume+0x36>
    3cac:	42 c0       	rjmp	.+132    	; 0x3d32 <vTaskResume+0xba>
		{
			taskENTER_CRITICAL();
    3cae:	0f b6       	in	r0, 0x3f	; 63
    3cb0:	f8 94       	cli
    3cb2:	0f 92       	push	r0
			{
				if( prvTaskIsTaskSuspended( pxTCB ) != pdFALSE )
    3cb4:	89 81       	ldd	r24, Y+1	; 0x01
    3cb6:	9a 81       	ldd	r25, Y+2	; 0x02
    3cb8:	0e 94 0d 1e 	call	0x3c1a	; 0x3c1a <prvTaskIsTaskSuspended>
    3cbc:	88 23       	and	r24, r24
    3cbe:	b9 f1       	breq	.+110    	; 0x3d2e <vTaskResume+0xb6>
				{
					traceTASK_RESUME( pxTCB );

					/* The ready list can be accessed even if the scheduler is
					suspended because this is inside a critical section. */
					( void ) uxListRemove(  &( pxTCB->xStateListItem ) );
    3cc0:	89 81       	ldd	r24, Y+1	; 0x01
    3cc2:	9a 81       	ldd	r25, Y+2	; 0x02
    3cc4:	02 96       	adiw	r24, 0x02	; 2
    3cc6:	0e 94 90 07 	call	0xf20	; 0xf20 <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
    3cca:	e9 81       	ldd	r30, Y+1	; 0x01
    3ccc:	fa 81       	ldd	r31, Y+2	; 0x02
    3cce:	96 89       	ldd	r25, Z+22	; 0x16
    3cd0:	80 91 4e 06 	lds	r24, 0x064E
    3cd4:	89 17       	cp	r24, r25
    3cd6:	28 f4       	brcc	.+10     	; 0x3ce2 <vTaskResume+0x6a>
    3cd8:	e9 81       	ldd	r30, Y+1	; 0x01
    3cda:	fa 81       	ldd	r31, Y+2	; 0x02
    3cdc:	86 89       	ldd	r24, Z+22	; 0x16
    3cde:	80 93 4e 06 	sts	0x064E, r24
    3ce2:	e9 81       	ldd	r30, Y+1	; 0x01
    3ce4:	fa 81       	ldd	r31, Y+2	; 0x02
    3ce6:	86 89       	ldd	r24, Z+22	; 0x16
    3ce8:	28 2f       	mov	r18, r24
    3cea:	30 e0       	ldi	r19, 0x00	; 0
    3cec:	c9 01       	movw	r24, r18
    3cee:	88 0f       	add	r24, r24
    3cf0:	99 1f       	adc	r25, r25
    3cf2:	88 0f       	add	r24, r24
    3cf4:	99 1f       	adc	r25, r25
    3cf6:	88 0f       	add	r24, r24
    3cf8:	99 1f       	adc	r25, r25
    3cfa:	82 0f       	add	r24, r18
    3cfc:	93 1f       	adc	r25, r19
    3cfe:	ac 01       	movw	r20, r24
    3d00:	47 5a       	subi	r20, 0xA7	; 167
    3d02:	59 4f       	sbci	r21, 0xF9	; 249
    3d04:	89 81       	ldd	r24, Y+1	; 0x01
    3d06:	9a 81       	ldd	r25, Y+2	; 0x02
    3d08:	9c 01       	movw	r18, r24
    3d0a:	2e 5f       	subi	r18, 0xFE	; 254
    3d0c:	3f 4f       	sbci	r19, 0xFF	; 255
    3d0e:	ca 01       	movw	r24, r20
    3d10:	b9 01       	movw	r22, r18
    3d12:	0e 94 e0 06 	call	0xdc0	; 0xdc0 <vListInsertEnd>

					/* A higher priority task may have just been resumed. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    3d16:	e9 81       	ldd	r30, Y+1	; 0x01
    3d18:	fa 81       	ldd	r31, Y+2	; 0x02
    3d1a:	96 89       	ldd	r25, Z+22	; 0x16
    3d1c:	e0 91 48 06 	lds	r30, 0x0648
    3d20:	f0 91 49 06 	lds	r31, 0x0649
    3d24:	86 89       	ldd	r24, Z+22	; 0x16
    3d26:	98 17       	cp	r25, r24
    3d28:	10 f0       	brcs	.+4      	; 0x3d2e <vTaskResume+0xb6>
					{
						/* This yield may not cause the task just resumed to run,
						but will leave the lists in the correct state for the
						next yield. */
						taskYIELD_IF_USING_PREEMPTION();
    3d2a:	0e 94 3c 0a 	call	0x1478	; 0x1478 <vPortYield>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}
			}
			taskEXIT_CRITICAL();
    3d2e:	0f 90       	pop	r0
    3d30:	0f be       	out	0x3f, r0	; 63
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
    3d32:	0f 90       	pop	r0
    3d34:	0f 90       	pop	r0
    3d36:	0f 90       	pop	r0
    3d38:	0f 90       	pop	r0
    3d3a:	cf 91       	pop	r28
    3d3c:	df 91       	pop	r29
    3d3e:	08 95       	ret

00003d40 <xTaskResumeFromISR>:
/*-----------------------------------------------------------*/

#if ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) )

	BaseType_t xTaskResumeFromISR( TaskHandle_t xTaskToResume )
	{
    3d40:	df 93       	push	r29
    3d42:	cf 93       	push	r28
    3d44:	00 d0       	rcall	.+0      	; 0x3d46 <xTaskResumeFromISR+0x6>
    3d46:	00 d0       	rcall	.+0      	; 0x3d48 <xTaskResumeFromISR+0x8>
    3d48:	00 d0       	rcall	.+0      	; 0x3d4a <xTaskResumeFromISR+0xa>
    3d4a:	cd b7       	in	r28, 0x3d	; 61
    3d4c:	de b7       	in	r29, 0x3e	; 62
    3d4e:	9e 83       	std	Y+6, r25	; 0x06
    3d50:	8d 83       	std	Y+5, r24	; 0x05
	BaseType_t xYieldRequired = pdFALSE;
    3d52:	1c 82       	std	Y+4, r1	; 0x04
	TCB_t * const pxTCB = xTaskToResume;
    3d54:	8d 81       	ldd	r24, Y+5	; 0x05
    3d56:	9e 81       	ldd	r25, Y+6	; 0x06
    3d58:	9b 83       	std	Y+3, r25	; 0x03
    3d5a:	8a 83       	std	Y+2, r24	; 0x02
		simple as possible.  More information (albeit Cortex-M specific) is
		provided on the following link:
		https://www.freertos.org/RTOS-Cortex-M3-M4.html */
		portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

		uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    3d5c:	19 82       	std	Y+1, r1	; 0x01
		{
			if( prvTaskIsTaskSuspended( pxTCB ) != pdFALSE )
    3d5e:	8a 81       	ldd	r24, Y+2	; 0x02
    3d60:	9b 81       	ldd	r25, Y+3	; 0x03
    3d62:	0e 94 0d 1e 	call	0x3c1a	; 0x3c1a <prvTaskIsTaskSuspended>
    3d66:	88 23       	and	r24, r24
    3d68:	09 f4       	brne	.+2      	; 0x3d6c <xTaskResumeFromISR+0x2c>
    3d6a:	46 c0       	rjmp	.+140    	; 0x3df8 <xTaskResumeFromISR+0xb8>
			{
				traceTASK_RESUME_FROM_ISR( pxTCB );

				/* Check the ready lists can be accessed. */
				if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    3d6c:	80 91 58 06 	lds	r24, 0x0658
    3d70:	88 23       	and	r24, r24
    3d72:	c1 f5       	brne	.+112    	; 0x3de4 <xTaskResumeFromISR+0xa4>
				{
					/* Ready lists can be accessed so move the task from the
					suspended list to the ready list directly. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    3d74:	ea 81       	ldd	r30, Y+2	; 0x02
    3d76:	fb 81       	ldd	r31, Y+3	; 0x03
    3d78:	96 89       	ldd	r25, Z+22	; 0x16
    3d7a:	e0 91 48 06 	lds	r30, 0x0648
    3d7e:	f0 91 49 06 	lds	r31, 0x0649
    3d82:	86 89       	ldd	r24, Z+22	; 0x16
    3d84:	98 17       	cp	r25, r24
    3d86:	10 f0       	brcs	.+4      	; 0x3d8c <xTaskResumeFromISR+0x4c>
					{
						xYieldRequired = pdTRUE;
    3d88:	81 e0       	ldi	r24, 0x01	; 1
    3d8a:	8c 83       	std	Y+4, r24	; 0x04
					else
					{
						mtCOVERAGE_TEST_MARKER();
					}

					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    3d8c:	8a 81       	ldd	r24, Y+2	; 0x02
    3d8e:	9b 81       	ldd	r25, Y+3	; 0x03
    3d90:	02 96       	adiw	r24, 0x02	; 2
    3d92:	0e 94 90 07 	call	0xf20	; 0xf20 <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
    3d96:	ea 81       	ldd	r30, Y+2	; 0x02
    3d98:	fb 81       	ldd	r31, Y+3	; 0x03
    3d9a:	96 89       	ldd	r25, Z+22	; 0x16
    3d9c:	80 91 4e 06 	lds	r24, 0x064E
    3da0:	89 17       	cp	r24, r25
    3da2:	28 f4       	brcc	.+10     	; 0x3dae <xTaskResumeFromISR+0x6e>
    3da4:	ea 81       	ldd	r30, Y+2	; 0x02
    3da6:	fb 81       	ldd	r31, Y+3	; 0x03
    3da8:	86 89       	ldd	r24, Z+22	; 0x16
    3daa:	80 93 4e 06 	sts	0x064E, r24
    3dae:	ea 81       	ldd	r30, Y+2	; 0x02
    3db0:	fb 81       	ldd	r31, Y+3	; 0x03
    3db2:	86 89       	ldd	r24, Z+22	; 0x16
    3db4:	28 2f       	mov	r18, r24
    3db6:	30 e0       	ldi	r19, 0x00	; 0
    3db8:	c9 01       	movw	r24, r18
    3dba:	88 0f       	add	r24, r24
    3dbc:	99 1f       	adc	r25, r25
    3dbe:	88 0f       	add	r24, r24
    3dc0:	99 1f       	adc	r25, r25
    3dc2:	88 0f       	add	r24, r24
    3dc4:	99 1f       	adc	r25, r25
    3dc6:	82 0f       	add	r24, r18
    3dc8:	93 1f       	adc	r25, r19
    3dca:	ac 01       	movw	r20, r24
    3dcc:	47 5a       	subi	r20, 0xA7	; 167
    3dce:	59 4f       	sbci	r21, 0xF9	; 249
    3dd0:	8a 81       	ldd	r24, Y+2	; 0x02
    3dd2:	9b 81       	ldd	r25, Y+3	; 0x03
    3dd4:	9c 01       	movw	r18, r24
    3dd6:	2e 5f       	subi	r18, 0xFE	; 254
    3dd8:	3f 4f       	sbci	r19, 0xFF	; 255
    3dda:	ca 01       	movw	r24, r20
    3ddc:	b9 01       	movw	r22, r18
    3dde:	0e 94 e0 06 	call	0xdc0	; 0xdc0 <vListInsertEnd>
    3de2:	0a c0       	rjmp	.+20     	; 0x3df8 <xTaskResumeFromISR+0xb8>
				else
				{
					/* The delayed or ready lists cannot be accessed so the task
					is held in the pending ready list until the scheduler is
					unsuspended. */
					vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
    3de4:	8a 81       	ldd	r24, Y+2	; 0x02
    3de6:	9b 81       	ldd	r25, Y+3	; 0x03
    3de8:	9c 01       	movw	r18, r24
    3dea:	24 5f       	subi	r18, 0xF4	; 244
    3dec:	3f 4f       	sbci	r19, 0xFF	; 255
    3dee:	83 e9       	ldi	r24, 0x93	; 147
    3df0:	96 e0       	ldi	r25, 0x06	; 6
    3df2:	b9 01       	movw	r22, r18
    3df4:	0e 94 e0 06 	call	0xdc0	; 0xdc0 <vListInsertEnd>
				mtCOVERAGE_TEST_MARKER();
			}
		}
		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

		return xYieldRequired;
    3df8:	8c 81       	ldd	r24, Y+4	; 0x04
	}
    3dfa:	26 96       	adiw	r28, 0x06	; 6
    3dfc:	0f b6       	in	r0, 0x3f	; 63
    3dfe:	f8 94       	cli
    3e00:	de bf       	out	0x3e, r29	; 62
    3e02:	0f be       	out	0x3f, r0	; 63
    3e04:	cd bf       	out	0x3d, r28	; 61
    3e06:	cf 91       	pop	r28
    3e08:	df 91       	pop	r29
    3e0a:	08 95       	ret

00003e0c <vTaskStartScheduler>:

#endif /* ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) ) */
/*-----------------------------------------------------------*/

void vTaskStartScheduler( void )
{
    3e0c:	ef 92       	push	r14
    3e0e:	ff 92       	push	r15
    3e10:	0f 93       	push	r16
    3e12:	df 93       	push	r29
    3e14:	cf 93       	push	r28
    3e16:	0f 92       	push	r0
    3e18:	cd b7       	in	r28, 0x3d	; 61
    3e1a:	de b7       	in	r29, 0x3e	; 62
		}
	}
	#else
	{
		/* The Idle task is being created using dynamically allocated RAM. */
		xReturn = xTaskCreate(	prvIdleTask,
    3e1c:	8a e5       	ldi	r24, 0x5A	; 90
    3e1e:	93 e2       	ldi	r25, 0x23	; 35
    3e20:	20 e6       	ldi	r18, 0x60	; 96
    3e22:	30 e0       	ldi	r19, 0x00	; 0
    3e24:	e6 e5       	ldi	r30, 0x56	; 86
    3e26:	f6 e0       	ldi	r31, 0x06	; 6
    3e28:	b9 01       	movw	r22, r18
    3e2a:	45 e5       	ldi	r20, 0x55	; 85
    3e2c:	50 e0       	ldi	r21, 0x00	; 0
    3e2e:	20 e0       	ldi	r18, 0x00	; 0
    3e30:	30 e0       	ldi	r19, 0x00	; 0
    3e32:	00 e0       	ldi	r16, 0x00	; 0
    3e34:	7f 01       	movw	r14, r30
    3e36:	0e 94 52 1b 	call	0x36a4	; 0x36a4 <xTaskCreate>
    3e3a:	89 83       	std	Y+1, r24	; 0x01
			mtCOVERAGE_TEST_MARKER();
		}
	}
	#endif /* configUSE_TIMERS */

	if( xReturn == pdPASS )
    3e3c:	89 81       	ldd	r24, Y+1	; 0x01
    3e3e:	81 30       	cpi	r24, 0x01	; 1
    3e40:	81 f4       	brne	.+32     	; 0x3e62 <vTaskStartScheduler+0x56>
		/* Interrupts are turned off here, to ensure a tick does not occur
		before or during the call to xPortStartScheduler().  The stacks of
		the created tasks contain a status word with interrupts switched on
		so interrupts will automatically get re-enabled when the first task
		starts to run. */
		portDISABLE_INTERRUPTS();
    3e42:	f8 94       	cli
			structure specific to the task that will run first. */
			_impure_ptr = &( pxCurrentTCB->xNewLib_reent );
		}
		#endif /* configUSE_NEWLIB_REENTRANT */

		xNextTaskUnblockTime = portMAX_DELAY;
    3e44:	8f ef       	ldi	r24, 0xFF	; 255
    3e46:	9f ef       	ldi	r25, 0xFF	; 255
    3e48:	90 93 55 06 	sts	0x0655, r25
    3e4c:	80 93 54 06 	sts	0x0654, r24
		xSchedulerRunning = pdTRUE;
    3e50:	81 e0       	ldi	r24, 0x01	; 1
    3e52:	80 93 4f 06 	sts	0x064F, r24
		xTickCount = ( TickType_t ) configINITIAL_TICK_COUNT;
    3e56:	10 92 4d 06 	sts	0x064D, r1
    3e5a:	10 92 4c 06 	sts	0x064C, r1

		traceTASK_SWITCHED_IN();

		/* Setting up the timer tick is hardware specific and thus in the
		portable interface. */
		if( xPortStartScheduler() != pdFALSE )
    3e5e:	0e 94 00 0a 	call	0x1400	; 0x1400 <xPortStartScheduler>
	}

	/* Prevent compiler warnings if INCLUDE_xTaskGetIdleTaskHandle is set to 0,
	meaning xIdleTaskHandle is not used anywhere else. */
	( void ) xIdleTaskHandle;
}
    3e62:	0f 90       	pop	r0
    3e64:	cf 91       	pop	r28
    3e66:	df 91       	pop	r29
    3e68:	0f 91       	pop	r16
    3e6a:	ff 90       	pop	r15
    3e6c:	ef 90       	pop	r14
    3e6e:	08 95       	ret

00003e70 <vTaskEndScheduler>:
/*-----------------------------------------------------------*/

void vTaskEndScheduler( void )
{
    3e70:	df 93       	push	r29
    3e72:	cf 93       	push	r28
    3e74:	cd b7       	in	r28, 0x3d	; 61
    3e76:	de b7       	in	r29, 0x3e	; 62
	/* Stop the scheduler interrupts and call the portable scheduler end
	routine so the original ISRs can be restored if necessary.  The port
	layer must ensure interrupts enable	bit is left in the correct state. */
	portDISABLE_INTERRUPTS();
    3e78:	f8 94       	cli
	xSchedulerRunning = pdFALSE;
    3e7a:	10 92 4f 06 	sts	0x064F, r1
	vPortEndScheduler();
    3e7e:	0e 94 35 0a 	call	0x146a	; 0x146a <vPortEndScheduler>
}
    3e82:	cf 91       	pop	r28
    3e84:	df 91       	pop	r29
    3e86:	08 95       	ret

00003e88 <vTaskSuspendAll>:
/*----------------------------------------------------------*/

void vTaskSuspendAll( void )
{
    3e88:	df 93       	push	r29
    3e8a:	cf 93       	push	r28
    3e8c:	cd b7       	in	r28, 0x3d	; 61
    3e8e:	de b7       	in	r29, 0x3e	; 62
	/* A critical section is not required as the variable is of type
	BaseType_t.  Please read Richard Barry's reply in the following link to a
	post in the FreeRTOS support forum before reporting this as a bug! -
	http://goo.gl/wu4acr */
	++uxSchedulerSuspended;
    3e90:	80 91 58 06 	lds	r24, 0x0658
    3e94:	8f 5f       	subi	r24, 0xFF	; 255
    3e96:	80 93 58 06 	sts	0x0658, r24
}
    3e9a:	cf 91       	pop	r28
    3e9c:	df 91       	pop	r29
    3e9e:	08 95       	ret

00003ea0 <xTaskResumeAll>:

#endif /* configUSE_TICKLESS_IDLE */
/*----------------------------------------------------------*/

BaseType_t xTaskResumeAll( void )
{
    3ea0:	df 93       	push	r29
    3ea2:	cf 93       	push	r28
    3ea4:	00 d0       	rcall	.+0      	; 0x3ea6 <xTaskResumeAll+0x6>
    3ea6:	00 d0       	rcall	.+0      	; 0x3ea8 <xTaskResumeAll+0x8>
    3ea8:	cd b7       	in	r28, 0x3d	; 61
    3eaa:	de b7       	in	r29, 0x3e	; 62
TCB_t *pxTCB = NULL;
    3eac:	1c 82       	std	Y+4, r1	; 0x04
    3eae:	1b 82       	std	Y+3, r1	; 0x03
BaseType_t xAlreadyYielded = pdFALSE;
    3eb0:	1a 82       	std	Y+2, r1	; 0x02
	/* It is possible that an ISR caused a task to be removed from an event
	list while the scheduler was suspended.  If this was the case then the
	removed task will have been added to the xPendingReadyList.  Once the
	scheduler has been resumed it is safe to move all the pending ready
	tasks from this list into their appropriate ready list. */
	taskENTER_CRITICAL();
    3eb2:	0f b6       	in	r0, 0x3f	; 63
    3eb4:	f8 94       	cli
    3eb6:	0f 92       	push	r0
	{
		--uxSchedulerSuspended;
    3eb8:	80 91 58 06 	lds	r24, 0x0658
    3ebc:	81 50       	subi	r24, 0x01	; 1
    3ebe:	80 93 58 06 	sts	0x0658, r24

		if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    3ec2:	80 91 58 06 	lds	r24, 0x0658
    3ec6:	88 23       	and	r24, r24
    3ec8:	09 f0       	breq	.+2      	; 0x3ecc <xTaskResumeAll+0x2c>
    3eca:	73 c0       	rjmp	.+230    	; 0x3fb2 <xTaskResumeAll+0x112>
		{
			if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
    3ecc:	80 91 4b 06 	lds	r24, 0x064B
    3ed0:	88 23       	and	r24, r24
    3ed2:	09 f4       	brne	.+2      	; 0x3ed6 <xTaskResumeAll+0x36>
    3ed4:	6e c0       	rjmp	.+220    	; 0x3fb2 <xTaskResumeAll+0x112>
    3ed6:	45 c0       	rjmp	.+138    	; 0x3f62 <xTaskResumeAll+0xc2>
			{
				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
				{
					pxTCB = listGET_OWNER_OF_HEAD_ENTRY( ( &xPendingReadyList ) ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    3ed8:	e0 91 98 06 	lds	r30, 0x0698
    3edc:	f0 91 99 06 	lds	r31, 0x0699
    3ee0:	86 81       	ldd	r24, Z+6	; 0x06
    3ee2:	97 81       	ldd	r25, Z+7	; 0x07
    3ee4:	9c 83       	std	Y+4, r25	; 0x04
    3ee6:	8b 83       	std	Y+3, r24	; 0x03
					( void ) uxListRemove( &( pxTCB->xEventListItem ) );
    3ee8:	8b 81       	ldd	r24, Y+3	; 0x03
    3eea:	9c 81       	ldd	r25, Y+4	; 0x04
    3eec:	0c 96       	adiw	r24, 0x0c	; 12
    3eee:	0e 94 90 07 	call	0xf20	; 0xf20 <uxListRemove>
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    3ef2:	8b 81       	ldd	r24, Y+3	; 0x03
    3ef4:	9c 81       	ldd	r25, Y+4	; 0x04
    3ef6:	02 96       	adiw	r24, 0x02	; 2
    3ef8:	0e 94 90 07 	call	0xf20	; 0xf20 <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
    3efc:	eb 81       	ldd	r30, Y+3	; 0x03
    3efe:	fc 81       	ldd	r31, Y+4	; 0x04
    3f00:	96 89       	ldd	r25, Z+22	; 0x16
    3f02:	80 91 4e 06 	lds	r24, 0x064E
    3f06:	89 17       	cp	r24, r25
    3f08:	28 f4       	brcc	.+10     	; 0x3f14 <xTaskResumeAll+0x74>
    3f0a:	eb 81       	ldd	r30, Y+3	; 0x03
    3f0c:	fc 81       	ldd	r31, Y+4	; 0x04
    3f0e:	86 89       	ldd	r24, Z+22	; 0x16
    3f10:	80 93 4e 06 	sts	0x064E, r24
    3f14:	eb 81       	ldd	r30, Y+3	; 0x03
    3f16:	fc 81       	ldd	r31, Y+4	; 0x04
    3f18:	86 89       	ldd	r24, Z+22	; 0x16
    3f1a:	28 2f       	mov	r18, r24
    3f1c:	30 e0       	ldi	r19, 0x00	; 0
    3f1e:	c9 01       	movw	r24, r18
    3f20:	88 0f       	add	r24, r24
    3f22:	99 1f       	adc	r25, r25
    3f24:	88 0f       	add	r24, r24
    3f26:	99 1f       	adc	r25, r25
    3f28:	88 0f       	add	r24, r24
    3f2a:	99 1f       	adc	r25, r25
    3f2c:	82 0f       	add	r24, r18
    3f2e:	93 1f       	adc	r25, r19
    3f30:	ac 01       	movw	r20, r24
    3f32:	47 5a       	subi	r20, 0xA7	; 167
    3f34:	59 4f       	sbci	r21, 0xF9	; 249
    3f36:	8b 81       	ldd	r24, Y+3	; 0x03
    3f38:	9c 81       	ldd	r25, Y+4	; 0x04
    3f3a:	9c 01       	movw	r18, r24
    3f3c:	2e 5f       	subi	r18, 0xFE	; 254
    3f3e:	3f 4f       	sbci	r19, 0xFF	; 255
    3f40:	ca 01       	movw	r24, r20
    3f42:	b9 01       	movw	r22, r18
    3f44:	0e 94 e0 06 	call	0xdc0	; 0xdc0 <vListInsertEnd>

					/* If the moved task has a priority higher than the current
					task then a yield must be performed. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    3f48:	eb 81       	ldd	r30, Y+3	; 0x03
    3f4a:	fc 81       	ldd	r31, Y+4	; 0x04
    3f4c:	96 89       	ldd	r25, Z+22	; 0x16
    3f4e:	e0 91 48 06 	lds	r30, 0x0648
    3f52:	f0 91 49 06 	lds	r31, 0x0649
    3f56:	86 89       	ldd	r24, Z+22	; 0x16
    3f58:	98 17       	cp	r25, r24
    3f5a:	18 f0       	brcs	.+6      	; 0x3f62 <xTaskResumeAll+0xc2>
					{
						xYieldPending = pdTRUE;
    3f5c:	81 e0       	ldi	r24, 0x01	; 1
    3f5e:	80 93 51 06 	sts	0x0651, r24
		{
			if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
			{
				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
    3f62:	80 91 93 06 	lds	r24, 0x0693
    3f66:	88 23       	and	r24, r24
    3f68:	09 f0       	breq	.+2      	; 0x3f6c <xTaskResumeAll+0xcc>
    3f6a:	b6 cf       	rjmp	.-148    	; 0x3ed8 <xTaskResumeAll+0x38>
					{
						mtCOVERAGE_TEST_MARKER();
					}
				}

				if( pxTCB != NULL )
    3f6c:	8b 81       	ldd	r24, Y+3	; 0x03
    3f6e:	9c 81       	ldd	r25, Y+4	; 0x04
    3f70:	00 97       	sbiw	r24, 0x00	; 0
    3f72:	11 f0       	breq	.+4      	; 0x3f78 <xTaskResumeAll+0xd8>
					which may have prevented the next unblock time from being
					re-calculated, in which case re-calculate it now.  Mainly
					important for low power tickless implementations, where
					this can prevent an unnecessary exit from low power
					state. */
					prvResetNextTaskUnblockTime();
    3f74:	0e 94 ea 23 	call	0x47d4	; 0x47d4 <prvResetNextTaskUnblockTime>
				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does
				not	slip, and that any delayed tasks are resumed at the correct
				time. */
				{
					UBaseType_t uxPendedCounts = uxPendedTicks; /* Non-volatile copy. */
    3f78:	80 91 50 06 	lds	r24, 0x0650
    3f7c:	89 83       	std	Y+1, r24	; 0x01

					if( uxPendedCounts > ( UBaseType_t ) 0U )
    3f7e:	89 81       	ldd	r24, Y+1	; 0x01
    3f80:	88 23       	and	r24, r24
    3f82:	79 f0       	breq	.+30     	; 0x3fa2 <xTaskResumeAll+0x102>
					{
						do
						{
							if( xTaskIncrementTick() != pdFALSE )
    3f84:	0e 94 40 20 	call	0x4080	; 0x4080 <xTaskIncrementTick>
    3f88:	88 23       	and	r24, r24
    3f8a:	19 f0       	breq	.+6      	; 0x3f92 <xTaskResumeAll+0xf2>
							{
								xYieldPending = pdTRUE;
    3f8c:	81 e0       	ldi	r24, 0x01	; 1
    3f8e:	80 93 51 06 	sts	0x0651, r24
							}
							else
							{
								mtCOVERAGE_TEST_MARKER();
							}
							--uxPendedCounts;
    3f92:	89 81       	ldd	r24, Y+1	; 0x01
    3f94:	81 50       	subi	r24, 0x01	; 1
    3f96:	89 83       	std	Y+1, r24	; 0x01
						} while( uxPendedCounts > ( UBaseType_t ) 0U );
    3f98:	89 81       	ldd	r24, Y+1	; 0x01
    3f9a:	88 23       	and	r24, r24
    3f9c:	99 f7       	brne	.-26     	; 0x3f84 <xTaskResumeAll+0xe4>

						uxPendedTicks = 0;
    3f9e:	10 92 50 06 	sts	0x0650, r1
					{
						mtCOVERAGE_TEST_MARKER();
					}
				}

				if( xYieldPending != pdFALSE )
    3fa2:	80 91 51 06 	lds	r24, 0x0651
    3fa6:	88 23       	and	r24, r24
    3fa8:	21 f0       	breq	.+8      	; 0x3fb2 <xTaskResumeAll+0x112>
				{
					#if( configUSE_PREEMPTION != 0 )
					{
						xAlreadyYielded = pdTRUE;
    3faa:	81 e0       	ldi	r24, 0x01	; 1
    3fac:	8a 83       	std	Y+2, r24	; 0x02
					}
					#endif
					taskYIELD_IF_USING_PREEMPTION();
    3fae:	0e 94 3c 0a 	call	0x1478	; 0x1478 <vPortYield>
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
	taskEXIT_CRITICAL();
    3fb2:	0f 90       	pop	r0
    3fb4:	0f be       	out	0x3f, r0	; 63

	return xAlreadyYielded;
    3fb6:	8a 81       	ldd	r24, Y+2	; 0x02
}
    3fb8:	0f 90       	pop	r0
    3fba:	0f 90       	pop	r0
    3fbc:	0f 90       	pop	r0
    3fbe:	0f 90       	pop	r0
    3fc0:	cf 91       	pop	r28
    3fc2:	df 91       	pop	r29
    3fc4:	08 95       	ret

00003fc6 <xTaskGetTickCount>:
/*-----------------------------------------------------------*/

TickType_t xTaskGetTickCount( void )
{
    3fc6:	df 93       	push	r29
    3fc8:	cf 93       	push	r28
    3fca:	00 d0       	rcall	.+0      	; 0x3fcc <xTaskGetTickCount+0x6>
    3fcc:	cd b7       	in	r28, 0x3d	; 61
    3fce:	de b7       	in	r29, 0x3e	; 62
TickType_t xTicks;

	/* Critical section required if running on a 16 bit processor. */
	portTICK_TYPE_ENTER_CRITICAL();
    3fd0:	0f b6       	in	r0, 0x3f	; 63
    3fd2:	f8 94       	cli
    3fd4:	0f 92       	push	r0
	{
		xTicks = xTickCount;
    3fd6:	80 91 4c 06 	lds	r24, 0x064C
    3fda:	90 91 4d 06 	lds	r25, 0x064D
    3fde:	9a 83       	std	Y+2, r25	; 0x02
    3fe0:	89 83       	std	Y+1, r24	; 0x01
	}
	portTICK_TYPE_EXIT_CRITICAL();
    3fe2:	0f 90       	pop	r0
    3fe4:	0f be       	out	0x3f, r0	; 63

	return xTicks;
    3fe6:	89 81       	ldd	r24, Y+1	; 0x01
    3fe8:	9a 81       	ldd	r25, Y+2	; 0x02
}
    3fea:	0f 90       	pop	r0
    3fec:	0f 90       	pop	r0
    3fee:	cf 91       	pop	r28
    3ff0:	df 91       	pop	r29
    3ff2:	08 95       	ret

00003ff4 <xTaskGetTickCountFromISR>:
/*-----------------------------------------------------------*/

TickType_t xTaskGetTickCountFromISR( void )
{
    3ff4:	df 93       	push	r29
    3ff6:	cf 93       	push	r28
    3ff8:	00 d0       	rcall	.+0      	; 0x3ffa <xTaskGetTickCountFromISR+0x6>
    3ffa:	0f 92       	push	r0
    3ffc:	cd b7       	in	r28, 0x3d	; 61
    3ffe:	de b7       	in	r29, 0x3e	; 62
	safe API to ensure interrupt entry is as fast and as simple as possible.
	More information (albeit Cortex-M specific) is provided on the following
	link: https://www.freertos.org/RTOS-Cortex-M3-M4.html */
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

	uxSavedInterruptStatus = portTICK_TYPE_SET_INTERRUPT_MASK_FROM_ISR();
    4000:	19 82       	std	Y+1, r1	; 0x01
	{
		xReturn = xTickCount;
    4002:	80 91 4c 06 	lds	r24, 0x064C
    4006:	90 91 4d 06 	lds	r25, 0x064D
    400a:	9b 83       	std	Y+3, r25	; 0x03
    400c:	8a 83       	std	Y+2, r24	; 0x02
	}
	portTICK_TYPE_CLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
    400e:	8a 81       	ldd	r24, Y+2	; 0x02
    4010:	9b 81       	ldd	r25, Y+3	; 0x03
}
    4012:	0f 90       	pop	r0
    4014:	0f 90       	pop	r0
    4016:	0f 90       	pop	r0
    4018:	cf 91       	pop	r28
    401a:	df 91       	pop	r29
    401c:	08 95       	ret

0000401e <uxTaskGetNumberOfTasks>:
/*-----------------------------------------------------------*/

UBaseType_t uxTaskGetNumberOfTasks( void )
{
    401e:	df 93       	push	r29
    4020:	cf 93       	push	r28
    4022:	cd b7       	in	r28, 0x3d	; 61
    4024:	de b7       	in	r29, 0x3e	; 62
	/* A critical section is not required because the variables are of type
	BaseType_t. */
	return uxCurrentNumberOfTasks;
    4026:	80 91 4b 06 	lds	r24, 0x064B
}
    402a:	cf 91       	pop	r28
    402c:	df 91       	pop	r29
    402e:	08 95       	ret

00004030 <pcTaskGetName>:
/*-----------------------------------------------------------*/

char *pcTaskGetName( TaskHandle_t xTaskToQuery ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
{
    4030:	df 93       	push	r29
    4032:	cf 93       	push	r28
    4034:	00 d0       	rcall	.+0      	; 0x4036 <pcTaskGetName+0x6>
    4036:	00 d0       	rcall	.+0      	; 0x4038 <pcTaskGetName+0x8>
    4038:	00 d0       	rcall	.+0      	; 0x403a <pcTaskGetName+0xa>
    403a:	cd b7       	in	r28, 0x3d	; 61
    403c:	de b7       	in	r29, 0x3e	; 62
    403e:	9c 83       	std	Y+4, r25	; 0x04
    4040:	8b 83       	std	Y+3, r24	; 0x03
TCB_t *pxTCB;

	/* If null is passed in here then the name of the calling task is being
	queried. */
	pxTCB = prvGetTCBFromHandle( xTaskToQuery );
    4042:	8b 81       	ldd	r24, Y+3	; 0x03
    4044:	9c 81       	ldd	r25, Y+4	; 0x04
    4046:	00 97       	sbiw	r24, 0x00	; 0
    4048:	39 f4       	brne	.+14     	; 0x4058 <pcTaskGetName+0x28>
    404a:	80 91 48 06 	lds	r24, 0x0648
    404e:	90 91 49 06 	lds	r25, 0x0649
    4052:	9e 83       	std	Y+6, r25	; 0x06
    4054:	8d 83       	std	Y+5, r24	; 0x05
    4056:	04 c0       	rjmp	.+8      	; 0x4060 <pcTaskGetName+0x30>
    4058:	8b 81       	ldd	r24, Y+3	; 0x03
    405a:	9c 81       	ldd	r25, Y+4	; 0x04
    405c:	9e 83       	std	Y+6, r25	; 0x06
    405e:	8d 83       	std	Y+5, r24	; 0x05
    4060:	8d 81       	ldd	r24, Y+5	; 0x05
    4062:	9e 81       	ldd	r25, Y+6	; 0x06
    4064:	9a 83       	std	Y+2, r25	; 0x02
    4066:	89 83       	std	Y+1, r24	; 0x01
	configASSERT( pxTCB );
	return &( pxTCB->pcTaskName[ 0 ] );
    4068:	89 81       	ldd	r24, Y+1	; 0x01
    406a:	9a 81       	ldd	r25, Y+2	; 0x02
    406c:	49 96       	adiw	r24, 0x19	; 25
}
    406e:	26 96       	adiw	r28, 0x06	; 6
    4070:	0f b6       	in	r0, 0x3f	; 63
    4072:	f8 94       	cli
    4074:	de bf       	out	0x3e, r29	; 62
    4076:	0f be       	out	0x3f, r0	; 63
    4078:	cd bf       	out	0x3d, r28	; 61
    407a:	cf 91       	pop	r28
    407c:	df 91       	pop	r29
    407e:	08 95       	ret

00004080 <xTaskIncrementTick>:

#endif /* INCLUDE_xTaskAbortDelay */
/*----------------------------------------------------------*/

BaseType_t xTaskIncrementTick( void )
{
    4080:	df 93       	push	r29
    4082:	cf 93       	push	r28
    4084:	cd b7       	in	r28, 0x3d	; 61
    4086:	de b7       	in	r29, 0x3e	; 62
    4088:	29 97       	sbiw	r28, 0x09	; 9
    408a:	0f b6       	in	r0, 0x3f	; 63
    408c:	f8 94       	cli
    408e:	de bf       	out	0x3e, r29	; 62
    4090:	0f be       	out	0x3f, r0	; 63
    4092:	cd bf       	out	0x3d, r28	; 61
TCB_t * pxTCB;
TickType_t xItemValue;
BaseType_t xSwitchRequired = pdFALSE;
    4094:	1d 82       	std	Y+5, r1	; 0x05

	/* Called by the portable layer each time a tick interrupt occurs.
	Increments the tick then checks to see if the new tick value will cause any
	tasks to be unblocked. */
	traceTASK_INCREMENT_TICK( xTickCount );
	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    4096:	80 91 58 06 	lds	r24, 0x0658
    409a:	88 23       	and	r24, r24
    409c:	09 f0       	breq	.+2      	; 0x40a0 <xTaskIncrementTick+0x20>
    409e:	c0 c0       	rjmp	.+384    	; 0x4220 <xTaskIncrementTick+0x1a0>
	{
		/* Minor optimisation.  The tick count cannot change in this
		block. */
		const TickType_t xConstTickCount = xTickCount + ( TickType_t ) 1;
    40a0:	80 91 4c 06 	lds	r24, 0x064C
    40a4:	90 91 4d 06 	lds	r25, 0x064D
    40a8:	01 96       	adiw	r24, 0x01	; 1
    40aa:	9c 83       	std	Y+4, r25	; 0x04
    40ac:	8b 83       	std	Y+3, r24	; 0x03

		/* Increment the RTOS tick, switching the delayed and overflowed
		delayed lists if it wraps to 0. */
		xTickCount = xConstTickCount;
    40ae:	8b 81       	ldd	r24, Y+3	; 0x03
    40b0:	9c 81       	ldd	r25, Y+4	; 0x04
    40b2:	90 93 4d 06 	sts	0x064D, r25
    40b6:	80 93 4c 06 	sts	0x064C, r24

		if( xConstTickCount == ( TickType_t ) 0U ) /*lint !e774 'if' does not always evaluate to false as it is looking for an overflow. */
    40ba:	8b 81       	ldd	r24, Y+3	; 0x03
    40bc:	9c 81       	ldd	r25, Y+4	; 0x04
    40be:	00 97       	sbiw	r24, 0x00	; 0
    40c0:	d9 f4       	brne	.+54     	; 0x40f8 <xTaskIncrementTick+0x78>
		{
			taskSWITCH_DELAYED_LISTS();
    40c2:	80 91 8f 06 	lds	r24, 0x068F
    40c6:	90 91 90 06 	lds	r25, 0x0690
    40ca:	9a 83       	std	Y+2, r25	; 0x02
    40cc:	89 83       	std	Y+1, r24	; 0x01
    40ce:	80 91 91 06 	lds	r24, 0x0691
    40d2:	90 91 92 06 	lds	r25, 0x0692
    40d6:	90 93 90 06 	sts	0x0690, r25
    40da:	80 93 8f 06 	sts	0x068F, r24
    40de:	89 81       	ldd	r24, Y+1	; 0x01
    40e0:	9a 81       	ldd	r25, Y+2	; 0x02
    40e2:	90 93 92 06 	sts	0x0692, r25
    40e6:	80 93 91 06 	sts	0x0691, r24
    40ea:	80 91 52 06 	lds	r24, 0x0652
    40ee:	8f 5f       	subi	r24, 0xFF	; 255
    40f0:	80 93 52 06 	sts	0x0652, r24
    40f4:	0e 94 ea 23 	call	0x47d4	; 0x47d4 <prvResetNextTaskUnblockTime>

		/* See if this tick has made a timeout expire.  Tasks are stored in
		the	queue in the order of their wake time - meaning once one task
		has been found whose block time has not expired there is no need to
		look any further down the list. */
		if( xConstTickCount >= xNextTaskUnblockTime )
    40f8:	20 91 54 06 	lds	r18, 0x0654
    40fc:	30 91 55 06 	lds	r19, 0x0655
    4100:	8b 81       	ldd	r24, Y+3	; 0x03
    4102:	9c 81       	ldd	r25, Y+4	; 0x04
    4104:	82 17       	cp	r24, r18
    4106:	93 07       	cpc	r25, r19
    4108:	08 f4       	brcc	.+2      	; 0x410c <xTaskIncrementTick+0x8c>
    410a:	71 c0       	rjmp	.+226    	; 0x41ee <xTaskIncrementTick+0x16e>
		{
			for( ;; )
			{
				if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
    410c:	e0 91 8f 06 	lds	r30, 0x068F
    4110:	f0 91 90 06 	lds	r31, 0x0690
    4114:	80 81       	ld	r24, Z
    4116:	88 23       	and	r24, r24
    4118:	39 f4       	brne	.+14     	; 0x4128 <xTaskIncrementTick+0xa8>
					/* The delayed list is empty.  Set xNextTaskUnblockTime
					to the maximum possible value so it is extremely
					unlikely that the
					if( xTickCount >= xNextTaskUnblockTime ) test will pass
					next time through. */
					xNextTaskUnblockTime = portMAX_DELAY; /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    411a:	8f ef       	ldi	r24, 0xFF	; 255
    411c:	9f ef       	ldi	r25, 0xFF	; 255
    411e:	90 93 55 06 	sts	0x0655, r25
    4122:	80 93 54 06 	sts	0x0654, r24
    4126:	63 c0       	rjmp	.+198    	; 0x41ee <xTaskIncrementTick+0x16e>
				{
					/* The delayed list is not empty, get the value of the
					item at the head of the delayed list.  This is the time
					at which the task at the head of the delayed list must
					be removed from the Blocked state. */
					pxTCB = listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    4128:	e0 91 8f 06 	lds	r30, 0x068F
    412c:	f0 91 90 06 	lds	r31, 0x0690
    4130:	05 80       	ldd	r0, Z+5	; 0x05
    4132:	f6 81       	ldd	r31, Z+6	; 0x06
    4134:	e0 2d       	mov	r30, r0
    4136:	86 81       	ldd	r24, Z+6	; 0x06
    4138:	97 81       	ldd	r25, Z+7	; 0x07
    413a:	99 87       	std	Y+9, r25	; 0x09
    413c:	88 87       	std	Y+8, r24	; 0x08
					xItemValue = listGET_LIST_ITEM_VALUE( &( pxTCB->xStateListItem ) );
    413e:	e8 85       	ldd	r30, Y+8	; 0x08
    4140:	f9 85       	ldd	r31, Y+9	; 0x09
    4142:	82 81       	ldd	r24, Z+2	; 0x02
    4144:	93 81       	ldd	r25, Z+3	; 0x03
    4146:	9f 83       	std	Y+7, r25	; 0x07
    4148:	8e 83       	std	Y+6, r24	; 0x06

					if( xConstTickCount < xItemValue )
    414a:	2b 81       	ldd	r18, Y+3	; 0x03
    414c:	3c 81       	ldd	r19, Y+4	; 0x04
    414e:	8e 81       	ldd	r24, Y+6	; 0x06
    4150:	9f 81       	ldd	r25, Y+7	; 0x07
    4152:	28 17       	cp	r18, r24
    4154:	39 07       	cpc	r19, r25
    4156:	38 f4       	brcc	.+14     	; 0x4166 <xTaskIncrementTick+0xe6>
						/* It is not time to unblock this item yet, but the
						item value is the time at which the task at the head
						of the blocked list must be removed from the Blocked
						state -	so record the item value in
						xNextTaskUnblockTime. */
						xNextTaskUnblockTime = xItemValue;
    4158:	8e 81       	ldd	r24, Y+6	; 0x06
    415a:	9f 81       	ldd	r25, Y+7	; 0x07
    415c:	90 93 55 06 	sts	0x0655, r25
    4160:	80 93 54 06 	sts	0x0654, r24
    4164:	44 c0       	rjmp	.+136    	; 0x41ee <xTaskIncrementTick+0x16e>
					{
						mtCOVERAGE_TEST_MARKER();
					}

					/* It is time to remove the item from the Blocked state. */
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    4166:	88 85       	ldd	r24, Y+8	; 0x08
    4168:	99 85       	ldd	r25, Y+9	; 0x09
    416a:	02 96       	adiw	r24, 0x02	; 2
    416c:	0e 94 90 07 	call	0xf20	; 0xf20 <uxListRemove>

					/* Is the task waiting on an event also?  If so remove
					it from the event list. */
					if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
    4170:	e8 85       	ldd	r30, Y+8	; 0x08
    4172:	f9 85       	ldd	r31, Y+9	; 0x09
    4174:	84 89       	ldd	r24, Z+20	; 0x14
    4176:	95 89       	ldd	r25, Z+21	; 0x15
    4178:	00 97       	sbiw	r24, 0x00	; 0
    417a:	29 f0       	breq	.+10     	; 0x4186 <xTaskIncrementTick+0x106>
					{
						( void ) uxListRemove( &( pxTCB->xEventListItem ) );
    417c:	88 85       	ldd	r24, Y+8	; 0x08
    417e:	99 85       	ldd	r25, Y+9	; 0x09
    4180:	0c 96       	adiw	r24, 0x0c	; 12
    4182:	0e 94 90 07 	call	0xf20	; 0xf20 <uxListRemove>
						mtCOVERAGE_TEST_MARKER();
					}

					/* Place the unblocked task into the appropriate ready
					list. */
					prvAddTaskToReadyList( pxTCB );
    4186:	e8 85       	ldd	r30, Y+8	; 0x08
    4188:	f9 85       	ldd	r31, Y+9	; 0x09
    418a:	96 89       	ldd	r25, Z+22	; 0x16
    418c:	80 91 4e 06 	lds	r24, 0x064E
    4190:	89 17       	cp	r24, r25
    4192:	28 f4       	brcc	.+10     	; 0x419e <xTaskIncrementTick+0x11e>
    4194:	e8 85       	ldd	r30, Y+8	; 0x08
    4196:	f9 85       	ldd	r31, Y+9	; 0x09
    4198:	86 89       	ldd	r24, Z+22	; 0x16
    419a:	80 93 4e 06 	sts	0x064E, r24
    419e:	e8 85       	ldd	r30, Y+8	; 0x08
    41a0:	f9 85       	ldd	r31, Y+9	; 0x09
    41a2:	86 89       	ldd	r24, Z+22	; 0x16
    41a4:	28 2f       	mov	r18, r24
    41a6:	30 e0       	ldi	r19, 0x00	; 0
    41a8:	c9 01       	movw	r24, r18
    41aa:	88 0f       	add	r24, r24
    41ac:	99 1f       	adc	r25, r25
    41ae:	88 0f       	add	r24, r24
    41b0:	99 1f       	adc	r25, r25
    41b2:	88 0f       	add	r24, r24
    41b4:	99 1f       	adc	r25, r25
    41b6:	82 0f       	add	r24, r18
    41b8:	93 1f       	adc	r25, r19
    41ba:	ac 01       	movw	r20, r24
    41bc:	47 5a       	subi	r20, 0xA7	; 167
    41be:	59 4f       	sbci	r21, 0xF9	; 249
    41c0:	88 85       	ldd	r24, Y+8	; 0x08
    41c2:	99 85       	ldd	r25, Y+9	; 0x09
    41c4:	9c 01       	movw	r18, r24
    41c6:	2e 5f       	subi	r18, 0xFE	; 254
    41c8:	3f 4f       	sbci	r19, 0xFF	; 255
    41ca:	ca 01       	movw	r24, r20
    41cc:	b9 01       	movw	r22, r18
    41ce:	0e 94 e0 06 	call	0xdc0	; 0xdc0 <vListInsertEnd>
					{
						/* Preemption is on, but a context switch should
						only be performed if the unblocked task has a
						priority that is equal to or higher than the
						currently executing task. */
						if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    41d2:	e8 85       	ldd	r30, Y+8	; 0x08
    41d4:	f9 85       	ldd	r31, Y+9	; 0x09
    41d6:	96 89       	ldd	r25, Z+22	; 0x16
    41d8:	e0 91 48 06 	lds	r30, 0x0648
    41dc:	f0 91 49 06 	lds	r31, 0x0649
    41e0:	86 89       	ldd	r24, Z+22	; 0x16
    41e2:	98 17       	cp	r25, r24
    41e4:	08 f4       	brcc	.+2      	; 0x41e8 <xTaskIncrementTick+0x168>
    41e6:	92 cf       	rjmp	.-220    	; 0x410c <xTaskIncrementTick+0x8c>
						{
							xSwitchRequired = pdTRUE;
    41e8:	81 e0       	ldi	r24, 0x01	; 1
    41ea:	8d 83       	std	Y+5, r24	; 0x05
    41ec:	8f cf       	rjmp	.-226    	; 0x410c <xTaskIncrementTick+0x8c>
		/* Tasks of equal priority to the currently running task will share
		processing time (time slice) if preemption is on, and the application
		writer has not explicitly turned time slicing off. */
		#if ( ( configUSE_PREEMPTION == 1 ) && ( configUSE_TIME_SLICING == 1 ) )
		{
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ pxCurrentTCB->uxPriority ] ) ) > ( UBaseType_t ) 1 )
    41ee:	e0 91 48 06 	lds	r30, 0x0648
    41f2:	f0 91 49 06 	lds	r31, 0x0649
    41f6:	86 89       	ldd	r24, Z+22	; 0x16
    41f8:	28 2f       	mov	r18, r24
    41fa:	30 e0       	ldi	r19, 0x00	; 0
    41fc:	c9 01       	movw	r24, r18
    41fe:	88 0f       	add	r24, r24
    4200:	99 1f       	adc	r25, r25
    4202:	88 0f       	add	r24, r24
    4204:	99 1f       	adc	r25, r25
    4206:	88 0f       	add	r24, r24
    4208:	99 1f       	adc	r25, r25
    420a:	82 0f       	add	r24, r18
    420c:	93 1f       	adc	r25, r19
    420e:	fc 01       	movw	r30, r24
    4210:	e7 5a       	subi	r30, 0xA7	; 167
    4212:	f9 4f       	sbci	r31, 0xF9	; 249
    4214:	80 81       	ld	r24, Z
    4216:	82 30       	cpi	r24, 0x02	; 2
    4218:	40 f0       	brcs	.+16     	; 0x422a <xTaskIncrementTick+0x1aa>
			{
				xSwitchRequired = pdTRUE;
    421a:	81 e0       	ldi	r24, 0x01	; 1
    421c:	8d 83       	std	Y+5, r24	; 0x05
    421e:	05 c0       	rjmp	.+10     	; 0x422a <xTaskIncrementTick+0x1aa>
		}
		#endif /* configUSE_TICK_HOOK */
	}
	else
	{
		++uxPendedTicks;
    4220:	80 91 50 06 	lds	r24, 0x0650
    4224:	8f 5f       	subi	r24, 0xFF	; 255
    4226:	80 93 50 06 	sts	0x0650, r24
		#endif
	}

	#if ( configUSE_PREEMPTION == 1 )
	{
		if( xYieldPending != pdFALSE )
    422a:	80 91 51 06 	lds	r24, 0x0651
    422e:	88 23       	and	r24, r24
    4230:	11 f0       	breq	.+4      	; 0x4236 <xTaskIncrementTick+0x1b6>
		{
			xSwitchRequired = pdTRUE;
    4232:	81 e0       	ldi	r24, 0x01	; 1
    4234:	8d 83       	std	Y+5, r24	; 0x05
			mtCOVERAGE_TEST_MARKER();
		}
	}
	#endif /* configUSE_PREEMPTION */

	return xSwitchRequired;
    4236:	8d 81       	ldd	r24, Y+5	; 0x05
}
    4238:	29 96       	adiw	r28, 0x09	; 9
    423a:	0f b6       	in	r0, 0x3f	; 63
    423c:	f8 94       	cli
    423e:	de bf       	out	0x3e, r29	; 62
    4240:	0f be       	out	0x3f, r0	; 63
    4242:	cd bf       	out	0x3d, r28	; 61
    4244:	cf 91       	pop	r28
    4246:	df 91       	pop	r29
    4248:	08 95       	ret

0000424a <vTaskSwitchContext>:

#endif /* configUSE_APPLICATION_TASK_TAG */
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
    424a:	df 93       	push	r29
    424c:	cf 93       	push	r28
    424e:	00 d0       	rcall	.+0      	; 0x4250 <vTaskSwitchContext+0x6>
    4250:	0f 92       	push	r0
    4252:	cd b7       	in	r28, 0x3d	; 61
    4254:	de b7       	in	r29, 0x3e	; 62
	if( uxSchedulerSuspended != ( UBaseType_t ) pdFALSE )
    4256:	80 91 58 06 	lds	r24, 0x0658
    425a:	88 23       	and	r24, r24
    425c:	21 f0       	breq	.+8      	; 0x4266 <vTaskSwitchContext+0x1c>
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xYieldPending = pdTRUE;
    425e:	81 e0       	ldi	r24, 0x01	; 1
    4260:	80 93 51 06 	sts	0x0651, r24
    4264:	59 c0       	rjmp	.+178    	; 0x4318 <vTaskSwitchContext+0xce>
	}
	else
	{
		xYieldPending = pdFALSE;
    4266:	10 92 51 06 	sts	0x0651, r1
		}
		#endif

		/* Select a new task to run using either the generic C or port
		optimised asm code. */
		taskSELECT_HIGHEST_PRIORITY_TASK(); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    426a:	80 91 4e 06 	lds	r24, 0x064E
    426e:	8b 83       	std	Y+3, r24	; 0x03
    4270:	03 c0       	rjmp	.+6      	; 0x4278 <vTaskSwitchContext+0x2e>
    4272:	8b 81       	ldd	r24, Y+3	; 0x03
    4274:	81 50       	subi	r24, 0x01	; 1
    4276:	8b 83       	std	Y+3, r24	; 0x03
    4278:	8b 81       	ldd	r24, Y+3	; 0x03
    427a:	28 2f       	mov	r18, r24
    427c:	30 e0       	ldi	r19, 0x00	; 0
    427e:	c9 01       	movw	r24, r18
    4280:	88 0f       	add	r24, r24
    4282:	99 1f       	adc	r25, r25
    4284:	88 0f       	add	r24, r24
    4286:	99 1f       	adc	r25, r25
    4288:	88 0f       	add	r24, r24
    428a:	99 1f       	adc	r25, r25
    428c:	82 0f       	add	r24, r18
    428e:	93 1f       	adc	r25, r19
    4290:	fc 01       	movw	r30, r24
    4292:	e7 5a       	subi	r30, 0xA7	; 167
    4294:	f9 4f       	sbci	r31, 0xF9	; 249
    4296:	80 81       	ld	r24, Z
    4298:	88 23       	and	r24, r24
    429a:	59 f3       	breq	.-42     	; 0x4272 <vTaskSwitchContext+0x28>
    429c:	8b 81       	ldd	r24, Y+3	; 0x03
    429e:	28 2f       	mov	r18, r24
    42a0:	30 e0       	ldi	r19, 0x00	; 0
    42a2:	c9 01       	movw	r24, r18
    42a4:	88 0f       	add	r24, r24
    42a6:	99 1f       	adc	r25, r25
    42a8:	88 0f       	add	r24, r24
    42aa:	99 1f       	adc	r25, r25
    42ac:	88 0f       	add	r24, r24
    42ae:	99 1f       	adc	r25, r25
    42b0:	82 0f       	add	r24, r18
    42b2:	93 1f       	adc	r25, r19
    42b4:	87 5a       	subi	r24, 0xA7	; 167
    42b6:	99 4f       	sbci	r25, 0xF9	; 249
    42b8:	9a 83       	std	Y+2, r25	; 0x02
    42ba:	89 83       	std	Y+1, r24	; 0x01
    42bc:	e9 81       	ldd	r30, Y+1	; 0x01
    42be:	fa 81       	ldd	r31, Y+2	; 0x02
    42c0:	01 80       	ldd	r0, Z+1	; 0x01
    42c2:	f2 81       	ldd	r31, Z+2	; 0x02
    42c4:	e0 2d       	mov	r30, r0
    42c6:	82 81       	ldd	r24, Z+2	; 0x02
    42c8:	93 81       	ldd	r25, Z+3	; 0x03
    42ca:	e9 81       	ldd	r30, Y+1	; 0x01
    42cc:	fa 81       	ldd	r31, Y+2	; 0x02
    42ce:	92 83       	std	Z+2, r25	; 0x02
    42d0:	81 83       	std	Z+1, r24	; 0x01
    42d2:	e9 81       	ldd	r30, Y+1	; 0x01
    42d4:	fa 81       	ldd	r31, Y+2	; 0x02
    42d6:	21 81       	ldd	r18, Z+1	; 0x01
    42d8:	32 81       	ldd	r19, Z+2	; 0x02
    42da:	89 81       	ldd	r24, Y+1	; 0x01
    42dc:	9a 81       	ldd	r25, Y+2	; 0x02
    42de:	03 96       	adiw	r24, 0x03	; 3
    42e0:	28 17       	cp	r18, r24
    42e2:	39 07       	cpc	r19, r25
    42e4:	59 f4       	brne	.+22     	; 0x42fc <vTaskSwitchContext+0xb2>
    42e6:	e9 81       	ldd	r30, Y+1	; 0x01
    42e8:	fa 81       	ldd	r31, Y+2	; 0x02
    42ea:	01 80       	ldd	r0, Z+1	; 0x01
    42ec:	f2 81       	ldd	r31, Z+2	; 0x02
    42ee:	e0 2d       	mov	r30, r0
    42f0:	82 81       	ldd	r24, Z+2	; 0x02
    42f2:	93 81       	ldd	r25, Z+3	; 0x03
    42f4:	e9 81       	ldd	r30, Y+1	; 0x01
    42f6:	fa 81       	ldd	r31, Y+2	; 0x02
    42f8:	92 83       	std	Z+2, r25	; 0x02
    42fa:	81 83       	std	Z+1, r24	; 0x01
    42fc:	e9 81       	ldd	r30, Y+1	; 0x01
    42fe:	fa 81       	ldd	r31, Y+2	; 0x02
    4300:	01 80       	ldd	r0, Z+1	; 0x01
    4302:	f2 81       	ldd	r31, Z+2	; 0x02
    4304:	e0 2d       	mov	r30, r0
    4306:	86 81       	ldd	r24, Z+6	; 0x06
    4308:	97 81       	ldd	r25, Z+7	; 0x07
    430a:	90 93 49 06 	sts	0x0649, r25
    430e:	80 93 48 06 	sts	0x0648, r24
    4312:	8b 81       	ldd	r24, Y+3	; 0x03
    4314:	80 93 4e 06 	sts	0x064E, r24
			structure specific to this task. */
			_impure_ptr = &( pxCurrentTCB->xNewLib_reent );
		}
		#endif /* configUSE_NEWLIB_REENTRANT */
	}
}
    4318:	0f 90       	pop	r0
    431a:	0f 90       	pop	r0
    431c:	0f 90       	pop	r0
    431e:	cf 91       	pop	r28
    4320:	df 91       	pop	r29
    4322:	08 95       	ret

00004324 <vTaskPlaceOnEventList>:
/*-----------------------------------------------------------*/

void vTaskPlaceOnEventList( List_t * const pxEventList, const TickType_t xTicksToWait )
{
    4324:	df 93       	push	r29
    4326:	cf 93       	push	r28
    4328:	00 d0       	rcall	.+0      	; 0x432a <vTaskPlaceOnEventList+0x6>
    432a:	00 d0       	rcall	.+0      	; 0x432c <vTaskPlaceOnEventList+0x8>
    432c:	cd b7       	in	r28, 0x3d	; 61
    432e:	de b7       	in	r29, 0x3e	; 62
    4330:	9a 83       	std	Y+2, r25	; 0x02
    4332:	89 83       	std	Y+1, r24	; 0x01
    4334:	7c 83       	std	Y+4, r23	; 0x04
    4336:	6b 83       	std	Y+3, r22	; 0x03

	/* Place the event list item of the TCB in the appropriate event list.
	This is placed in the list in priority order so the highest priority task
	is the first to be woken by the event.  The queue that contains the event
	list is locked, preventing simultaneous access from interrupts. */
	vListInsert( pxEventList, &( pxCurrentTCB->xEventListItem ) );
    4338:	80 91 48 06 	lds	r24, 0x0648
    433c:	90 91 49 06 	lds	r25, 0x0649
    4340:	9c 01       	movw	r18, r24
    4342:	24 5f       	subi	r18, 0xF4	; 244
    4344:	3f 4f       	sbci	r19, 0xFF	; 255
    4346:	89 81       	ldd	r24, Y+1	; 0x01
    4348:	9a 81       	ldd	r25, Y+2	; 0x02
    434a:	b9 01       	movw	r22, r18
    434c:	0e 94 24 07 	call	0xe48	; 0xe48 <vListInsert>

	prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
    4350:	8b 81       	ldd	r24, Y+3	; 0x03
    4352:	9c 81       	ldd	r25, Y+4	; 0x04
    4354:	61 e0       	ldi	r22, 0x01	; 1
    4356:	0e 94 b3 29 	call	0x5366	; 0x5366 <prvAddCurrentTaskToDelayedList>
}
    435a:	0f 90       	pop	r0
    435c:	0f 90       	pop	r0
    435e:	0f 90       	pop	r0
    4360:	0f 90       	pop	r0
    4362:	cf 91       	pop	r28
    4364:	df 91       	pop	r29
    4366:	08 95       	ret

00004368 <vTaskPlaceOnUnorderedEventList>:
/*-----------------------------------------------------------*/

void vTaskPlaceOnUnorderedEventList( List_t * pxEventList, const TickType_t xItemValue, const TickType_t xTicksToWait )
{
    4368:	df 93       	push	r29
    436a:	cf 93       	push	r28
    436c:	00 d0       	rcall	.+0      	; 0x436e <vTaskPlaceOnUnorderedEventList+0x6>
    436e:	00 d0       	rcall	.+0      	; 0x4370 <vTaskPlaceOnUnorderedEventList+0x8>
    4370:	00 d0       	rcall	.+0      	; 0x4372 <vTaskPlaceOnUnorderedEventList+0xa>
    4372:	cd b7       	in	r28, 0x3d	; 61
    4374:	de b7       	in	r29, 0x3e	; 62
    4376:	9a 83       	std	Y+2, r25	; 0x02
    4378:	89 83       	std	Y+1, r24	; 0x01
    437a:	7c 83       	std	Y+4, r23	; 0x04
    437c:	6b 83       	std	Y+3, r22	; 0x03
    437e:	5e 83       	std	Y+6, r21	; 0x06
    4380:	4d 83       	std	Y+5, r20	; 0x05
	configASSERT( uxSchedulerSuspended != 0 );

	/* Store the item value in the event list item.  It is safe to access the
	event list item here as interrupts won't access the event list item of a
	task that is not in the Blocked state. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), xItemValue | taskEVENT_LIST_ITEM_VALUE_IN_USE );
    4382:	e0 91 48 06 	lds	r30, 0x0648
    4386:	f0 91 49 06 	lds	r31, 0x0649
    438a:	8b 81       	ldd	r24, Y+3	; 0x03
    438c:	9c 81       	ldd	r25, Y+4	; 0x04
    438e:	90 68       	ori	r25, 0x80	; 128
    4390:	95 87       	std	Z+13, r25	; 0x0d
    4392:	84 87       	std	Z+12, r24	; 0x0c
	/* Place the event list item of the TCB at the end of the appropriate event
	list.  It is safe to access the event list here because it is part of an
	event group implementation - and interrupts don't access event groups
	directly (instead they access them indirectly by pending function calls to
	the task level). */
	vListInsertEnd( pxEventList, &( pxCurrentTCB->xEventListItem ) );
    4394:	80 91 48 06 	lds	r24, 0x0648
    4398:	90 91 49 06 	lds	r25, 0x0649
    439c:	9c 01       	movw	r18, r24
    439e:	24 5f       	subi	r18, 0xF4	; 244
    43a0:	3f 4f       	sbci	r19, 0xFF	; 255
    43a2:	89 81       	ldd	r24, Y+1	; 0x01
    43a4:	9a 81       	ldd	r25, Y+2	; 0x02
    43a6:	b9 01       	movw	r22, r18
    43a8:	0e 94 e0 06 	call	0xdc0	; 0xdc0 <vListInsertEnd>

	prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
    43ac:	8d 81       	ldd	r24, Y+5	; 0x05
    43ae:	9e 81       	ldd	r25, Y+6	; 0x06
    43b0:	61 e0       	ldi	r22, 0x01	; 1
    43b2:	0e 94 b3 29 	call	0x5366	; 0x5366 <prvAddCurrentTaskToDelayedList>
}
    43b6:	26 96       	adiw	r28, 0x06	; 6
    43b8:	0f b6       	in	r0, 0x3f	; 63
    43ba:	f8 94       	cli
    43bc:	de bf       	out	0x3e, r29	; 62
    43be:	0f be       	out	0x3f, r0	; 63
    43c0:	cd bf       	out	0x3d, r28	; 61
    43c2:	cf 91       	pop	r28
    43c4:	df 91       	pop	r29
    43c6:	08 95       	ret

000043c8 <xTaskRemoveFromEventList>:

#endif /* configUSE_TIMERS */
/*-----------------------------------------------------------*/

BaseType_t xTaskRemoveFromEventList( const List_t * const pxEventList )
{
    43c8:	df 93       	push	r29
    43ca:	cf 93       	push	r28
    43cc:	00 d0       	rcall	.+0      	; 0x43ce <xTaskRemoveFromEventList+0x6>
    43ce:	00 d0       	rcall	.+0      	; 0x43d0 <xTaskRemoveFromEventList+0x8>
    43d0:	0f 92       	push	r0
    43d2:	cd b7       	in	r28, 0x3d	; 61
    43d4:	de b7       	in	r29, 0x3e	; 62
    43d6:	9d 83       	std	Y+5, r25	; 0x05
    43d8:	8c 83       	std	Y+4, r24	; 0x04
	get called - the lock count on the queue will get modified instead.  This
	means exclusive access to the event list is guaranteed here.

	This function assumes that a check has already been made to ensure that
	pxEventList is not empty. */
	pxUnblockedTCB = listGET_OWNER_OF_HEAD_ENTRY( pxEventList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    43da:	ec 81       	ldd	r30, Y+4	; 0x04
    43dc:	fd 81       	ldd	r31, Y+5	; 0x05
    43de:	05 80       	ldd	r0, Z+5	; 0x05
    43e0:	f6 81       	ldd	r31, Z+6	; 0x06
    43e2:	e0 2d       	mov	r30, r0
    43e4:	86 81       	ldd	r24, Z+6	; 0x06
    43e6:	97 81       	ldd	r25, Z+7	; 0x07
    43e8:	9b 83       	std	Y+3, r25	; 0x03
    43ea:	8a 83       	std	Y+2, r24	; 0x02
	configASSERT( pxUnblockedTCB );
	( void ) uxListRemove( &( pxUnblockedTCB->xEventListItem ) );
    43ec:	8a 81       	ldd	r24, Y+2	; 0x02
    43ee:	9b 81       	ldd	r25, Y+3	; 0x03
    43f0:	0c 96       	adiw	r24, 0x0c	; 12
    43f2:	0e 94 90 07 	call	0xf20	; 0xf20 <uxListRemove>

	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    43f6:	80 91 58 06 	lds	r24, 0x0658
    43fa:	88 23       	and	r24, r24
    43fc:	61 f5       	brne	.+88     	; 0x4456 <xTaskRemoveFromEventList+0x8e>
	{
		( void ) uxListRemove( &( pxUnblockedTCB->xStateListItem ) );
    43fe:	8a 81       	ldd	r24, Y+2	; 0x02
    4400:	9b 81       	ldd	r25, Y+3	; 0x03
    4402:	02 96       	adiw	r24, 0x02	; 2
    4404:	0e 94 90 07 	call	0xf20	; 0xf20 <uxListRemove>
		prvAddTaskToReadyList( pxUnblockedTCB );
    4408:	ea 81       	ldd	r30, Y+2	; 0x02
    440a:	fb 81       	ldd	r31, Y+3	; 0x03
    440c:	96 89       	ldd	r25, Z+22	; 0x16
    440e:	80 91 4e 06 	lds	r24, 0x064E
    4412:	89 17       	cp	r24, r25
    4414:	28 f4       	brcc	.+10     	; 0x4420 <xTaskRemoveFromEventList+0x58>
    4416:	ea 81       	ldd	r30, Y+2	; 0x02
    4418:	fb 81       	ldd	r31, Y+3	; 0x03
    441a:	86 89       	ldd	r24, Z+22	; 0x16
    441c:	80 93 4e 06 	sts	0x064E, r24
    4420:	ea 81       	ldd	r30, Y+2	; 0x02
    4422:	fb 81       	ldd	r31, Y+3	; 0x03
    4424:	86 89       	ldd	r24, Z+22	; 0x16
    4426:	28 2f       	mov	r18, r24
    4428:	30 e0       	ldi	r19, 0x00	; 0
    442a:	c9 01       	movw	r24, r18
    442c:	88 0f       	add	r24, r24
    442e:	99 1f       	adc	r25, r25
    4430:	88 0f       	add	r24, r24
    4432:	99 1f       	adc	r25, r25
    4434:	88 0f       	add	r24, r24
    4436:	99 1f       	adc	r25, r25
    4438:	82 0f       	add	r24, r18
    443a:	93 1f       	adc	r25, r19
    443c:	ac 01       	movw	r20, r24
    443e:	47 5a       	subi	r20, 0xA7	; 167
    4440:	59 4f       	sbci	r21, 0xF9	; 249
    4442:	8a 81       	ldd	r24, Y+2	; 0x02
    4444:	9b 81       	ldd	r25, Y+3	; 0x03
    4446:	9c 01       	movw	r18, r24
    4448:	2e 5f       	subi	r18, 0xFE	; 254
    444a:	3f 4f       	sbci	r19, 0xFF	; 255
    444c:	ca 01       	movw	r24, r20
    444e:	b9 01       	movw	r22, r18
    4450:	0e 94 e0 06 	call	0xdc0	; 0xdc0 <vListInsertEnd>
    4454:	0a c0       	rjmp	.+20     	; 0x446a <xTaskRemoveFromEventList+0xa2>
	}
	else
	{
		/* The delayed and ready lists cannot be accessed, so hold this task
		pending until the scheduler is resumed. */
		vListInsertEnd( &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
    4456:	8a 81       	ldd	r24, Y+2	; 0x02
    4458:	9b 81       	ldd	r25, Y+3	; 0x03
    445a:	9c 01       	movw	r18, r24
    445c:	24 5f       	subi	r18, 0xF4	; 244
    445e:	3f 4f       	sbci	r19, 0xFF	; 255
    4460:	83 e9       	ldi	r24, 0x93	; 147
    4462:	96 e0       	ldi	r25, 0x06	; 6
    4464:	b9 01       	movw	r22, r18
    4466:	0e 94 e0 06 	call	0xdc0	; 0xdc0 <vListInsertEnd>
	}

	if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
    446a:	ea 81       	ldd	r30, Y+2	; 0x02
    446c:	fb 81       	ldd	r31, Y+3	; 0x03
    446e:	96 89       	ldd	r25, Z+22	; 0x16
    4470:	e0 91 48 06 	lds	r30, 0x0648
    4474:	f0 91 49 06 	lds	r31, 0x0649
    4478:	86 89       	ldd	r24, Z+22	; 0x16
    447a:	89 17       	cp	r24, r25
    447c:	30 f4       	brcc	.+12     	; 0x448a <xTaskRemoveFromEventList+0xc2>
	{
		/* Return true if the task removed from the event list has a higher
		priority than the calling task.  This allows the calling task to know if
		it should force a context switch now. */
		xReturn = pdTRUE;
    447e:	81 e0       	ldi	r24, 0x01	; 1
    4480:	89 83       	std	Y+1, r24	; 0x01

		/* Mark that a yield is pending in case the user is not using the
		"xHigherPriorityTaskWoken" parameter to an ISR safe FreeRTOS function. */
		xYieldPending = pdTRUE;
    4482:	81 e0       	ldi	r24, 0x01	; 1
    4484:	80 93 51 06 	sts	0x0651, r24
    4488:	01 c0       	rjmp	.+2      	; 0x448c <xTaskRemoveFromEventList+0xc4>
	}
	else
	{
		xReturn = pdFALSE;
    448a:	19 82       	std	Y+1, r1	; 0x01
	}

	return xReturn;
    448c:	89 81       	ldd	r24, Y+1	; 0x01
}
    448e:	0f 90       	pop	r0
    4490:	0f 90       	pop	r0
    4492:	0f 90       	pop	r0
    4494:	0f 90       	pop	r0
    4496:	0f 90       	pop	r0
    4498:	cf 91       	pop	r28
    449a:	df 91       	pop	r29
    449c:	08 95       	ret

0000449e <vTaskRemoveFromUnorderedEventList>:
/*-----------------------------------------------------------*/

void vTaskRemoveFromUnorderedEventList( ListItem_t * pxEventListItem, const TickType_t xItemValue )
{
    449e:	df 93       	push	r29
    44a0:	cf 93       	push	r28
    44a2:	00 d0       	rcall	.+0      	; 0x44a4 <vTaskRemoveFromUnorderedEventList+0x6>
    44a4:	00 d0       	rcall	.+0      	; 0x44a6 <vTaskRemoveFromUnorderedEventList+0x8>
    44a6:	00 d0       	rcall	.+0      	; 0x44a8 <vTaskRemoveFromUnorderedEventList+0xa>
    44a8:	cd b7       	in	r28, 0x3d	; 61
    44aa:	de b7       	in	r29, 0x3e	; 62
    44ac:	9c 83       	std	Y+4, r25	; 0x04
    44ae:	8b 83       	std	Y+3, r24	; 0x03
    44b0:	7e 83       	std	Y+6, r23	; 0x06
    44b2:	6d 83       	std	Y+5, r22	; 0x05
	/* THIS FUNCTION MUST BE CALLED WITH THE SCHEDULER SUSPENDED.  It is used by
	the event flags implementation. */
	configASSERT( uxSchedulerSuspended != pdFALSE );

	/* Store the new item value in the event list. */
	listSET_LIST_ITEM_VALUE( pxEventListItem, xItemValue | taskEVENT_LIST_ITEM_VALUE_IN_USE );
    44b4:	8d 81       	ldd	r24, Y+5	; 0x05
    44b6:	9e 81       	ldd	r25, Y+6	; 0x06
    44b8:	90 68       	ori	r25, 0x80	; 128
    44ba:	eb 81       	ldd	r30, Y+3	; 0x03
    44bc:	fc 81       	ldd	r31, Y+4	; 0x04
    44be:	91 83       	std	Z+1, r25	; 0x01
    44c0:	80 83       	st	Z, r24

	/* Remove the event list form the event flag.  Interrupts do not access
	event flags. */
	pxUnblockedTCB = listGET_LIST_ITEM_OWNER( pxEventListItem ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    44c2:	eb 81       	ldd	r30, Y+3	; 0x03
    44c4:	fc 81       	ldd	r31, Y+4	; 0x04
    44c6:	86 81       	ldd	r24, Z+6	; 0x06
    44c8:	97 81       	ldd	r25, Z+7	; 0x07
    44ca:	9a 83       	std	Y+2, r25	; 0x02
    44cc:	89 83       	std	Y+1, r24	; 0x01
	configASSERT( pxUnblockedTCB );
	( void ) uxListRemove( pxEventListItem );
    44ce:	8b 81       	ldd	r24, Y+3	; 0x03
    44d0:	9c 81       	ldd	r25, Y+4	; 0x04
    44d2:	0e 94 90 07 	call	0xf20	; 0xf20 <uxListRemove>

	/* Remove the task from the delayed list and add it to the ready list.  The
	scheduler is suspended so interrupts will not be accessing the ready
	lists. */
	( void ) uxListRemove( &( pxUnblockedTCB->xStateListItem ) );
    44d6:	89 81       	ldd	r24, Y+1	; 0x01
    44d8:	9a 81       	ldd	r25, Y+2	; 0x02
    44da:	02 96       	adiw	r24, 0x02	; 2
    44dc:	0e 94 90 07 	call	0xf20	; 0xf20 <uxListRemove>
	prvAddTaskToReadyList( pxUnblockedTCB );
    44e0:	e9 81       	ldd	r30, Y+1	; 0x01
    44e2:	fa 81       	ldd	r31, Y+2	; 0x02
    44e4:	96 89       	ldd	r25, Z+22	; 0x16
    44e6:	80 91 4e 06 	lds	r24, 0x064E
    44ea:	89 17       	cp	r24, r25
    44ec:	28 f4       	brcc	.+10     	; 0x44f8 <vTaskRemoveFromUnorderedEventList+0x5a>
    44ee:	e9 81       	ldd	r30, Y+1	; 0x01
    44f0:	fa 81       	ldd	r31, Y+2	; 0x02
    44f2:	86 89       	ldd	r24, Z+22	; 0x16
    44f4:	80 93 4e 06 	sts	0x064E, r24
    44f8:	e9 81       	ldd	r30, Y+1	; 0x01
    44fa:	fa 81       	ldd	r31, Y+2	; 0x02
    44fc:	86 89       	ldd	r24, Z+22	; 0x16
    44fe:	28 2f       	mov	r18, r24
    4500:	30 e0       	ldi	r19, 0x00	; 0
    4502:	c9 01       	movw	r24, r18
    4504:	88 0f       	add	r24, r24
    4506:	99 1f       	adc	r25, r25
    4508:	88 0f       	add	r24, r24
    450a:	99 1f       	adc	r25, r25
    450c:	88 0f       	add	r24, r24
    450e:	99 1f       	adc	r25, r25
    4510:	82 0f       	add	r24, r18
    4512:	93 1f       	adc	r25, r19
    4514:	ac 01       	movw	r20, r24
    4516:	47 5a       	subi	r20, 0xA7	; 167
    4518:	59 4f       	sbci	r21, 0xF9	; 249
    451a:	89 81       	ldd	r24, Y+1	; 0x01
    451c:	9a 81       	ldd	r25, Y+2	; 0x02
    451e:	9c 01       	movw	r18, r24
    4520:	2e 5f       	subi	r18, 0xFE	; 254
    4522:	3f 4f       	sbci	r19, 0xFF	; 255
    4524:	ca 01       	movw	r24, r20
    4526:	b9 01       	movw	r22, r18
    4528:	0e 94 e0 06 	call	0xdc0	; 0xdc0 <vListInsertEnd>

	if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
    452c:	e9 81       	ldd	r30, Y+1	; 0x01
    452e:	fa 81       	ldd	r31, Y+2	; 0x02
    4530:	96 89       	ldd	r25, Z+22	; 0x16
    4532:	e0 91 48 06 	lds	r30, 0x0648
    4536:	f0 91 49 06 	lds	r31, 0x0649
    453a:	86 89       	ldd	r24, Z+22	; 0x16
    453c:	89 17       	cp	r24, r25
    453e:	18 f4       	brcc	.+6      	; 0x4546 <vTaskRemoveFromUnorderedEventList+0xa8>
	{
		/* The unblocked task has a priority above that of the calling task, so
		a context switch is required.  This function is called with the
		scheduler suspended so xYieldPending is set so the context switch
		occurs immediately that the scheduler is resumed (unsuspended). */
		xYieldPending = pdTRUE;
    4540:	81 e0       	ldi	r24, 0x01	; 1
    4542:	80 93 51 06 	sts	0x0651, r24
	}
}
    4546:	26 96       	adiw	r28, 0x06	; 6
    4548:	0f b6       	in	r0, 0x3f	; 63
    454a:	f8 94       	cli
    454c:	de bf       	out	0x3e, r29	; 62
    454e:	0f be       	out	0x3f, r0	; 63
    4550:	cd bf       	out	0x3d, r28	; 61
    4552:	cf 91       	pop	r28
    4554:	df 91       	pop	r29
    4556:	08 95       	ret

00004558 <vTaskSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( TimeOut_t * const pxTimeOut )
{
    4558:	df 93       	push	r29
    455a:	cf 93       	push	r28
    455c:	00 d0       	rcall	.+0      	; 0x455e <vTaskSetTimeOutState+0x6>
    455e:	cd b7       	in	r28, 0x3d	; 61
    4560:	de b7       	in	r29, 0x3e	; 62
    4562:	9a 83       	std	Y+2, r25	; 0x02
    4564:	89 83       	std	Y+1, r24	; 0x01
	configASSERT( pxTimeOut );
	taskENTER_CRITICAL();
    4566:	0f b6       	in	r0, 0x3f	; 63
    4568:	f8 94       	cli
    456a:	0f 92       	push	r0
	{
		pxTimeOut->xOverflowCount = xNumOfOverflows;
    456c:	80 91 52 06 	lds	r24, 0x0652
    4570:	e9 81       	ldd	r30, Y+1	; 0x01
    4572:	fa 81       	ldd	r31, Y+2	; 0x02
    4574:	80 83       	st	Z, r24
		pxTimeOut->xTimeOnEntering = xTickCount;
    4576:	80 91 4c 06 	lds	r24, 0x064C
    457a:	90 91 4d 06 	lds	r25, 0x064D
    457e:	e9 81       	ldd	r30, Y+1	; 0x01
    4580:	fa 81       	ldd	r31, Y+2	; 0x02
    4582:	92 83       	std	Z+2, r25	; 0x02
    4584:	81 83       	std	Z+1, r24	; 0x01
	}
	taskEXIT_CRITICAL();
    4586:	0f 90       	pop	r0
    4588:	0f be       	out	0x3f, r0	; 63
}
    458a:	0f 90       	pop	r0
    458c:	0f 90       	pop	r0
    458e:	cf 91       	pop	r28
    4590:	df 91       	pop	r29
    4592:	08 95       	ret

00004594 <vTaskInternalSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskInternalSetTimeOutState( TimeOut_t * const pxTimeOut )
{
    4594:	df 93       	push	r29
    4596:	cf 93       	push	r28
    4598:	00 d0       	rcall	.+0      	; 0x459a <vTaskInternalSetTimeOutState+0x6>
    459a:	cd b7       	in	r28, 0x3d	; 61
    459c:	de b7       	in	r29, 0x3e	; 62
    459e:	9a 83       	std	Y+2, r25	; 0x02
    45a0:	89 83       	std	Y+1, r24	; 0x01
	/* For internal use only as it does not use a critical section. */
	pxTimeOut->xOverflowCount = xNumOfOverflows;
    45a2:	80 91 52 06 	lds	r24, 0x0652
    45a6:	e9 81       	ldd	r30, Y+1	; 0x01
    45a8:	fa 81       	ldd	r31, Y+2	; 0x02
    45aa:	80 83       	st	Z, r24
	pxTimeOut->xTimeOnEntering = xTickCount;
    45ac:	80 91 4c 06 	lds	r24, 0x064C
    45b0:	90 91 4d 06 	lds	r25, 0x064D
    45b4:	e9 81       	ldd	r30, Y+1	; 0x01
    45b6:	fa 81       	ldd	r31, Y+2	; 0x02
    45b8:	92 83       	std	Z+2, r25	; 0x02
    45ba:	81 83       	std	Z+1, r24	; 0x01
}
    45bc:	0f 90       	pop	r0
    45be:	0f 90       	pop	r0
    45c0:	cf 91       	pop	r28
    45c2:	df 91       	pop	r29
    45c4:	08 95       	ret

000045c6 <xTaskCheckForTimeOut>:
/*-----------------------------------------------------------*/

BaseType_t xTaskCheckForTimeOut( TimeOut_t * const pxTimeOut, TickType_t * const pxTicksToWait )
{
    45c6:	df 93       	push	r29
    45c8:	cf 93       	push	r28
    45ca:	cd b7       	in	r28, 0x3d	; 61
    45cc:	de b7       	in	r29, 0x3e	; 62
    45ce:	29 97       	sbiw	r28, 0x09	; 9
    45d0:	0f b6       	in	r0, 0x3f	; 63
    45d2:	f8 94       	cli
    45d4:	de bf       	out	0x3e, r29	; 62
    45d6:	0f be       	out	0x3f, r0	; 63
    45d8:	cd bf       	out	0x3d, r28	; 61
    45da:	9f 83       	std	Y+7, r25	; 0x07
    45dc:	8e 83       	std	Y+6, r24	; 0x06
    45de:	79 87       	std	Y+9, r23	; 0x09
    45e0:	68 87       	std	Y+8, r22	; 0x08
BaseType_t xReturn;

	configASSERT( pxTimeOut );
	configASSERT( pxTicksToWait );

	taskENTER_CRITICAL();
    45e2:	0f b6       	in	r0, 0x3f	; 63
    45e4:	f8 94       	cli
    45e6:	0f 92       	push	r0
	{
		/* Minor optimisation.  The tick count cannot change in this block. */
		const TickType_t xConstTickCount = xTickCount;
    45e8:	80 91 4c 06 	lds	r24, 0x064C
    45ec:	90 91 4d 06 	lds	r25, 0x064D
    45f0:	9c 83       	std	Y+4, r25	; 0x04
    45f2:	8b 83       	std	Y+3, r24	; 0x03
		const TickType_t xElapsedTime = xConstTickCount - pxTimeOut->xTimeOnEntering;
    45f4:	ee 81       	ldd	r30, Y+6	; 0x06
    45f6:	ff 81       	ldd	r31, Y+7	; 0x07
    45f8:	21 81       	ldd	r18, Z+1	; 0x01
    45fa:	32 81       	ldd	r19, Z+2	; 0x02
    45fc:	8b 81       	ldd	r24, Y+3	; 0x03
    45fe:	9c 81       	ldd	r25, Y+4	; 0x04
    4600:	82 1b       	sub	r24, r18
    4602:	93 0b       	sbc	r25, r19
    4604:	9a 83       	std	Y+2, r25	; 0x02
    4606:	89 83       	std	Y+1, r24	; 0x01
			}
			else
		#endif

		#if ( INCLUDE_vTaskSuspend == 1 )
			if( *pxTicksToWait == portMAX_DELAY )
    4608:	e8 85       	ldd	r30, Y+8	; 0x08
    460a:	f9 85       	ldd	r31, Y+9	; 0x09
    460c:	80 81       	ld	r24, Z
    460e:	91 81       	ldd	r25, Z+1	; 0x01
    4610:	2f ef       	ldi	r18, 0xFF	; 255
    4612:	8f 3f       	cpi	r24, 0xFF	; 255
    4614:	92 07       	cpc	r25, r18
    4616:	11 f4       	brne	.+4      	; 0x461c <xTaskCheckForTimeOut+0x56>
			{
				/* If INCLUDE_vTaskSuspend is set to 1 and the block time
				specified is the maximum block time then the task should block
				indefinitely, and therefore never time out. */
				xReturn = pdFALSE;
    4618:	1d 82       	std	Y+5, r1	; 0x05
    461a:	36 c0       	rjmp	.+108    	; 0x4688 <xTaskCheckForTimeOut+0xc2>
			}
			else
		#endif

		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( xConstTickCount >= pxTimeOut->xTimeOnEntering ) ) /*lint !e525 Indentation preferred as is to make code within pre-processor directives clearer. */
    461c:	ee 81       	ldd	r30, Y+6	; 0x06
    461e:	ff 81       	ldd	r31, Y+7	; 0x07
    4620:	90 81       	ld	r25, Z
    4622:	80 91 52 06 	lds	r24, 0x0652
    4626:	98 17       	cp	r25, r24
    4628:	61 f0       	breq	.+24     	; 0x4642 <xTaskCheckForTimeOut+0x7c>
    462a:	ee 81       	ldd	r30, Y+6	; 0x06
    462c:	ff 81       	ldd	r31, Y+7	; 0x07
    462e:	21 81       	ldd	r18, Z+1	; 0x01
    4630:	32 81       	ldd	r19, Z+2	; 0x02
    4632:	8b 81       	ldd	r24, Y+3	; 0x03
    4634:	9c 81       	ldd	r25, Y+4	; 0x04
    4636:	82 17       	cp	r24, r18
    4638:	93 07       	cpc	r25, r19
    463a:	18 f0       	brcs	.+6      	; 0x4642 <xTaskCheckForTimeOut+0x7c>
			/* The tick count is greater than the time at which
			vTaskSetTimeout() was called, but has also overflowed since
			vTaskSetTimeOut() was called.  It must have wrapped all the way
			around and gone past again. This passed since vTaskSetTimeout()
			was called. */
			xReturn = pdTRUE;
    463c:	81 e0       	ldi	r24, 0x01	; 1
    463e:	8d 83       	std	Y+5, r24	; 0x05
    4640:	23 c0       	rjmp	.+70     	; 0x4688 <xTaskCheckForTimeOut+0xc2>
		}
		else if( xElapsedTime < *pxTicksToWait ) /*lint !e961 Explicit casting is only redundant with some compilers, whereas others require it to prevent integer conversion errors. */
    4642:	e8 85       	ldd	r30, Y+8	; 0x08
    4644:	f9 85       	ldd	r31, Y+9	; 0x09
    4646:	20 81       	ld	r18, Z
    4648:	31 81       	ldd	r19, Z+1	; 0x01
    464a:	89 81       	ldd	r24, Y+1	; 0x01
    464c:	9a 81       	ldd	r25, Y+2	; 0x02
    464e:	82 17       	cp	r24, r18
    4650:	93 07       	cpc	r25, r19
    4652:	a0 f4       	brcc	.+40     	; 0x467c <xTaskCheckForTimeOut+0xb6>
		{
			/* Not a genuine timeout. Adjust parameters for time remaining. */
			*pxTicksToWait -= xElapsedTime;
    4654:	e8 85       	ldd	r30, Y+8	; 0x08
    4656:	f9 85       	ldd	r31, Y+9	; 0x09
    4658:	20 81       	ld	r18, Z
    465a:	31 81       	ldd	r19, Z+1	; 0x01
    465c:	89 81       	ldd	r24, Y+1	; 0x01
    465e:	9a 81       	ldd	r25, Y+2	; 0x02
    4660:	a9 01       	movw	r20, r18
    4662:	48 1b       	sub	r20, r24
    4664:	59 0b       	sbc	r21, r25
    4666:	ca 01       	movw	r24, r20
    4668:	e8 85       	ldd	r30, Y+8	; 0x08
    466a:	f9 85       	ldd	r31, Y+9	; 0x09
    466c:	91 83       	std	Z+1, r25	; 0x01
    466e:	80 83       	st	Z, r24
			vTaskInternalSetTimeOutState( pxTimeOut );
    4670:	8e 81       	ldd	r24, Y+6	; 0x06
    4672:	9f 81       	ldd	r25, Y+7	; 0x07
    4674:	0e 94 ca 22 	call	0x4594	; 0x4594 <vTaskInternalSetTimeOutState>
			xReturn = pdFALSE;
    4678:	1d 82       	std	Y+5, r1	; 0x05
    467a:	06 c0       	rjmp	.+12     	; 0x4688 <xTaskCheckForTimeOut+0xc2>
		}
		else
		{
			*pxTicksToWait = 0;
    467c:	e8 85       	ldd	r30, Y+8	; 0x08
    467e:	f9 85       	ldd	r31, Y+9	; 0x09
    4680:	11 82       	std	Z+1, r1	; 0x01
    4682:	10 82       	st	Z, r1
			xReturn = pdTRUE;
    4684:	81 e0       	ldi	r24, 0x01	; 1
    4686:	8d 83       	std	Y+5, r24	; 0x05
		}
	}
	taskEXIT_CRITICAL();
    4688:	0f 90       	pop	r0
    468a:	0f be       	out	0x3f, r0	; 63

	return xReturn;
    468c:	8d 81       	ldd	r24, Y+5	; 0x05
}
    468e:	29 96       	adiw	r28, 0x09	; 9
    4690:	0f b6       	in	r0, 0x3f	; 63
    4692:	f8 94       	cli
    4694:	de bf       	out	0x3e, r29	; 62
    4696:	0f be       	out	0x3f, r0	; 63
    4698:	cd bf       	out	0x3d, r28	; 61
    469a:	cf 91       	pop	r28
    469c:	df 91       	pop	r29
    469e:	08 95       	ret

000046a0 <vTaskMissedYield>:
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
    46a0:	df 93       	push	r29
    46a2:	cf 93       	push	r28
    46a4:	cd b7       	in	r28, 0x3d	; 61
    46a6:	de b7       	in	r29, 0x3e	; 62
	xYieldPending = pdTRUE;
    46a8:	81 e0       	ldi	r24, 0x01	; 1
    46aa:	80 93 51 06 	sts	0x0651, r24
}
    46ae:	cf 91       	pop	r28
    46b0:	df 91       	pop	r29
    46b2:	08 95       	ret

000046b4 <prvIdleTask>:
 *
 * void prvIdleTask( void *pvParameters );
 *
 */
static portTASK_FUNCTION( prvIdleTask, pvParameters )
{
    46b4:	df 93       	push	r29
    46b6:	cf 93       	push	r28
    46b8:	00 d0       	rcall	.+0      	; 0x46ba <prvIdleTask+0x6>
    46ba:	cd b7       	in	r28, 0x3d	; 61
    46bc:	de b7       	in	r29, 0x3e	; 62
    46be:	9a 83       	std	Y+2, r25	; 0x02
    46c0:	89 83       	std	Y+1, r24	; 0x01

	for( ;; )
	{
		/* See if any tasks have deleted themselves - if so then the idle task
		is responsible for freeing the deleted task's TCB and stack. */
		prvCheckTasksWaitingTermination();
    46c2:	0e 94 a5 23 	call	0x474a	; 0x474a <prvCheckTasksWaitingTermination>
    46c6:	fd cf       	rjmp	.-6      	; 0x46c2 <prvIdleTask+0xe>

000046c8 <prvInitialiseTaskLists>:

#endif /* portUSING_MPU_WRAPPERS */
/*-----------------------------------------------------------*/

static void prvInitialiseTaskLists( void )
{
    46c8:	df 93       	push	r29
    46ca:	cf 93       	push	r28
    46cc:	0f 92       	push	r0
    46ce:	cd b7       	in	r28, 0x3d	; 61
    46d0:	de b7       	in	r29, 0x3e	; 62
UBaseType_t uxPriority;

	for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
    46d2:	19 82       	std	Y+1, r1	; 0x01
    46d4:	13 c0       	rjmp	.+38     	; 0x46fc <prvInitialiseTaskLists+0x34>
	{
		vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
    46d6:	89 81       	ldd	r24, Y+1	; 0x01
    46d8:	28 2f       	mov	r18, r24
    46da:	30 e0       	ldi	r19, 0x00	; 0
    46dc:	c9 01       	movw	r24, r18
    46de:	88 0f       	add	r24, r24
    46e0:	99 1f       	adc	r25, r25
    46e2:	88 0f       	add	r24, r24
    46e4:	99 1f       	adc	r25, r25
    46e6:	88 0f       	add	r24, r24
    46e8:	99 1f       	adc	r25, r25
    46ea:	82 0f       	add	r24, r18
    46ec:	93 1f       	adc	r25, r19
    46ee:	87 5a       	subi	r24, 0xA7	; 167
    46f0:	99 4f       	sbci	r25, 0xF9	; 249
    46f2:	0e 94 a6 06 	call	0xd4c	; 0xd4c <vListInitialise>

static void prvInitialiseTaskLists( void )
{
UBaseType_t uxPriority;

	for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
    46f6:	89 81       	ldd	r24, Y+1	; 0x01
    46f8:	8f 5f       	subi	r24, 0xFF	; 255
    46fa:	89 83       	std	Y+1, r24	; 0x01
    46fc:	89 81       	ldd	r24, Y+1	; 0x01
    46fe:	84 30       	cpi	r24, 0x04	; 4
    4700:	50 f3       	brcs	.-44     	; 0x46d6 <prvInitialiseTaskLists+0xe>
	{
		vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
	}

	vListInitialise( &xDelayedTaskList1 );
    4702:	8d e7       	ldi	r24, 0x7D	; 125
    4704:	96 e0       	ldi	r25, 0x06	; 6
    4706:	0e 94 a6 06 	call	0xd4c	; 0xd4c <vListInitialise>
	vListInitialise( &xDelayedTaskList2 );
    470a:	86 e8       	ldi	r24, 0x86	; 134
    470c:	96 e0       	ldi	r25, 0x06	; 6
    470e:	0e 94 a6 06 	call	0xd4c	; 0xd4c <vListInitialise>
	vListInitialise( &xPendingReadyList );
    4712:	83 e9       	ldi	r24, 0x93	; 147
    4714:	96 e0       	ldi	r25, 0x06	; 6
    4716:	0e 94 a6 06 	call	0xd4c	; 0xd4c <vListInitialise>

	#if ( INCLUDE_vTaskDelete == 1 )
	{
		vListInitialise( &xTasksWaitingTermination );
    471a:	8c e9       	ldi	r24, 0x9C	; 156
    471c:	96 e0       	ldi	r25, 0x06	; 6
    471e:	0e 94 a6 06 	call	0xd4c	; 0xd4c <vListInitialise>
	}
	#endif /* INCLUDE_vTaskDelete */

	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		vListInitialise( &xSuspendedTaskList );
    4722:	85 ea       	ldi	r24, 0xA5	; 165
    4724:	96 e0       	ldi	r25, 0x06	; 6
    4726:	0e 94 a6 06 	call	0xd4c	; 0xd4c <vListInitialise>
	}
	#endif /* INCLUDE_vTaskSuspend */

	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
	using list2. */
	pxDelayedTaskList = &xDelayedTaskList1;
    472a:	8d e7       	ldi	r24, 0x7D	; 125
    472c:	96 e0       	ldi	r25, 0x06	; 6
    472e:	90 93 90 06 	sts	0x0690, r25
    4732:	80 93 8f 06 	sts	0x068F, r24
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
    4736:	86 e8       	ldi	r24, 0x86	; 134
    4738:	96 e0       	ldi	r25, 0x06	; 6
    473a:	90 93 92 06 	sts	0x0692, r25
    473e:	80 93 91 06 	sts	0x0691, r24
}
    4742:	0f 90       	pop	r0
    4744:	cf 91       	pop	r28
    4746:	df 91       	pop	r29
    4748:	08 95       	ret

0000474a <prvCheckTasksWaitingTermination>:
/*-----------------------------------------------------------*/

static void prvCheckTasksWaitingTermination( void )
{
    474a:	df 93       	push	r29
    474c:	cf 93       	push	r28
    474e:	00 d0       	rcall	.+0      	; 0x4750 <prvCheckTasksWaitingTermination+0x6>
    4750:	cd b7       	in	r28, 0x3d	; 61
    4752:	de b7       	in	r29, 0x3e	; 62
    4754:	20 c0       	rjmp	.+64     	; 0x4796 <prvCheckTasksWaitingTermination+0x4c>

		/* uxDeletedTasksWaitingCleanUp is used to prevent taskENTER_CRITICAL()
		being called too often in the idle task. */
		while( uxDeletedTasksWaitingCleanUp > ( UBaseType_t ) 0U )
		{
			taskENTER_CRITICAL();
    4756:	0f b6       	in	r0, 0x3f	; 63
    4758:	f8 94       	cli
    475a:	0f 92       	push	r0
			{
				pxTCB = listGET_OWNER_OF_HEAD_ENTRY( ( &xTasksWaitingTermination ) ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    475c:	e0 91 a1 06 	lds	r30, 0x06A1
    4760:	f0 91 a2 06 	lds	r31, 0x06A2
    4764:	86 81       	ldd	r24, Z+6	; 0x06
    4766:	97 81       	ldd	r25, Z+7	; 0x07
    4768:	9a 83       	std	Y+2, r25	; 0x02
    476a:	89 83       	std	Y+1, r24	; 0x01
				( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    476c:	89 81       	ldd	r24, Y+1	; 0x01
    476e:	9a 81       	ldd	r25, Y+2	; 0x02
    4770:	02 96       	adiw	r24, 0x02	; 2
    4772:	0e 94 90 07 	call	0xf20	; 0xf20 <uxListRemove>
				--uxCurrentNumberOfTasks;
    4776:	80 91 4b 06 	lds	r24, 0x064B
    477a:	81 50       	subi	r24, 0x01	; 1
    477c:	80 93 4b 06 	sts	0x064B, r24
				--uxDeletedTasksWaitingCleanUp;
    4780:	80 91 4a 06 	lds	r24, 0x064A
    4784:	81 50       	subi	r24, 0x01	; 1
    4786:	80 93 4a 06 	sts	0x064A, r24
			}
			taskEXIT_CRITICAL();
    478a:	0f 90       	pop	r0
    478c:	0f be       	out	0x3f, r0	; 63

			prvDeleteTCB( pxTCB );
    478e:	89 81       	ldd	r24, Y+1	; 0x01
    4790:	9a 81       	ldd	r25, Y+2	; 0x02
    4792:	0e 94 d4 23 	call	0x47a8	; 0x47a8 <prvDeleteTCB>
	{
		TCB_t *pxTCB;

		/* uxDeletedTasksWaitingCleanUp is used to prevent taskENTER_CRITICAL()
		being called too often in the idle task. */
		while( uxDeletedTasksWaitingCleanUp > ( UBaseType_t ) 0U )
    4796:	80 91 4a 06 	lds	r24, 0x064A
    479a:	88 23       	and	r24, r24
    479c:	e1 f6       	brne	.-72     	; 0x4756 <prvCheckTasksWaitingTermination+0xc>

			prvDeleteTCB( pxTCB );
		}
	}
	#endif /* INCLUDE_vTaskDelete */
}
    479e:	0f 90       	pop	r0
    47a0:	0f 90       	pop	r0
    47a2:	cf 91       	pop	r28
    47a4:	df 91       	pop	r29
    47a6:	08 95       	ret

000047a8 <prvDeleteTCB>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelete == 1 )

	static void prvDeleteTCB( TCB_t *pxTCB )
	{
    47a8:	df 93       	push	r29
    47aa:	cf 93       	push	r28
    47ac:	00 d0       	rcall	.+0      	; 0x47ae <prvDeleteTCB+0x6>
    47ae:	cd b7       	in	r28, 0x3d	; 61
    47b0:	de b7       	in	r29, 0x3e	; 62
    47b2:	9a 83       	std	Y+2, r25	; 0x02
    47b4:	89 83       	std	Y+1, r24	; 0x01

		#if( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) && ( portUSING_MPU_WRAPPERS == 0 ) )
		{
			/* The task can only have been allocated dynamically - free both
			the stack and TCB. */
			vPortFree( pxTCB->pxStack );
    47b6:	e9 81       	ldd	r30, Y+1	; 0x01
    47b8:	fa 81       	ldd	r31, Y+2	; 0x02
    47ba:	87 89       	ldd	r24, Z+23	; 0x17
    47bc:	90 8d       	ldd	r25, Z+24	; 0x18
    47be:	0e 94 80 06 	call	0xd00	; 0xd00 <vPortFree>
			vPortFree( pxTCB );
    47c2:	89 81       	ldd	r24, Y+1	; 0x01
    47c4:	9a 81       	ldd	r25, Y+2	; 0x02
    47c6:	0e 94 80 06 	call	0xd00	; 0xd00 <vPortFree>
				configASSERT( pxTCB->ucStaticallyAllocated == tskSTATICALLY_ALLOCATED_STACK_AND_TCB	);
				mtCOVERAGE_TEST_MARKER();
			}
		}
		#endif /* configSUPPORT_DYNAMIC_ALLOCATION */
	}
    47ca:	0f 90       	pop	r0
    47cc:	0f 90       	pop	r0
    47ce:	cf 91       	pop	r28
    47d0:	df 91       	pop	r29
    47d2:	08 95       	ret

000047d4 <prvResetNextTaskUnblockTime>:

#endif /* INCLUDE_vTaskDelete */
/*-----------------------------------------------------------*/

static void prvResetNextTaskUnblockTime( void )
{
    47d4:	df 93       	push	r29
    47d6:	cf 93       	push	r28
    47d8:	00 d0       	rcall	.+0      	; 0x47da <prvResetNextTaskUnblockTime+0x6>
    47da:	cd b7       	in	r28, 0x3d	; 61
    47dc:	de b7       	in	r29, 0x3e	; 62
TCB_t *pxTCB;

	if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
    47de:	e0 91 8f 06 	lds	r30, 0x068F
    47e2:	f0 91 90 06 	lds	r31, 0x0690
    47e6:	80 81       	ld	r24, Z
    47e8:	88 23       	and	r24, r24
    47ea:	39 f4       	brne	.+14     	; 0x47fa <prvResetNextTaskUnblockTime+0x26>
	{
		/* The new current delayed list is empty.  Set xNextTaskUnblockTime to
		the maximum possible value so it is	extremely unlikely that the
		if( xTickCount >= xNextTaskUnblockTime ) test will pass until
		there is an item in the delayed list. */
		xNextTaskUnblockTime = portMAX_DELAY;
    47ec:	8f ef       	ldi	r24, 0xFF	; 255
    47ee:	9f ef       	ldi	r25, 0xFF	; 255
    47f0:	90 93 55 06 	sts	0x0655, r25
    47f4:	80 93 54 06 	sts	0x0654, r24
    47f8:	13 c0       	rjmp	.+38     	; 0x4820 <prvResetNextTaskUnblockTime+0x4c>
	{
		/* The new current delayed list is not empty, get the value of
		the item at the head of the delayed list.  This is the time at
		which the task at the head of the delayed list should be removed
		from the Blocked state. */
		( pxTCB ) = listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    47fa:	e0 91 8f 06 	lds	r30, 0x068F
    47fe:	f0 91 90 06 	lds	r31, 0x0690
    4802:	05 80       	ldd	r0, Z+5	; 0x05
    4804:	f6 81       	ldd	r31, Z+6	; 0x06
    4806:	e0 2d       	mov	r30, r0
    4808:	86 81       	ldd	r24, Z+6	; 0x06
    480a:	97 81       	ldd	r25, Z+7	; 0x07
    480c:	9a 83       	std	Y+2, r25	; 0x02
    480e:	89 83       	std	Y+1, r24	; 0x01
		xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( ( pxTCB )->xStateListItem ) );
    4810:	e9 81       	ldd	r30, Y+1	; 0x01
    4812:	fa 81       	ldd	r31, Y+2	; 0x02
    4814:	82 81       	ldd	r24, Z+2	; 0x02
    4816:	93 81       	ldd	r25, Z+3	; 0x03
    4818:	90 93 55 06 	sts	0x0655, r25
    481c:	80 93 54 06 	sts	0x0654, r24
	}
}
    4820:	0f 90       	pop	r0
    4822:	0f 90       	pop	r0
    4824:	cf 91       	pop	r28
    4826:	df 91       	pop	r29
    4828:	08 95       	ret

0000482a <xTaskGetCurrentTaskHandle>:
/*-----------------------------------------------------------*/

#if ( ( INCLUDE_xTaskGetCurrentTaskHandle == 1 ) || ( configUSE_MUTEXES == 1 ) )

	TaskHandle_t xTaskGetCurrentTaskHandle( void )
	{
    482a:	df 93       	push	r29
    482c:	cf 93       	push	r28
    482e:	00 d0       	rcall	.+0      	; 0x4830 <xTaskGetCurrentTaskHandle+0x6>
    4830:	cd b7       	in	r28, 0x3d	; 61
    4832:	de b7       	in	r29, 0x3e	; 62
	TaskHandle_t xReturn;

		/* A critical section is not required as this is not called from
		an interrupt and the current TCB will always be the same for any
		individual execution thread. */
		xReturn = pxCurrentTCB;
    4834:	80 91 48 06 	lds	r24, 0x0648
    4838:	90 91 49 06 	lds	r25, 0x0649
    483c:	9a 83       	std	Y+2, r25	; 0x02
    483e:	89 83       	std	Y+1, r24	; 0x01

		return xReturn;
    4840:	89 81       	ldd	r24, Y+1	; 0x01
    4842:	9a 81       	ldd	r25, Y+2	; 0x02
	}
    4844:	0f 90       	pop	r0
    4846:	0f 90       	pop	r0
    4848:	cf 91       	pop	r28
    484a:	df 91       	pop	r29
    484c:	08 95       	ret

0000484e <xTaskPriorityInherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	BaseType_t xTaskPriorityInherit( TaskHandle_t const pxMutexHolder )
	{
    484e:	df 93       	push	r29
    4850:	cf 93       	push	r28
    4852:	00 d0       	rcall	.+0      	; 0x4854 <xTaskPriorityInherit+0x6>
    4854:	00 d0       	rcall	.+0      	; 0x4856 <xTaskPriorityInherit+0x8>
    4856:	0f 92       	push	r0
    4858:	cd b7       	in	r28, 0x3d	; 61
    485a:	de b7       	in	r29, 0x3e	; 62
    485c:	9d 83       	std	Y+5, r25	; 0x05
    485e:	8c 83       	std	Y+4, r24	; 0x04
	TCB_t * const pxMutexHolderTCB = pxMutexHolder;
    4860:	8c 81       	ldd	r24, Y+4	; 0x04
    4862:	9d 81       	ldd	r25, Y+5	; 0x05
    4864:	9b 83       	std	Y+3, r25	; 0x03
    4866:	8a 83       	std	Y+2, r24	; 0x02
	BaseType_t xReturn = pdFALSE;
    4868:	19 82       	std	Y+1, r1	; 0x01

		/* If the mutex was given back by an interrupt while the queue was
		locked then the mutex holder might now be NULL.  _RB_ Is this still
		needed as interrupts can no longer use mutexes? */
		if( pxMutexHolder != NULL )
    486a:	8c 81       	ldd	r24, Y+4	; 0x04
    486c:	9d 81       	ldd	r25, Y+5	; 0x05
    486e:	00 97       	sbiw	r24, 0x00	; 0
    4870:	09 f4       	brne	.+2      	; 0x4874 <xTaskPriorityInherit+0x26>
    4872:	82 c0       	rjmp	.+260    	; 0x4978 <xTaskPriorityInherit+0x12a>
		{
			/* If the holder of the mutex has a priority below the priority of
			the task attempting to obtain the mutex then it will temporarily
			inherit the priority of the task attempting to obtain the mutex. */
			if( pxMutexHolderTCB->uxPriority < pxCurrentTCB->uxPriority )
    4874:	ea 81       	ldd	r30, Y+2	; 0x02
    4876:	fb 81       	ldd	r31, Y+3	; 0x03
    4878:	96 89       	ldd	r25, Z+22	; 0x16
    487a:	e0 91 48 06 	lds	r30, 0x0648
    487e:	f0 91 49 06 	lds	r31, 0x0649
    4882:	86 89       	ldd	r24, Z+22	; 0x16
    4884:	98 17       	cp	r25, r24
    4886:	08 f0       	brcs	.+2      	; 0x488a <xTaskPriorityInherit+0x3c>
    4888:	6b c0       	rjmp	.+214    	; 0x4960 <xTaskPriorityInherit+0x112>
			{
				/* Adjust the mutex holder state to account for its new
				priority.  Only reset the event list item value if the value is
				not being used for anything else. */
				if( ( listGET_LIST_ITEM_VALUE( &( pxMutexHolderTCB->xEventListItem ) ) & taskEVENT_LIST_ITEM_VALUE_IN_USE ) == 0UL )
    488a:	ea 81       	ldd	r30, Y+2	; 0x02
    488c:	fb 81       	ldd	r31, Y+3	; 0x03
    488e:	84 85       	ldd	r24, Z+12	; 0x0c
    4890:	95 85       	ldd	r25, Z+13	; 0x0d
    4892:	99 23       	and	r25, r25
    4894:	7c f0       	brlt	.+30     	; 0x48b4 <xTaskPriorityInherit+0x66>
				{
					listSET_LIST_ITEM_VALUE( &( pxMutexHolderTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxCurrentTCB->uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    4896:	e0 91 48 06 	lds	r30, 0x0648
    489a:	f0 91 49 06 	lds	r31, 0x0649
    489e:	86 89       	ldd	r24, Z+22	; 0x16
    48a0:	28 2f       	mov	r18, r24
    48a2:	30 e0       	ldi	r19, 0x00	; 0
    48a4:	84 e0       	ldi	r24, 0x04	; 4
    48a6:	90 e0       	ldi	r25, 0x00	; 0
    48a8:	82 1b       	sub	r24, r18
    48aa:	93 0b       	sbc	r25, r19
    48ac:	ea 81       	ldd	r30, Y+2	; 0x02
    48ae:	fb 81       	ldd	r31, Y+3	; 0x03
    48b0:	95 87       	std	Z+13, r25	; 0x0d
    48b2:	84 87       	std	Z+12, r24	; 0x0c
					mtCOVERAGE_TEST_MARKER();
				}

				/* If the task being modified is in the ready state it will need
				to be moved into a new list. */
				if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ pxMutexHolderTCB->uxPriority ] ), &( pxMutexHolderTCB->xStateListItem ) ) != pdFALSE )
    48b4:	ea 81       	ldd	r30, Y+2	; 0x02
    48b6:	fb 81       	ldd	r31, Y+3	; 0x03
    48b8:	42 85       	ldd	r20, Z+10	; 0x0a
    48ba:	53 85       	ldd	r21, Z+11	; 0x0b
    48bc:	ea 81       	ldd	r30, Y+2	; 0x02
    48be:	fb 81       	ldd	r31, Y+3	; 0x03
    48c0:	86 89       	ldd	r24, Z+22	; 0x16
    48c2:	28 2f       	mov	r18, r24
    48c4:	30 e0       	ldi	r19, 0x00	; 0
    48c6:	c9 01       	movw	r24, r18
    48c8:	88 0f       	add	r24, r24
    48ca:	99 1f       	adc	r25, r25
    48cc:	88 0f       	add	r24, r24
    48ce:	99 1f       	adc	r25, r25
    48d0:	88 0f       	add	r24, r24
    48d2:	99 1f       	adc	r25, r25
    48d4:	82 0f       	add	r24, r18
    48d6:	93 1f       	adc	r25, r19
    48d8:	87 5a       	subi	r24, 0xA7	; 167
    48da:	99 4f       	sbci	r25, 0xF9	; 249
    48dc:	48 17       	cp	r20, r24
    48de:	59 07       	cpc	r21, r25
    48e0:	a1 f5       	brne	.+104    	; 0x494a <xTaskPriorityInherit+0xfc>
				{
					if( uxListRemove( &( pxMutexHolderTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
    48e2:	8a 81       	ldd	r24, Y+2	; 0x02
    48e4:	9b 81       	ldd	r25, Y+3	; 0x03
    48e6:	02 96       	adiw	r24, 0x02	; 2
    48e8:	0e 94 90 07 	call	0xf20	; 0xf20 <uxListRemove>
					{
						mtCOVERAGE_TEST_MARKER();
					}

					/* Inherit the priority before being moved into the new list. */
					pxMutexHolderTCB->uxPriority = pxCurrentTCB->uxPriority;
    48ec:	e0 91 48 06 	lds	r30, 0x0648
    48f0:	f0 91 49 06 	lds	r31, 0x0649
    48f4:	86 89       	ldd	r24, Z+22	; 0x16
    48f6:	ea 81       	ldd	r30, Y+2	; 0x02
    48f8:	fb 81       	ldd	r31, Y+3	; 0x03
    48fa:	86 8b       	std	Z+22, r24	; 0x16
					prvAddTaskToReadyList( pxMutexHolderTCB );
    48fc:	ea 81       	ldd	r30, Y+2	; 0x02
    48fe:	fb 81       	ldd	r31, Y+3	; 0x03
    4900:	96 89       	ldd	r25, Z+22	; 0x16
    4902:	80 91 4e 06 	lds	r24, 0x064E
    4906:	89 17       	cp	r24, r25
    4908:	28 f4       	brcc	.+10     	; 0x4914 <xTaskPriorityInherit+0xc6>
    490a:	ea 81       	ldd	r30, Y+2	; 0x02
    490c:	fb 81       	ldd	r31, Y+3	; 0x03
    490e:	86 89       	ldd	r24, Z+22	; 0x16
    4910:	80 93 4e 06 	sts	0x064E, r24
    4914:	ea 81       	ldd	r30, Y+2	; 0x02
    4916:	fb 81       	ldd	r31, Y+3	; 0x03
    4918:	86 89       	ldd	r24, Z+22	; 0x16
    491a:	28 2f       	mov	r18, r24
    491c:	30 e0       	ldi	r19, 0x00	; 0
    491e:	c9 01       	movw	r24, r18
    4920:	88 0f       	add	r24, r24
    4922:	99 1f       	adc	r25, r25
    4924:	88 0f       	add	r24, r24
    4926:	99 1f       	adc	r25, r25
    4928:	88 0f       	add	r24, r24
    492a:	99 1f       	adc	r25, r25
    492c:	82 0f       	add	r24, r18
    492e:	93 1f       	adc	r25, r19
    4930:	ac 01       	movw	r20, r24
    4932:	47 5a       	subi	r20, 0xA7	; 167
    4934:	59 4f       	sbci	r21, 0xF9	; 249
    4936:	8a 81       	ldd	r24, Y+2	; 0x02
    4938:	9b 81       	ldd	r25, Y+3	; 0x03
    493a:	9c 01       	movw	r18, r24
    493c:	2e 5f       	subi	r18, 0xFE	; 254
    493e:	3f 4f       	sbci	r19, 0xFF	; 255
    4940:	ca 01       	movw	r24, r20
    4942:	b9 01       	movw	r22, r18
    4944:	0e 94 e0 06 	call	0xdc0	; 0xdc0 <vListInsertEnd>
    4948:	08 c0       	rjmp	.+16     	; 0x495a <xTaskPriorityInherit+0x10c>
				}
				else
				{
					/* Just inherit the priority. */
					pxMutexHolderTCB->uxPriority = pxCurrentTCB->uxPriority;
    494a:	e0 91 48 06 	lds	r30, 0x0648
    494e:	f0 91 49 06 	lds	r31, 0x0649
    4952:	86 89       	ldd	r24, Z+22	; 0x16
    4954:	ea 81       	ldd	r30, Y+2	; 0x02
    4956:	fb 81       	ldd	r31, Y+3	; 0x03
    4958:	86 8b       	std	Z+22, r24	; 0x16
				}

				traceTASK_PRIORITY_INHERIT( pxMutexHolderTCB, pxCurrentTCB->uxPriority );

				/* Inheritance occurred. */
				xReturn = pdTRUE;
    495a:	81 e0       	ldi	r24, 0x01	; 1
    495c:	89 83       	std	Y+1, r24	; 0x01
    495e:	0c c0       	rjmp	.+24     	; 0x4978 <xTaskPriorityInherit+0x12a>
			}
			else
			{
				if( pxMutexHolderTCB->uxBasePriority < pxCurrentTCB->uxPriority )
    4960:	ea 81       	ldd	r30, Y+2	; 0x02
    4962:	fb 81       	ldd	r31, Y+3	; 0x03
    4964:	93 a1       	ldd	r25, Z+35	; 0x23
    4966:	e0 91 48 06 	lds	r30, 0x0648
    496a:	f0 91 49 06 	lds	r31, 0x0649
    496e:	86 89       	ldd	r24, Z+22	; 0x16
    4970:	98 17       	cp	r25, r24
    4972:	10 f4       	brcc	.+4      	; 0x4978 <xTaskPriorityInherit+0x12a>
					current priority of the mutex holder is not lower than the
					priority of the task attempting to take the mutex.
					Therefore the mutex holder must have already inherited a
					priority, but inheritance would have occurred if that had
					not been the case. */
					xReturn = pdTRUE;
    4974:	81 e0       	ldi	r24, 0x01	; 1
    4976:	89 83       	std	Y+1, r24	; 0x01
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}

		return xReturn;
    4978:	89 81       	ldd	r24, Y+1	; 0x01
	}
    497a:	0f 90       	pop	r0
    497c:	0f 90       	pop	r0
    497e:	0f 90       	pop	r0
    4980:	0f 90       	pop	r0
    4982:	0f 90       	pop	r0
    4984:	cf 91       	pop	r28
    4986:	df 91       	pop	r29
    4988:	08 95       	ret

0000498a <xTaskPriorityDisinherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	BaseType_t xTaskPriorityDisinherit( TaskHandle_t const pxMutexHolder )
	{
    498a:	df 93       	push	r29
    498c:	cf 93       	push	r28
    498e:	00 d0       	rcall	.+0      	; 0x4990 <xTaskPriorityDisinherit+0x6>
    4990:	00 d0       	rcall	.+0      	; 0x4992 <xTaskPriorityDisinherit+0x8>
    4992:	0f 92       	push	r0
    4994:	cd b7       	in	r28, 0x3d	; 61
    4996:	de b7       	in	r29, 0x3e	; 62
    4998:	9d 83       	std	Y+5, r25	; 0x05
    499a:	8c 83       	std	Y+4, r24	; 0x04
	TCB_t * const pxTCB = pxMutexHolder;
    499c:	8c 81       	ldd	r24, Y+4	; 0x04
    499e:	9d 81       	ldd	r25, Y+5	; 0x05
    49a0:	9b 83       	std	Y+3, r25	; 0x03
    49a2:	8a 83       	std	Y+2, r24	; 0x02
	BaseType_t xReturn = pdFALSE;
    49a4:	19 82       	std	Y+1, r1	; 0x01

		if( pxMutexHolder != NULL )
    49a6:	8c 81       	ldd	r24, Y+4	; 0x04
    49a8:	9d 81       	ldd	r25, Y+5	; 0x05
    49aa:	00 97       	sbiw	r24, 0x00	; 0
    49ac:	09 f4       	brne	.+2      	; 0x49b0 <xTaskPriorityDisinherit+0x26>
    49ae:	56 c0       	rjmp	.+172    	; 0x4a5c <xTaskPriorityDisinherit+0xd2>
			If the mutex is held by a task then it cannot be given from an
			interrupt, and if a mutex is given by the holding task then it must
			be the running state task. */
			configASSERT( pxTCB == pxCurrentTCB );
			configASSERT( pxTCB->uxMutexesHeld );
			( pxTCB->uxMutexesHeld )--;
    49b0:	ea 81       	ldd	r30, Y+2	; 0x02
    49b2:	fb 81       	ldd	r31, Y+3	; 0x03
    49b4:	84 a1       	ldd	r24, Z+36	; 0x24
    49b6:	81 50       	subi	r24, 0x01	; 1
    49b8:	ea 81       	ldd	r30, Y+2	; 0x02
    49ba:	fb 81       	ldd	r31, Y+3	; 0x03
    49bc:	84 a3       	std	Z+36, r24	; 0x24

			/* Has the holder of the mutex inherited the priority of another
			task? */
			if( pxTCB->uxPriority != pxTCB->uxBasePriority )
    49be:	ea 81       	ldd	r30, Y+2	; 0x02
    49c0:	fb 81       	ldd	r31, Y+3	; 0x03
    49c2:	96 89       	ldd	r25, Z+22	; 0x16
    49c4:	ea 81       	ldd	r30, Y+2	; 0x02
    49c6:	fb 81       	ldd	r31, Y+3	; 0x03
    49c8:	83 a1       	ldd	r24, Z+35	; 0x23
    49ca:	98 17       	cp	r25, r24
    49cc:	09 f4       	brne	.+2      	; 0x49d0 <xTaskPriorityDisinherit+0x46>
    49ce:	46 c0       	rjmp	.+140    	; 0x4a5c <xTaskPriorityDisinherit+0xd2>
			{
				/* Only disinherit if no other mutexes are held. */
				if( pxTCB->uxMutexesHeld == ( UBaseType_t ) 0 )
    49d0:	ea 81       	ldd	r30, Y+2	; 0x02
    49d2:	fb 81       	ldd	r31, Y+3	; 0x03
    49d4:	84 a1       	ldd	r24, Z+36	; 0x24
    49d6:	88 23       	and	r24, r24
    49d8:	09 f0       	breq	.+2      	; 0x49dc <xTaskPriorityDisinherit+0x52>
    49da:	40 c0       	rjmp	.+128    	; 0x4a5c <xTaskPriorityDisinherit+0xd2>
					/* A task can only have an inherited priority if it holds
					the mutex.  If the mutex is held by a task then it cannot be
					given from an interrupt, and if a mutex is given by the
					holding task then it must be the running state task.  Remove
					the holding task from the ready list. */
					if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
    49dc:	8a 81       	ldd	r24, Y+2	; 0x02
    49de:	9b 81       	ldd	r25, Y+3	; 0x03
    49e0:	02 96       	adiw	r24, 0x02	; 2
    49e2:	0e 94 90 07 	call	0xf20	; 0xf20 <uxListRemove>
					}

					/* Disinherit the priority before adding the task into the
					new	ready list. */
					traceTASK_PRIORITY_DISINHERIT( pxTCB, pxTCB->uxBasePriority );
					pxTCB->uxPriority = pxTCB->uxBasePriority;
    49e6:	ea 81       	ldd	r30, Y+2	; 0x02
    49e8:	fb 81       	ldd	r31, Y+3	; 0x03
    49ea:	83 a1       	ldd	r24, Z+35	; 0x23
    49ec:	ea 81       	ldd	r30, Y+2	; 0x02
    49ee:	fb 81       	ldd	r31, Y+3	; 0x03
    49f0:	86 8b       	std	Z+22, r24	; 0x16

					/* Reset the event list item value.  It cannot be in use for
					any other purpose if this task is running, and it must be
					running to give back the mutex. */
					listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxTCB->uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    49f2:	ea 81       	ldd	r30, Y+2	; 0x02
    49f4:	fb 81       	ldd	r31, Y+3	; 0x03
    49f6:	86 89       	ldd	r24, Z+22	; 0x16
    49f8:	28 2f       	mov	r18, r24
    49fa:	30 e0       	ldi	r19, 0x00	; 0
    49fc:	84 e0       	ldi	r24, 0x04	; 4
    49fe:	90 e0       	ldi	r25, 0x00	; 0
    4a00:	82 1b       	sub	r24, r18
    4a02:	93 0b       	sbc	r25, r19
    4a04:	ea 81       	ldd	r30, Y+2	; 0x02
    4a06:	fb 81       	ldd	r31, Y+3	; 0x03
    4a08:	95 87       	std	Z+13, r25	; 0x0d
    4a0a:	84 87       	std	Z+12, r24	; 0x0c
					prvAddTaskToReadyList( pxTCB );
    4a0c:	ea 81       	ldd	r30, Y+2	; 0x02
    4a0e:	fb 81       	ldd	r31, Y+3	; 0x03
    4a10:	96 89       	ldd	r25, Z+22	; 0x16
    4a12:	80 91 4e 06 	lds	r24, 0x064E
    4a16:	89 17       	cp	r24, r25
    4a18:	28 f4       	brcc	.+10     	; 0x4a24 <xTaskPriorityDisinherit+0x9a>
    4a1a:	ea 81       	ldd	r30, Y+2	; 0x02
    4a1c:	fb 81       	ldd	r31, Y+3	; 0x03
    4a1e:	86 89       	ldd	r24, Z+22	; 0x16
    4a20:	80 93 4e 06 	sts	0x064E, r24
    4a24:	ea 81       	ldd	r30, Y+2	; 0x02
    4a26:	fb 81       	ldd	r31, Y+3	; 0x03
    4a28:	86 89       	ldd	r24, Z+22	; 0x16
    4a2a:	28 2f       	mov	r18, r24
    4a2c:	30 e0       	ldi	r19, 0x00	; 0
    4a2e:	c9 01       	movw	r24, r18
    4a30:	88 0f       	add	r24, r24
    4a32:	99 1f       	adc	r25, r25
    4a34:	88 0f       	add	r24, r24
    4a36:	99 1f       	adc	r25, r25
    4a38:	88 0f       	add	r24, r24
    4a3a:	99 1f       	adc	r25, r25
    4a3c:	82 0f       	add	r24, r18
    4a3e:	93 1f       	adc	r25, r19
    4a40:	ac 01       	movw	r20, r24
    4a42:	47 5a       	subi	r20, 0xA7	; 167
    4a44:	59 4f       	sbci	r21, 0xF9	; 249
    4a46:	8a 81       	ldd	r24, Y+2	; 0x02
    4a48:	9b 81       	ldd	r25, Y+3	; 0x03
    4a4a:	9c 01       	movw	r18, r24
    4a4c:	2e 5f       	subi	r18, 0xFE	; 254
    4a4e:	3f 4f       	sbci	r19, 0xFF	; 255
    4a50:	ca 01       	movw	r24, r20
    4a52:	b9 01       	movw	r22, r18
    4a54:	0e 94 e0 06 	call	0xdc0	; 0xdc0 <vListInsertEnd>
					in an order different to that in which they were taken.
					If a context switch did not occur when the first mutex was
					returned, even if a task was waiting on it, then a context
					switch should occur when the last mutex is returned whether
					a task is waiting on it or not. */
					xReturn = pdTRUE;
    4a58:	81 e0       	ldi	r24, 0x01	; 1
    4a5a:	89 83       	std	Y+1, r24	; 0x01
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}

		return xReturn;
    4a5c:	89 81       	ldd	r24, Y+1	; 0x01
	}
    4a5e:	0f 90       	pop	r0
    4a60:	0f 90       	pop	r0
    4a62:	0f 90       	pop	r0
    4a64:	0f 90       	pop	r0
    4a66:	0f 90       	pop	r0
    4a68:	cf 91       	pop	r28
    4a6a:	df 91       	pop	r29
    4a6c:	08 95       	ret

00004a6e <vTaskPriorityDisinheritAfterTimeout>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityDisinheritAfterTimeout( TaskHandle_t const pxMutexHolder, UBaseType_t uxHighestPriorityWaitingTask )
	{
    4a6e:	df 93       	push	r29
    4a70:	cf 93       	push	r28
    4a72:	cd b7       	in	r28, 0x3d	; 61
    4a74:	de b7       	in	r29, 0x3e	; 62
    4a76:	28 97       	sbiw	r28, 0x08	; 8
    4a78:	0f b6       	in	r0, 0x3f	; 63
    4a7a:	f8 94       	cli
    4a7c:	de bf       	out	0x3e, r29	; 62
    4a7e:	0f be       	out	0x3f, r0	; 63
    4a80:	cd bf       	out	0x3d, r28	; 61
    4a82:	9f 83       	std	Y+7, r25	; 0x07
    4a84:	8e 83       	std	Y+6, r24	; 0x06
    4a86:	68 87       	std	Y+8, r22	; 0x08
	TCB_t * const pxTCB = pxMutexHolder;
    4a88:	8e 81       	ldd	r24, Y+6	; 0x06
    4a8a:	9f 81       	ldd	r25, Y+7	; 0x07
    4a8c:	9d 83       	std	Y+5, r25	; 0x05
    4a8e:	8c 83       	std	Y+4, r24	; 0x04
	UBaseType_t uxPriorityUsedOnEntry, uxPriorityToUse;
	const UBaseType_t uxOnlyOneMutexHeld = ( UBaseType_t ) 1;
    4a90:	81 e0       	ldi	r24, 0x01	; 1
    4a92:	89 83       	std	Y+1, r24	; 0x01

		if( pxMutexHolder != NULL )
    4a94:	8e 81       	ldd	r24, Y+6	; 0x06
    4a96:	9f 81       	ldd	r25, Y+7	; 0x07
    4a98:	00 97       	sbiw	r24, 0x00	; 0
    4a9a:	09 f4       	brne	.+2      	; 0x4a9e <vTaskPriorityDisinheritAfterTimeout+0x30>
    4a9c:	74 c0       	rjmp	.+232    	; 0x4b86 <vTaskPriorityDisinheritAfterTimeout+0x118>

			/* Determine the priority to which the priority of the task that
			holds the mutex should be set.  This will be the greater of the
			holding task's base priority and the priority of the highest
			priority task that is waiting to obtain the mutex. */
			if( pxTCB->uxBasePriority < uxHighestPriorityWaitingTask )
    4a9e:	ec 81       	ldd	r30, Y+4	; 0x04
    4aa0:	fd 81       	ldd	r31, Y+5	; 0x05
    4aa2:	93 a1       	ldd	r25, Z+35	; 0x23
    4aa4:	88 85       	ldd	r24, Y+8	; 0x08
    4aa6:	98 17       	cp	r25, r24
    4aa8:	18 f4       	brcc	.+6      	; 0x4ab0 <vTaskPriorityDisinheritAfterTimeout+0x42>
			{
				uxPriorityToUse = uxHighestPriorityWaitingTask;
    4aaa:	88 85       	ldd	r24, Y+8	; 0x08
    4aac:	8a 83       	std	Y+2, r24	; 0x02
    4aae:	04 c0       	rjmp	.+8      	; 0x4ab8 <vTaskPriorityDisinheritAfterTimeout+0x4a>
			}
			else
			{
				uxPriorityToUse = pxTCB->uxBasePriority;
    4ab0:	ec 81       	ldd	r30, Y+4	; 0x04
    4ab2:	fd 81       	ldd	r31, Y+5	; 0x05
    4ab4:	83 a1       	ldd	r24, Z+35	; 0x23
    4ab6:	8a 83       	std	Y+2, r24	; 0x02
			}

			/* Does the priority need to change? */
			if( pxTCB->uxPriority != uxPriorityToUse )
    4ab8:	ec 81       	ldd	r30, Y+4	; 0x04
    4aba:	fd 81       	ldd	r31, Y+5	; 0x05
    4abc:	96 89       	ldd	r25, Z+22	; 0x16
    4abe:	8a 81       	ldd	r24, Y+2	; 0x02
    4ac0:	98 17       	cp	r25, r24
    4ac2:	09 f4       	brne	.+2      	; 0x4ac6 <vTaskPriorityDisinheritAfterTimeout+0x58>
    4ac4:	60 c0       	rjmp	.+192    	; 0x4b86 <vTaskPriorityDisinheritAfterTimeout+0x118>
			{
				/* Only disinherit if no other mutexes are held.  This is a
				simplification in the priority inheritance implementation.  If
				the task that holds the mutex is also holding other mutexes then
				the other mutexes may have caused the priority inheritance. */
				if( pxTCB->uxMutexesHeld == uxOnlyOneMutexHeld )
    4ac6:	ec 81       	ldd	r30, Y+4	; 0x04
    4ac8:	fd 81       	ldd	r31, Y+5	; 0x05
    4aca:	94 a1       	ldd	r25, Z+36	; 0x24
    4acc:	89 81       	ldd	r24, Y+1	; 0x01
    4ace:	98 17       	cp	r25, r24
    4ad0:	09 f0       	breq	.+2      	; 0x4ad4 <vTaskPriorityDisinheritAfterTimeout+0x66>
    4ad2:	59 c0       	rjmp	.+178    	; 0x4b86 <vTaskPriorityDisinheritAfterTimeout+0x118>

					/* Disinherit the priority, remembering the previous
					priority to facilitate determining the subject task's
					state. */
					traceTASK_PRIORITY_DISINHERIT( pxTCB, pxTCB->uxBasePriority );
					uxPriorityUsedOnEntry = pxTCB->uxPriority;
    4ad4:	ec 81       	ldd	r30, Y+4	; 0x04
    4ad6:	fd 81       	ldd	r31, Y+5	; 0x05
    4ad8:	86 89       	ldd	r24, Z+22	; 0x16
    4ada:	8b 83       	std	Y+3, r24	; 0x03
					pxTCB->uxPriority = uxPriorityToUse;
    4adc:	ec 81       	ldd	r30, Y+4	; 0x04
    4ade:	fd 81       	ldd	r31, Y+5	; 0x05
    4ae0:	8a 81       	ldd	r24, Y+2	; 0x02
    4ae2:	86 8b       	std	Z+22, r24	; 0x16

					/* Only reset the event list item value if the value is not
					being used for anything else. */
					if( ( listGET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ) ) & taskEVENT_LIST_ITEM_VALUE_IN_USE ) == 0UL )
    4ae4:	ec 81       	ldd	r30, Y+4	; 0x04
    4ae6:	fd 81       	ldd	r31, Y+5	; 0x05
    4ae8:	84 85       	ldd	r24, Z+12	; 0x0c
    4aea:	95 85       	ldd	r25, Z+13	; 0x0d
    4aec:	99 23       	and	r25, r25
    4aee:	5c f0       	brlt	.+22     	; 0x4b06 <vTaskPriorityDisinheritAfterTimeout+0x98>
					{
						listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriorityToUse ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    4af0:	8a 81       	ldd	r24, Y+2	; 0x02
    4af2:	28 2f       	mov	r18, r24
    4af4:	30 e0       	ldi	r19, 0x00	; 0
    4af6:	84 e0       	ldi	r24, 0x04	; 4
    4af8:	90 e0       	ldi	r25, 0x00	; 0
    4afa:	82 1b       	sub	r24, r18
    4afc:	93 0b       	sbc	r25, r19
    4afe:	ec 81       	ldd	r30, Y+4	; 0x04
    4b00:	fd 81       	ldd	r31, Y+5	; 0x05
    4b02:	95 87       	std	Z+13, r25	; 0x0d
    4b04:	84 87       	std	Z+12, r24	; 0x0c
					then the task that holds the mutex could be in either the
					Ready, Blocked or Suspended states.  Only remove the task
					from its current state list if it is in the Ready state as
					the task's priority is going to change and there is one
					Ready list per priority. */
					if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ uxPriorityUsedOnEntry ] ), &( pxTCB->xStateListItem ) ) != pdFALSE )
    4b06:	ec 81       	ldd	r30, Y+4	; 0x04
    4b08:	fd 81       	ldd	r31, Y+5	; 0x05
    4b0a:	42 85       	ldd	r20, Z+10	; 0x0a
    4b0c:	53 85       	ldd	r21, Z+11	; 0x0b
    4b0e:	8b 81       	ldd	r24, Y+3	; 0x03
    4b10:	28 2f       	mov	r18, r24
    4b12:	30 e0       	ldi	r19, 0x00	; 0
    4b14:	c9 01       	movw	r24, r18
    4b16:	88 0f       	add	r24, r24
    4b18:	99 1f       	adc	r25, r25
    4b1a:	88 0f       	add	r24, r24
    4b1c:	99 1f       	adc	r25, r25
    4b1e:	88 0f       	add	r24, r24
    4b20:	99 1f       	adc	r25, r25
    4b22:	82 0f       	add	r24, r18
    4b24:	93 1f       	adc	r25, r19
    4b26:	87 5a       	subi	r24, 0xA7	; 167
    4b28:	99 4f       	sbci	r25, 0xF9	; 249
    4b2a:	48 17       	cp	r20, r24
    4b2c:	59 07       	cpc	r21, r25
    4b2e:	59 f5       	brne	.+86     	; 0x4b86 <vTaskPriorityDisinheritAfterTimeout+0x118>
					{
						if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
    4b30:	8c 81       	ldd	r24, Y+4	; 0x04
    4b32:	9d 81       	ldd	r25, Y+5	; 0x05
    4b34:	02 96       	adiw	r24, 0x02	; 2
    4b36:	0e 94 90 07 	call	0xf20	; 0xf20 <uxListRemove>
						else
						{
							mtCOVERAGE_TEST_MARKER();
						}

						prvAddTaskToReadyList( pxTCB );
    4b3a:	ec 81       	ldd	r30, Y+4	; 0x04
    4b3c:	fd 81       	ldd	r31, Y+5	; 0x05
    4b3e:	96 89       	ldd	r25, Z+22	; 0x16
    4b40:	80 91 4e 06 	lds	r24, 0x064E
    4b44:	89 17       	cp	r24, r25
    4b46:	28 f4       	brcc	.+10     	; 0x4b52 <vTaskPriorityDisinheritAfterTimeout+0xe4>
    4b48:	ec 81       	ldd	r30, Y+4	; 0x04
    4b4a:	fd 81       	ldd	r31, Y+5	; 0x05
    4b4c:	86 89       	ldd	r24, Z+22	; 0x16
    4b4e:	80 93 4e 06 	sts	0x064E, r24
    4b52:	ec 81       	ldd	r30, Y+4	; 0x04
    4b54:	fd 81       	ldd	r31, Y+5	; 0x05
    4b56:	86 89       	ldd	r24, Z+22	; 0x16
    4b58:	28 2f       	mov	r18, r24
    4b5a:	30 e0       	ldi	r19, 0x00	; 0
    4b5c:	c9 01       	movw	r24, r18
    4b5e:	88 0f       	add	r24, r24
    4b60:	99 1f       	adc	r25, r25
    4b62:	88 0f       	add	r24, r24
    4b64:	99 1f       	adc	r25, r25
    4b66:	88 0f       	add	r24, r24
    4b68:	99 1f       	adc	r25, r25
    4b6a:	82 0f       	add	r24, r18
    4b6c:	93 1f       	adc	r25, r19
    4b6e:	ac 01       	movw	r20, r24
    4b70:	47 5a       	subi	r20, 0xA7	; 167
    4b72:	59 4f       	sbci	r21, 0xF9	; 249
    4b74:	8c 81       	ldd	r24, Y+4	; 0x04
    4b76:	9d 81       	ldd	r25, Y+5	; 0x05
    4b78:	9c 01       	movw	r18, r24
    4b7a:	2e 5f       	subi	r18, 0xFE	; 254
    4b7c:	3f 4f       	sbci	r19, 0xFF	; 255
    4b7e:	ca 01       	movw	r24, r20
    4b80:	b9 01       	movw	r22, r18
    4b82:	0e 94 e0 06 	call	0xdc0	; 0xdc0 <vListInsertEnd>
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
    4b86:	28 96       	adiw	r28, 0x08	; 8
    4b88:	0f b6       	in	r0, 0x3f	; 63
    4b8a:	f8 94       	cli
    4b8c:	de bf       	out	0x3e, r29	; 62
    4b8e:	0f be       	out	0x3f, r0	; 63
    4b90:	cd bf       	out	0x3d, r28	; 61
    4b92:	cf 91       	pop	r28
    4b94:	df 91       	pop	r29
    4b96:	08 95       	ret

00004b98 <uxTaskResetEventItemValue>:

#endif /* ( ( configGENERATE_RUN_TIME_STATS == 1 ) && ( configUSE_STATS_FORMATTING_FUNCTIONS > 0 ) && ( configSUPPORT_STATIC_ALLOCATION == 1 ) ) */
/*-----------------------------------------------------------*/

TickType_t uxTaskResetEventItemValue( void )
{
    4b98:	df 93       	push	r29
    4b9a:	cf 93       	push	r28
    4b9c:	00 d0       	rcall	.+0      	; 0x4b9e <uxTaskResetEventItemValue+0x6>
    4b9e:	cd b7       	in	r28, 0x3d	; 61
    4ba0:	de b7       	in	r29, 0x3e	; 62
TickType_t uxReturn;

	uxReturn = listGET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ) );
    4ba2:	e0 91 48 06 	lds	r30, 0x0648
    4ba6:	f0 91 49 06 	lds	r31, 0x0649
    4baa:	84 85       	ldd	r24, Z+12	; 0x0c
    4bac:	95 85       	ldd	r25, Z+13	; 0x0d
    4bae:	9a 83       	std	Y+2, r25	; 0x02
    4bb0:	89 83       	std	Y+1, r24	; 0x01

	/* Reset the event list item to its normal value - so it can be used with
	queues and semaphores. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), ( ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxCurrentTCB->uxPriority ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    4bb2:	a0 91 48 06 	lds	r26, 0x0648
    4bb6:	b0 91 49 06 	lds	r27, 0x0649
    4bba:	e0 91 48 06 	lds	r30, 0x0648
    4bbe:	f0 91 49 06 	lds	r31, 0x0649
    4bc2:	86 89       	ldd	r24, Z+22	; 0x16
    4bc4:	28 2f       	mov	r18, r24
    4bc6:	30 e0       	ldi	r19, 0x00	; 0
    4bc8:	84 e0       	ldi	r24, 0x04	; 4
    4bca:	90 e0       	ldi	r25, 0x00	; 0
    4bcc:	82 1b       	sub	r24, r18
    4bce:	93 0b       	sbc	r25, r19
    4bd0:	1d 96       	adiw	r26, 0x0d	; 13
    4bd2:	9c 93       	st	X, r25
    4bd4:	8e 93       	st	-X, r24
    4bd6:	1c 97       	sbiw	r26, 0x0c	; 12

	return uxReturn;
    4bd8:	89 81       	ldd	r24, Y+1	; 0x01
    4bda:	9a 81       	ldd	r25, Y+2	; 0x02
}
    4bdc:	0f 90       	pop	r0
    4bde:	0f 90       	pop	r0
    4be0:	cf 91       	pop	r28
    4be2:	df 91       	pop	r29
    4be4:	08 95       	ret

00004be6 <pvTaskIncrementMutexHeldCount>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	TaskHandle_t pvTaskIncrementMutexHeldCount( void )
	{
    4be6:	df 93       	push	r29
    4be8:	cf 93       	push	r28
    4bea:	cd b7       	in	r28, 0x3d	; 61
    4bec:	de b7       	in	r29, 0x3e	; 62
		/* If xSemaphoreCreateMutex() is called before any tasks have been created
		then pxCurrentTCB will be NULL. */
		if( pxCurrentTCB != NULL )
    4bee:	80 91 48 06 	lds	r24, 0x0648
    4bf2:	90 91 49 06 	lds	r25, 0x0649
    4bf6:	00 97       	sbiw	r24, 0x00	; 0
    4bf8:	39 f0       	breq	.+14     	; 0x4c08 <pvTaskIncrementMutexHeldCount+0x22>
		{
			( pxCurrentTCB->uxMutexesHeld )++;
    4bfa:	e0 91 48 06 	lds	r30, 0x0648
    4bfe:	f0 91 49 06 	lds	r31, 0x0649
    4c02:	84 a1       	ldd	r24, Z+36	; 0x24
    4c04:	8f 5f       	subi	r24, 0xFF	; 255
    4c06:	84 a3       	std	Z+36, r24	; 0x24
		}

		return pxCurrentTCB;
    4c08:	80 91 48 06 	lds	r24, 0x0648
    4c0c:	90 91 49 06 	lds	r25, 0x0649
	}
    4c10:	cf 91       	pop	r28
    4c12:	df 91       	pop	r29
    4c14:	08 95       	ret

00004c16 <ulTaskNotifyTake>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	uint32_t ulTaskNotifyTake( BaseType_t xClearCountOnExit, TickType_t xTicksToWait )
	{
    4c16:	df 93       	push	r29
    4c18:	cf 93       	push	r28
    4c1a:	cd b7       	in	r28, 0x3d	; 61
    4c1c:	de b7       	in	r29, 0x3e	; 62
    4c1e:	27 97       	sbiw	r28, 0x07	; 7
    4c20:	0f b6       	in	r0, 0x3f	; 63
    4c22:	f8 94       	cli
    4c24:	de bf       	out	0x3e, r29	; 62
    4c26:	0f be       	out	0x3f, r0	; 63
    4c28:	cd bf       	out	0x3d, r28	; 61
    4c2a:	8d 83       	std	Y+5, r24	; 0x05
    4c2c:	7f 83       	std	Y+7, r23	; 0x07
    4c2e:	6e 83       	std	Y+6, r22	; 0x06
	uint32_t ulReturn;

		taskENTER_CRITICAL();
    4c30:	0f b6       	in	r0, 0x3f	; 63
    4c32:	f8 94       	cli
    4c34:	0f 92       	push	r0
		{
			/* Only block if the notification count is not already non-zero. */
			if( pxCurrentTCB->ulNotifiedValue == 0UL )
    4c36:	e0 91 48 06 	lds	r30, 0x0648
    4c3a:	f0 91 49 06 	lds	r31, 0x0649
    4c3e:	85 a1       	ldd	r24, Z+37	; 0x25
    4c40:	96 a1       	ldd	r25, Z+38	; 0x26
    4c42:	a7 a1       	ldd	r26, Z+39	; 0x27
    4c44:	b0 a5       	ldd	r27, Z+40	; 0x28
    4c46:	00 97       	sbiw	r24, 0x00	; 0
    4c48:	a1 05       	cpc	r26, r1
    4c4a:	b1 05       	cpc	r27, r1
    4c4c:	89 f4       	brne	.+34     	; 0x4c70 <ulTaskNotifyTake+0x5a>
			{
				/* Mark this task as waiting for a notification. */
				pxCurrentTCB->ucNotifyState = taskWAITING_NOTIFICATION;
    4c4e:	e0 91 48 06 	lds	r30, 0x0648
    4c52:	f0 91 49 06 	lds	r31, 0x0649
    4c56:	81 e0       	ldi	r24, 0x01	; 1
    4c58:	81 a7       	std	Z+41, r24	; 0x29

				if( xTicksToWait > ( TickType_t ) 0 )
    4c5a:	8e 81       	ldd	r24, Y+6	; 0x06
    4c5c:	9f 81       	ldd	r25, Y+7	; 0x07
    4c5e:	00 97       	sbiw	r24, 0x00	; 0
    4c60:	39 f0       	breq	.+14     	; 0x4c70 <ulTaskNotifyTake+0x5a>
				{
					prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
    4c62:	8e 81       	ldd	r24, Y+6	; 0x06
    4c64:	9f 81       	ldd	r25, Y+7	; 0x07
    4c66:	61 e0       	ldi	r22, 0x01	; 1
    4c68:	0e 94 b3 29 	call	0x5366	; 0x5366 <prvAddCurrentTaskToDelayedList>

					/* All ports are written to allow a yield in a critical
					section (some will yield immediately, others wait until the
					critical section exits) - but it is not something that
					application code should ever do. */
					portYIELD_WITHIN_API();
    4c6c:	0e 94 3c 0a 	call	0x1478	; 0x1478 <vPortYield>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		taskEXIT_CRITICAL();
    4c70:	0f 90       	pop	r0
    4c72:	0f be       	out	0x3f, r0	; 63

		taskENTER_CRITICAL();
    4c74:	0f b6       	in	r0, 0x3f	; 63
    4c76:	f8 94       	cli
    4c78:	0f 92       	push	r0
		{
			traceTASK_NOTIFY_TAKE();
			ulReturn = pxCurrentTCB->ulNotifiedValue;
    4c7a:	e0 91 48 06 	lds	r30, 0x0648
    4c7e:	f0 91 49 06 	lds	r31, 0x0649
    4c82:	85 a1       	ldd	r24, Z+37	; 0x25
    4c84:	96 a1       	ldd	r25, Z+38	; 0x26
    4c86:	a7 a1       	ldd	r26, Z+39	; 0x27
    4c88:	b0 a5       	ldd	r27, Z+40	; 0x28
    4c8a:	89 83       	std	Y+1, r24	; 0x01
    4c8c:	9a 83       	std	Y+2, r25	; 0x02
    4c8e:	ab 83       	std	Y+3, r26	; 0x03
    4c90:	bc 83       	std	Y+4, r27	; 0x04

			if( ulReturn != 0UL )
    4c92:	89 81       	ldd	r24, Y+1	; 0x01
    4c94:	9a 81       	ldd	r25, Y+2	; 0x02
    4c96:	ab 81       	ldd	r26, Y+3	; 0x03
    4c98:	bc 81       	ldd	r27, Y+4	; 0x04
    4c9a:	00 97       	sbiw	r24, 0x00	; 0
    4c9c:	a1 05       	cpc	r26, r1
    4c9e:	b1 05       	cpc	r27, r1
    4ca0:	d9 f0       	breq	.+54     	; 0x4cd8 <ulTaskNotifyTake+0xc2>
			{
				if( xClearCountOnExit != pdFALSE )
    4ca2:	8d 81       	ldd	r24, Y+5	; 0x05
    4ca4:	88 23       	and	r24, r24
    4ca6:	49 f0       	breq	.+18     	; 0x4cba <ulTaskNotifyTake+0xa4>
				{
					pxCurrentTCB->ulNotifiedValue = 0UL;
    4ca8:	e0 91 48 06 	lds	r30, 0x0648
    4cac:	f0 91 49 06 	lds	r31, 0x0649
    4cb0:	15 a2       	std	Z+37, r1	; 0x25
    4cb2:	16 a2       	std	Z+38, r1	; 0x26
    4cb4:	17 a2       	std	Z+39, r1	; 0x27
    4cb6:	10 a6       	std	Z+40, r1	; 0x28
    4cb8:	0f c0       	rjmp	.+30     	; 0x4cd8 <ulTaskNotifyTake+0xc2>
				}
				else
				{
					pxCurrentTCB->ulNotifiedValue = ulReturn - ( uint32_t ) 1;
    4cba:	e0 91 48 06 	lds	r30, 0x0648
    4cbe:	f0 91 49 06 	lds	r31, 0x0649
    4cc2:	89 81       	ldd	r24, Y+1	; 0x01
    4cc4:	9a 81       	ldd	r25, Y+2	; 0x02
    4cc6:	ab 81       	ldd	r26, Y+3	; 0x03
    4cc8:	bc 81       	ldd	r27, Y+4	; 0x04
    4cca:	01 97       	sbiw	r24, 0x01	; 1
    4ccc:	a1 09       	sbc	r26, r1
    4cce:	b1 09       	sbc	r27, r1
    4cd0:	85 a3       	std	Z+37, r24	; 0x25
    4cd2:	96 a3       	std	Z+38, r25	; 0x26
    4cd4:	a7 a3       	std	Z+39, r26	; 0x27
    4cd6:	b0 a7       	std	Z+40, r27	; 0x28
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}

			pxCurrentTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
    4cd8:	e0 91 48 06 	lds	r30, 0x0648
    4cdc:	f0 91 49 06 	lds	r31, 0x0649
    4ce0:	11 a6       	std	Z+41, r1	; 0x29
		}
		taskEXIT_CRITICAL();
    4ce2:	0f 90       	pop	r0
    4ce4:	0f be       	out	0x3f, r0	; 63

		return ulReturn;
    4ce6:	89 81       	ldd	r24, Y+1	; 0x01
    4ce8:	9a 81       	ldd	r25, Y+2	; 0x02
    4cea:	ab 81       	ldd	r26, Y+3	; 0x03
    4cec:	bc 81       	ldd	r27, Y+4	; 0x04
	}
    4cee:	bc 01       	movw	r22, r24
    4cf0:	cd 01       	movw	r24, r26
    4cf2:	27 96       	adiw	r28, 0x07	; 7
    4cf4:	0f b6       	in	r0, 0x3f	; 63
    4cf6:	f8 94       	cli
    4cf8:	de bf       	out	0x3e, r29	; 62
    4cfa:	0f be       	out	0x3f, r0	; 63
    4cfc:	cd bf       	out	0x3d, r28	; 61
    4cfe:	cf 91       	pop	r28
    4d00:	df 91       	pop	r29
    4d02:	08 95       	ret

00004d04 <xTaskNotifyWait>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	BaseType_t xTaskNotifyWait( uint32_t ulBitsToClearOnEntry, uint32_t ulBitsToClearOnExit, uint32_t *pulNotificationValue, TickType_t xTicksToWait )
	{
    4d04:	ef 92       	push	r14
    4d06:	ff 92       	push	r15
    4d08:	0f 93       	push	r16
    4d0a:	1f 93       	push	r17
    4d0c:	df 93       	push	r29
    4d0e:	cf 93       	push	r28
    4d10:	cd b7       	in	r28, 0x3d	; 61
    4d12:	de b7       	in	r29, 0x3e	; 62
    4d14:	2d 97       	sbiw	r28, 0x0d	; 13
    4d16:	0f b6       	in	r0, 0x3f	; 63
    4d18:	f8 94       	cli
    4d1a:	de bf       	out	0x3e, r29	; 62
    4d1c:	0f be       	out	0x3f, r0	; 63
    4d1e:	cd bf       	out	0x3d, r28	; 61
    4d20:	6a 83       	std	Y+2, r22	; 0x02
    4d22:	7b 83       	std	Y+3, r23	; 0x03
    4d24:	8c 83       	std	Y+4, r24	; 0x04
    4d26:	9d 83       	std	Y+5, r25	; 0x05
    4d28:	2e 83       	std	Y+6, r18	; 0x06
    4d2a:	3f 83       	std	Y+7, r19	; 0x07
    4d2c:	48 87       	std	Y+8, r20	; 0x08
    4d2e:	59 87       	std	Y+9, r21	; 0x09
    4d30:	1b 87       	std	Y+11, r17	; 0x0b
    4d32:	0a 87       	std	Y+10, r16	; 0x0a
    4d34:	fd 86       	std	Y+13, r15	; 0x0d
    4d36:	ec 86       	std	Y+12, r14	; 0x0c
	BaseType_t xReturn;

		taskENTER_CRITICAL();
    4d38:	0f b6       	in	r0, 0x3f	; 63
    4d3a:	f8 94       	cli
    4d3c:	0f 92       	push	r0
		{
			/* Only block if a notification is not already pending. */
			if( pxCurrentTCB->ucNotifyState != taskNOTIFICATION_RECEIVED )
    4d3e:	e0 91 48 06 	lds	r30, 0x0648
    4d42:	f0 91 49 06 	lds	r31, 0x0649
    4d46:	81 a5       	ldd	r24, Z+41	; 0x29
    4d48:	82 30       	cpi	r24, 0x02	; 2
    4d4a:	49 f1       	breq	.+82     	; 0x4d9e <xTaskNotifyWait+0x9a>
			{
				/* Clear bits in the task's notification value as bits may get
				set	by the notifying task or interrupt.  This can be used to
				clear the value to zero. */
				pxCurrentTCB->ulNotifiedValue &= ~ulBitsToClearOnEntry;
    4d4c:	e0 91 48 06 	lds	r30, 0x0648
    4d50:	f0 91 49 06 	lds	r31, 0x0649
    4d54:	25 a1       	ldd	r18, Z+37	; 0x25
    4d56:	36 a1       	ldd	r19, Z+38	; 0x26
    4d58:	47 a1       	ldd	r20, Z+39	; 0x27
    4d5a:	50 a5       	ldd	r21, Z+40	; 0x28
    4d5c:	8a 81       	ldd	r24, Y+2	; 0x02
    4d5e:	9b 81       	ldd	r25, Y+3	; 0x03
    4d60:	ac 81       	ldd	r26, Y+4	; 0x04
    4d62:	bd 81       	ldd	r27, Y+5	; 0x05
    4d64:	80 95       	com	r24
    4d66:	90 95       	com	r25
    4d68:	a0 95       	com	r26
    4d6a:	b0 95       	com	r27
    4d6c:	82 23       	and	r24, r18
    4d6e:	93 23       	and	r25, r19
    4d70:	a4 23       	and	r26, r20
    4d72:	b5 23       	and	r27, r21
    4d74:	85 a3       	std	Z+37, r24	; 0x25
    4d76:	96 a3       	std	Z+38, r25	; 0x26
    4d78:	a7 a3       	std	Z+39, r26	; 0x27
    4d7a:	b0 a7       	std	Z+40, r27	; 0x28

				/* Mark this task as waiting for a notification. */
				pxCurrentTCB->ucNotifyState = taskWAITING_NOTIFICATION;
    4d7c:	e0 91 48 06 	lds	r30, 0x0648
    4d80:	f0 91 49 06 	lds	r31, 0x0649
    4d84:	81 e0       	ldi	r24, 0x01	; 1
    4d86:	81 a7       	std	Z+41, r24	; 0x29

				if( xTicksToWait > ( TickType_t ) 0 )
    4d88:	8c 85       	ldd	r24, Y+12	; 0x0c
    4d8a:	9d 85       	ldd	r25, Y+13	; 0x0d
    4d8c:	00 97       	sbiw	r24, 0x00	; 0
    4d8e:	39 f0       	breq	.+14     	; 0x4d9e <xTaskNotifyWait+0x9a>
				{
					prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
    4d90:	8c 85       	ldd	r24, Y+12	; 0x0c
    4d92:	9d 85       	ldd	r25, Y+13	; 0x0d
    4d94:	61 e0       	ldi	r22, 0x01	; 1
    4d96:	0e 94 b3 29 	call	0x5366	; 0x5366 <prvAddCurrentTaskToDelayedList>

					/* All ports are written to allow a yield in a critical
					section (some will yield immediately, others wait until the
					critical section exits) - but it is not something that
					application code should ever do. */
					portYIELD_WITHIN_API();
    4d9a:	0e 94 3c 0a 	call	0x1478	; 0x1478 <vPortYield>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		taskEXIT_CRITICAL();
    4d9e:	0f 90       	pop	r0
    4da0:	0f be       	out	0x3f, r0	; 63

		taskENTER_CRITICAL();
    4da2:	0f b6       	in	r0, 0x3f	; 63
    4da4:	f8 94       	cli
    4da6:	0f 92       	push	r0
		{
			traceTASK_NOTIFY_WAIT();

			if( pulNotificationValue != NULL )
    4da8:	8a 85       	ldd	r24, Y+10	; 0x0a
    4daa:	9b 85       	ldd	r25, Y+11	; 0x0b
    4dac:	00 97       	sbiw	r24, 0x00	; 0
    4dae:	71 f0       	breq	.+28     	; 0x4dcc <xTaskNotifyWait+0xc8>
			{
				/* Output the current notification value, which may or may not
				have changed. */
				*pulNotificationValue = pxCurrentTCB->ulNotifiedValue;
    4db0:	e0 91 48 06 	lds	r30, 0x0648
    4db4:	f0 91 49 06 	lds	r31, 0x0649
    4db8:	85 a1       	ldd	r24, Z+37	; 0x25
    4dba:	96 a1       	ldd	r25, Z+38	; 0x26
    4dbc:	a7 a1       	ldd	r26, Z+39	; 0x27
    4dbe:	b0 a5       	ldd	r27, Z+40	; 0x28
    4dc0:	ea 85       	ldd	r30, Y+10	; 0x0a
    4dc2:	fb 85       	ldd	r31, Y+11	; 0x0b
    4dc4:	80 83       	st	Z, r24
    4dc6:	91 83       	std	Z+1, r25	; 0x01
    4dc8:	a2 83       	std	Z+2, r26	; 0x02
    4dca:	b3 83       	std	Z+3, r27	; 0x03

			/* If ucNotifyValue is set then either the task never entered the
			blocked state (because a notification was already pending) or the
			task unblocked because of a notification.  Otherwise the task
			unblocked because of a timeout. */
			if( pxCurrentTCB->ucNotifyState != taskNOTIFICATION_RECEIVED )
    4dcc:	e0 91 48 06 	lds	r30, 0x0648
    4dd0:	f0 91 49 06 	lds	r31, 0x0649
    4dd4:	81 a5       	ldd	r24, Z+41	; 0x29
    4dd6:	82 30       	cpi	r24, 0x02	; 2
    4dd8:	11 f0       	breq	.+4      	; 0x4dde <xTaskNotifyWait+0xda>
			{
				/* A notification was not received. */
				xReturn = pdFALSE;
    4dda:	19 82       	std	Y+1, r1	; 0x01
    4ddc:	1a c0       	rjmp	.+52     	; 0x4e12 <xTaskNotifyWait+0x10e>
			}
			else
			{
				/* A notification was already pending or a notification was
				received while the task was waiting. */
				pxCurrentTCB->ulNotifiedValue &= ~ulBitsToClearOnExit;
    4dde:	e0 91 48 06 	lds	r30, 0x0648
    4de2:	f0 91 49 06 	lds	r31, 0x0649
    4de6:	25 a1       	ldd	r18, Z+37	; 0x25
    4de8:	36 a1       	ldd	r19, Z+38	; 0x26
    4dea:	47 a1       	ldd	r20, Z+39	; 0x27
    4dec:	50 a5       	ldd	r21, Z+40	; 0x28
    4dee:	8e 81       	ldd	r24, Y+6	; 0x06
    4df0:	9f 81       	ldd	r25, Y+7	; 0x07
    4df2:	a8 85       	ldd	r26, Y+8	; 0x08
    4df4:	b9 85       	ldd	r27, Y+9	; 0x09
    4df6:	80 95       	com	r24
    4df8:	90 95       	com	r25
    4dfa:	a0 95       	com	r26
    4dfc:	b0 95       	com	r27
    4dfe:	82 23       	and	r24, r18
    4e00:	93 23       	and	r25, r19
    4e02:	a4 23       	and	r26, r20
    4e04:	b5 23       	and	r27, r21
    4e06:	85 a3       	std	Z+37, r24	; 0x25
    4e08:	96 a3       	std	Z+38, r25	; 0x26
    4e0a:	a7 a3       	std	Z+39, r26	; 0x27
    4e0c:	b0 a7       	std	Z+40, r27	; 0x28
				xReturn = pdTRUE;
    4e0e:	81 e0       	ldi	r24, 0x01	; 1
    4e10:	89 83       	std	Y+1, r24	; 0x01
			}

			pxCurrentTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
    4e12:	e0 91 48 06 	lds	r30, 0x0648
    4e16:	f0 91 49 06 	lds	r31, 0x0649
    4e1a:	11 a6       	std	Z+41, r1	; 0x29
		}
		taskEXIT_CRITICAL();
    4e1c:	0f 90       	pop	r0
    4e1e:	0f be       	out	0x3f, r0	; 63

		return xReturn;
    4e20:	89 81       	ldd	r24, Y+1	; 0x01
	}
    4e22:	2d 96       	adiw	r28, 0x0d	; 13
    4e24:	0f b6       	in	r0, 0x3f	; 63
    4e26:	f8 94       	cli
    4e28:	de bf       	out	0x3e, r29	; 62
    4e2a:	0f be       	out	0x3f, r0	; 63
    4e2c:	cd bf       	out	0x3d, r28	; 61
    4e2e:	cf 91       	pop	r28
    4e30:	df 91       	pop	r29
    4e32:	1f 91       	pop	r17
    4e34:	0f 91       	pop	r16
    4e36:	ff 90       	pop	r15
    4e38:	ef 90       	pop	r14
    4e3a:	08 95       	ret

00004e3c <xTaskGenericNotify>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	BaseType_t xTaskGenericNotify( TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction, uint32_t *pulPreviousNotificationValue )
	{
    4e3c:	0f 93       	push	r16
    4e3e:	1f 93       	push	r17
    4e40:	df 93       	push	r29
    4e42:	cf 93       	push	r28
    4e44:	cd b7       	in	r28, 0x3d	; 61
    4e46:	de b7       	in	r29, 0x3e	; 62
    4e48:	2f 97       	sbiw	r28, 0x0f	; 15
    4e4a:	0f b6       	in	r0, 0x3f	; 63
    4e4c:	f8 94       	cli
    4e4e:	de bf       	out	0x3e, r29	; 62
    4e50:	0f be       	out	0x3f, r0	; 63
    4e52:	cd bf       	out	0x3d, r28	; 61
    4e54:	9e 83       	std	Y+6, r25	; 0x06
    4e56:	8d 83       	std	Y+5, r24	; 0x05
    4e58:	4f 83       	std	Y+7, r20	; 0x07
    4e5a:	58 87       	std	Y+8, r21	; 0x08
    4e5c:	69 87       	std	Y+9, r22	; 0x09
    4e5e:	7a 87       	std	Y+10, r23	; 0x0a
    4e60:	2b 87       	std	Y+11, r18	; 0x0b
    4e62:	1d 87       	std	Y+13, r17	; 0x0d
    4e64:	0c 87       	std	Y+12, r16	; 0x0c
	TCB_t * pxTCB;
	BaseType_t xReturn = pdPASS;
    4e66:	81 e0       	ldi	r24, 0x01	; 1
    4e68:	8a 83       	std	Y+2, r24	; 0x02
	uint8_t ucOriginalNotifyState;

		configASSERT( xTaskToNotify );
		pxTCB = xTaskToNotify;
    4e6a:	8d 81       	ldd	r24, Y+5	; 0x05
    4e6c:	9e 81       	ldd	r25, Y+6	; 0x06
    4e6e:	9c 83       	std	Y+4, r25	; 0x04
    4e70:	8b 83       	std	Y+3, r24	; 0x03

		taskENTER_CRITICAL();
    4e72:	0f b6       	in	r0, 0x3f	; 63
    4e74:	f8 94       	cli
    4e76:	0f 92       	push	r0
		{
			if( pulPreviousNotificationValue != NULL )
    4e78:	8c 85       	ldd	r24, Y+12	; 0x0c
    4e7a:	9d 85       	ldd	r25, Y+13	; 0x0d
    4e7c:	00 97       	sbiw	r24, 0x00	; 0
    4e7e:	61 f0       	breq	.+24     	; 0x4e98 <xTaskGenericNotify+0x5c>
			{
				*pulPreviousNotificationValue = pxTCB->ulNotifiedValue;
    4e80:	eb 81       	ldd	r30, Y+3	; 0x03
    4e82:	fc 81       	ldd	r31, Y+4	; 0x04
    4e84:	85 a1       	ldd	r24, Z+37	; 0x25
    4e86:	96 a1       	ldd	r25, Z+38	; 0x26
    4e88:	a7 a1       	ldd	r26, Z+39	; 0x27
    4e8a:	b0 a5       	ldd	r27, Z+40	; 0x28
    4e8c:	ec 85       	ldd	r30, Y+12	; 0x0c
    4e8e:	fd 85       	ldd	r31, Y+13	; 0x0d
    4e90:	80 83       	st	Z, r24
    4e92:	91 83       	std	Z+1, r25	; 0x01
    4e94:	a2 83       	std	Z+2, r26	; 0x02
    4e96:	b3 83       	std	Z+3, r27	; 0x03
			}

			ucOriginalNotifyState = pxTCB->ucNotifyState;
    4e98:	eb 81       	ldd	r30, Y+3	; 0x03
    4e9a:	fc 81       	ldd	r31, Y+4	; 0x04
    4e9c:	81 a5       	ldd	r24, Z+41	; 0x29
    4e9e:	89 83       	std	Y+1, r24	; 0x01

			pxTCB->ucNotifyState = taskNOTIFICATION_RECEIVED;
    4ea0:	eb 81       	ldd	r30, Y+3	; 0x03
    4ea2:	fc 81       	ldd	r31, Y+4	; 0x04
    4ea4:	82 e0       	ldi	r24, 0x02	; 2
    4ea6:	81 a7       	std	Z+41, r24	; 0x29

			switch( eAction )
    4ea8:	8b 85       	ldd	r24, Y+11	; 0x0b
    4eaa:	28 2f       	mov	r18, r24
    4eac:	30 e0       	ldi	r19, 0x00	; 0
    4eae:	3f 87       	std	Y+15, r19	; 0x0f
    4eb0:	2e 87       	std	Y+14, r18	; 0x0e
    4eb2:	8e 85       	ldd	r24, Y+14	; 0x0e
    4eb4:	9f 85       	ldd	r25, Y+15	; 0x0f
    4eb6:	82 30       	cpi	r24, 0x02	; 2
    4eb8:	91 05       	cpc	r25, r1
    4eba:	59 f1       	breq	.+86     	; 0x4f12 <xTaskGenericNotify+0xd6>
    4ebc:	2e 85       	ldd	r18, Y+14	; 0x0e
    4ebe:	3f 85       	ldd	r19, Y+15	; 0x0f
    4ec0:	23 30       	cpi	r18, 0x03	; 3
    4ec2:	31 05       	cpc	r19, r1
    4ec4:	34 f4       	brge	.+12     	; 0x4ed2 <xTaskGenericNotify+0x96>
    4ec6:	8e 85       	ldd	r24, Y+14	; 0x0e
    4ec8:	9f 85       	ldd	r25, Y+15	; 0x0f
    4eca:	81 30       	cpi	r24, 0x01	; 1
    4ecc:	91 05       	cpc	r25, r1
    4ece:	61 f0       	breq	.+24     	; 0x4ee8 <xTaskGenericNotify+0xac>
    4ed0:	4a c0       	rjmp	.+148    	; 0x4f66 <xTaskGenericNotify+0x12a>
    4ed2:	2e 85       	ldd	r18, Y+14	; 0x0e
    4ed4:	3f 85       	ldd	r19, Y+15	; 0x0f
    4ed6:	23 30       	cpi	r18, 0x03	; 3
    4ed8:	31 05       	cpc	r19, r1
    4eda:	59 f1       	breq	.+86     	; 0x4f32 <xTaskGenericNotify+0xf6>
    4edc:	8e 85       	ldd	r24, Y+14	; 0x0e
    4ede:	9f 85       	ldd	r25, Y+15	; 0x0f
    4ee0:	84 30       	cpi	r24, 0x04	; 4
    4ee2:	91 05       	cpc	r25, r1
    4ee4:	89 f1       	breq	.+98     	; 0x4f48 <xTaskGenericNotify+0x10c>
    4ee6:	3f c0       	rjmp	.+126    	; 0x4f66 <xTaskGenericNotify+0x12a>
			{
				case eSetBits	:
					pxTCB->ulNotifiedValue |= ulValue;
    4ee8:	eb 81       	ldd	r30, Y+3	; 0x03
    4eea:	fc 81       	ldd	r31, Y+4	; 0x04
    4eec:	25 a1       	ldd	r18, Z+37	; 0x25
    4eee:	36 a1       	ldd	r19, Z+38	; 0x26
    4ef0:	47 a1       	ldd	r20, Z+39	; 0x27
    4ef2:	50 a5       	ldd	r21, Z+40	; 0x28
    4ef4:	8f 81       	ldd	r24, Y+7	; 0x07
    4ef6:	98 85       	ldd	r25, Y+8	; 0x08
    4ef8:	a9 85       	ldd	r26, Y+9	; 0x09
    4efa:	ba 85       	ldd	r27, Y+10	; 0x0a
    4efc:	82 2b       	or	r24, r18
    4efe:	93 2b       	or	r25, r19
    4f00:	a4 2b       	or	r26, r20
    4f02:	b5 2b       	or	r27, r21
    4f04:	eb 81       	ldd	r30, Y+3	; 0x03
    4f06:	fc 81       	ldd	r31, Y+4	; 0x04
    4f08:	85 a3       	std	Z+37, r24	; 0x25
    4f0a:	96 a3       	std	Z+38, r25	; 0x26
    4f0c:	a7 a3       	std	Z+39, r26	; 0x27
    4f0e:	b0 a7       	std	Z+40, r27	; 0x28
    4f10:	2a c0       	rjmp	.+84     	; 0x4f66 <xTaskGenericNotify+0x12a>
					break;

				case eIncrement	:
					( pxTCB->ulNotifiedValue )++;
    4f12:	eb 81       	ldd	r30, Y+3	; 0x03
    4f14:	fc 81       	ldd	r31, Y+4	; 0x04
    4f16:	85 a1       	ldd	r24, Z+37	; 0x25
    4f18:	96 a1       	ldd	r25, Z+38	; 0x26
    4f1a:	a7 a1       	ldd	r26, Z+39	; 0x27
    4f1c:	b0 a5       	ldd	r27, Z+40	; 0x28
    4f1e:	01 96       	adiw	r24, 0x01	; 1
    4f20:	a1 1d       	adc	r26, r1
    4f22:	b1 1d       	adc	r27, r1
    4f24:	eb 81       	ldd	r30, Y+3	; 0x03
    4f26:	fc 81       	ldd	r31, Y+4	; 0x04
    4f28:	85 a3       	std	Z+37, r24	; 0x25
    4f2a:	96 a3       	std	Z+38, r25	; 0x26
    4f2c:	a7 a3       	std	Z+39, r26	; 0x27
    4f2e:	b0 a7       	std	Z+40, r27	; 0x28
    4f30:	1a c0       	rjmp	.+52     	; 0x4f66 <xTaskGenericNotify+0x12a>
					break;

				case eSetValueWithOverwrite	:
					pxTCB->ulNotifiedValue = ulValue;
    4f32:	eb 81       	ldd	r30, Y+3	; 0x03
    4f34:	fc 81       	ldd	r31, Y+4	; 0x04
    4f36:	8f 81       	ldd	r24, Y+7	; 0x07
    4f38:	98 85       	ldd	r25, Y+8	; 0x08
    4f3a:	a9 85       	ldd	r26, Y+9	; 0x09
    4f3c:	ba 85       	ldd	r27, Y+10	; 0x0a
    4f3e:	85 a3       	std	Z+37, r24	; 0x25
    4f40:	96 a3       	std	Z+38, r25	; 0x26
    4f42:	a7 a3       	std	Z+39, r26	; 0x27
    4f44:	b0 a7       	std	Z+40, r27	; 0x28
    4f46:	0f c0       	rjmp	.+30     	; 0x4f66 <xTaskGenericNotify+0x12a>
					break;

				case eSetValueWithoutOverwrite :
					if( ucOriginalNotifyState != taskNOTIFICATION_RECEIVED )
    4f48:	89 81       	ldd	r24, Y+1	; 0x01
    4f4a:	82 30       	cpi	r24, 0x02	; 2
    4f4c:	59 f0       	breq	.+22     	; 0x4f64 <xTaskGenericNotify+0x128>
					{
						pxTCB->ulNotifiedValue = ulValue;
    4f4e:	eb 81       	ldd	r30, Y+3	; 0x03
    4f50:	fc 81       	ldd	r31, Y+4	; 0x04
    4f52:	8f 81       	ldd	r24, Y+7	; 0x07
    4f54:	98 85       	ldd	r25, Y+8	; 0x08
    4f56:	a9 85       	ldd	r26, Y+9	; 0x09
    4f58:	ba 85       	ldd	r27, Y+10	; 0x0a
    4f5a:	85 a3       	std	Z+37, r24	; 0x25
    4f5c:	96 a3       	std	Z+38, r25	; 0x26
    4f5e:	a7 a3       	std	Z+39, r26	; 0x27
    4f60:	b0 a7       	std	Z+40, r27	; 0x28
    4f62:	01 c0       	rjmp	.+2      	; 0x4f66 <xTaskGenericNotify+0x12a>
					}
					else
					{
						/* The value could not be written to the task. */
						xReturn = pdFAIL;
    4f64:	1a 82       	std	Y+2, r1	; 0x02

			traceTASK_NOTIFY();

			/* If the task is in the blocked state specifically to wait for a
			notification then unblock it now. */
			if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
    4f66:	89 81       	ldd	r24, Y+1	; 0x01
    4f68:	81 30       	cpi	r24, 0x01	; 1
    4f6a:	b9 f5       	brne	.+110    	; 0x4fda <xTaskGenericNotify+0x19e>
			{
				( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    4f6c:	8b 81       	ldd	r24, Y+3	; 0x03
    4f6e:	9c 81       	ldd	r25, Y+4	; 0x04
    4f70:	02 96       	adiw	r24, 0x02	; 2
    4f72:	0e 94 90 07 	call	0xf20	; 0xf20 <uxListRemove>
				prvAddTaskToReadyList( pxTCB );
    4f76:	eb 81       	ldd	r30, Y+3	; 0x03
    4f78:	fc 81       	ldd	r31, Y+4	; 0x04
    4f7a:	96 89       	ldd	r25, Z+22	; 0x16
    4f7c:	80 91 4e 06 	lds	r24, 0x064E
    4f80:	89 17       	cp	r24, r25
    4f82:	28 f4       	brcc	.+10     	; 0x4f8e <xTaskGenericNotify+0x152>
    4f84:	eb 81       	ldd	r30, Y+3	; 0x03
    4f86:	fc 81       	ldd	r31, Y+4	; 0x04
    4f88:	86 89       	ldd	r24, Z+22	; 0x16
    4f8a:	80 93 4e 06 	sts	0x064E, r24
    4f8e:	eb 81       	ldd	r30, Y+3	; 0x03
    4f90:	fc 81       	ldd	r31, Y+4	; 0x04
    4f92:	86 89       	ldd	r24, Z+22	; 0x16
    4f94:	28 2f       	mov	r18, r24
    4f96:	30 e0       	ldi	r19, 0x00	; 0
    4f98:	c9 01       	movw	r24, r18
    4f9a:	88 0f       	add	r24, r24
    4f9c:	99 1f       	adc	r25, r25
    4f9e:	88 0f       	add	r24, r24
    4fa0:	99 1f       	adc	r25, r25
    4fa2:	88 0f       	add	r24, r24
    4fa4:	99 1f       	adc	r25, r25
    4fa6:	82 0f       	add	r24, r18
    4fa8:	93 1f       	adc	r25, r19
    4faa:	ac 01       	movw	r20, r24
    4fac:	47 5a       	subi	r20, 0xA7	; 167
    4fae:	59 4f       	sbci	r21, 0xF9	; 249
    4fb0:	8b 81       	ldd	r24, Y+3	; 0x03
    4fb2:	9c 81       	ldd	r25, Y+4	; 0x04
    4fb4:	9c 01       	movw	r18, r24
    4fb6:	2e 5f       	subi	r18, 0xFE	; 254
    4fb8:	3f 4f       	sbci	r19, 0xFF	; 255
    4fba:	ca 01       	movw	r24, r20
    4fbc:	b9 01       	movw	r22, r18
    4fbe:	0e 94 e0 06 	call	0xdc0	; 0xdc0 <vListInsertEnd>
					earliest possible time. */
					prvResetNextTaskUnblockTime();
				}
				#endif

				if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
    4fc2:	eb 81       	ldd	r30, Y+3	; 0x03
    4fc4:	fc 81       	ldd	r31, Y+4	; 0x04
    4fc6:	96 89       	ldd	r25, Z+22	; 0x16
    4fc8:	e0 91 48 06 	lds	r30, 0x0648
    4fcc:	f0 91 49 06 	lds	r31, 0x0649
    4fd0:	86 89       	ldd	r24, Z+22	; 0x16
    4fd2:	89 17       	cp	r24, r25
    4fd4:	10 f4       	brcc	.+4      	; 0x4fda <xTaskGenericNotify+0x19e>
				{
					/* The notified task has a priority above the currently
					executing task so a yield is required. */
					taskYIELD_IF_USING_PREEMPTION();
    4fd6:	0e 94 3c 0a 	call	0x1478	; 0x1478 <vPortYield>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		taskEXIT_CRITICAL();
    4fda:	0f 90       	pop	r0
    4fdc:	0f be       	out	0x3f, r0	; 63

		return xReturn;
    4fde:	8a 81       	ldd	r24, Y+2	; 0x02
	}
    4fe0:	2f 96       	adiw	r28, 0x0f	; 15
    4fe2:	0f b6       	in	r0, 0x3f	; 63
    4fe4:	f8 94       	cli
    4fe6:	de bf       	out	0x3e, r29	; 62
    4fe8:	0f be       	out	0x3f, r0	; 63
    4fea:	cd bf       	out	0x3d, r28	; 61
    4fec:	cf 91       	pop	r28
    4fee:	df 91       	pop	r29
    4ff0:	1f 91       	pop	r17
    4ff2:	0f 91       	pop	r16
    4ff4:	08 95       	ret

00004ff6 <xTaskGenericNotifyFromISR>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	BaseType_t xTaskGenericNotifyFromISR( TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction, uint32_t *pulPreviousNotificationValue, BaseType_t *pxHigherPriorityTaskWoken )
	{
    4ff6:	ef 92       	push	r14
    4ff8:	ff 92       	push	r15
    4ffa:	0f 93       	push	r16
    4ffc:	1f 93       	push	r17
    4ffe:	df 93       	push	r29
    5000:	cf 93       	push	r28
    5002:	cd b7       	in	r28, 0x3d	; 61
    5004:	de b7       	in	r29, 0x3e	; 62
    5006:	62 97       	sbiw	r28, 0x12	; 18
    5008:	0f b6       	in	r0, 0x3f	; 63
    500a:	f8 94       	cli
    500c:	de bf       	out	0x3e, r29	; 62
    500e:	0f be       	out	0x3f, r0	; 63
    5010:	cd bf       	out	0x3d, r28	; 61
    5012:	9f 83       	std	Y+7, r25	; 0x07
    5014:	8e 83       	std	Y+6, r24	; 0x06
    5016:	48 87       	std	Y+8, r20	; 0x08
    5018:	59 87       	std	Y+9, r21	; 0x09
    501a:	6a 87       	std	Y+10, r22	; 0x0a
    501c:	7b 87       	std	Y+11, r23	; 0x0b
    501e:	2c 87       	std	Y+12, r18	; 0x0c
    5020:	1e 87       	std	Y+14, r17	; 0x0e
    5022:	0d 87       	std	Y+13, r16	; 0x0d
    5024:	f8 8a       	std	Y+16, r15	; 0x10
    5026:	ef 86       	std	Y+15, r14	; 0x0f
	TCB_t * pxTCB;
	uint8_t ucOriginalNotifyState;
	BaseType_t xReturn = pdPASS;
    5028:	81 e0       	ldi	r24, 0x01	; 1
    502a:	8a 83       	std	Y+2, r24	; 0x02
		simple as possible.  More information (albeit Cortex-M specific) is
		provided on the following link:
		http://www.freertos.org/RTOS-Cortex-M3-M4.html */
		portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

		pxTCB = xTaskToNotify;
    502c:	8e 81       	ldd	r24, Y+6	; 0x06
    502e:	9f 81       	ldd	r25, Y+7	; 0x07
    5030:	9d 83       	std	Y+5, r25	; 0x05
    5032:	8c 83       	std	Y+4, r24	; 0x04

		uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    5034:	19 82       	std	Y+1, r1	; 0x01
		{
			if( pulPreviousNotificationValue != NULL )
    5036:	8d 85       	ldd	r24, Y+13	; 0x0d
    5038:	9e 85       	ldd	r25, Y+14	; 0x0e
    503a:	00 97       	sbiw	r24, 0x00	; 0
    503c:	61 f0       	breq	.+24     	; 0x5056 <xTaskGenericNotifyFromISR+0x60>
			{
				*pulPreviousNotificationValue = pxTCB->ulNotifiedValue;
    503e:	ec 81       	ldd	r30, Y+4	; 0x04
    5040:	fd 81       	ldd	r31, Y+5	; 0x05
    5042:	85 a1       	ldd	r24, Z+37	; 0x25
    5044:	96 a1       	ldd	r25, Z+38	; 0x26
    5046:	a7 a1       	ldd	r26, Z+39	; 0x27
    5048:	b0 a5       	ldd	r27, Z+40	; 0x28
    504a:	ed 85       	ldd	r30, Y+13	; 0x0d
    504c:	fe 85       	ldd	r31, Y+14	; 0x0e
    504e:	80 83       	st	Z, r24
    5050:	91 83       	std	Z+1, r25	; 0x01
    5052:	a2 83       	std	Z+2, r26	; 0x02
    5054:	b3 83       	std	Z+3, r27	; 0x03
			}

			ucOriginalNotifyState = pxTCB->ucNotifyState;
    5056:	ec 81       	ldd	r30, Y+4	; 0x04
    5058:	fd 81       	ldd	r31, Y+5	; 0x05
    505a:	81 a5       	ldd	r24, Z+41	; 0x29
    505c:	8b 83       	std	Y+3, r24	; 0x03
			pxTCB->ucNotifyState = taskNOTIFICATION_RECEIVED;
    505e:	ec 81       	ldd	r30, Y+4	; 0x04
    5060:	fd 81       	ldd	r31, Y+5	; 0x05
    5062:	82 e0       	ldi	r24, 0x02	; 2
    5064:	81 a7       	std	Z+41, r24	; 0x29

			switch( eAction )
    5066:	8c 85       	ldd	r24, Y+12	; 0x0c
    5068:	28 2f       	mov	r18, r24
    506a:	30 e0       	ldi	r19, 0x00	; 0
    506c:	3a 8b       	std	Y+18, r19	; 0x12
    506e:	29 8b       	std	Y+17, r18	; 0x11
    5070:	89 89       	ldd	r24, Y+17	; 0x11
    5072:	9a 89       	ldd	r25, Y+18	; 0x12
    5074:	82 30       	cpi	r24, 0x02	; 2
    5076:	91 05       	cpc	r25, r1
    5078:	59 f1       	breq	.+86     	; 0x50d0 <xTaskGenericNotifyFromISR+0xda>
    507a:	29 89       	ldd	r18, Y+17	; 0x11
    507c:	3a 89       	ldd	r19, Y+18	; 0x12
    507e:	23 30       	cpi	r18, 0x03	; 3
    5080:	31 05       	cpc	r19, r1
    5082:	34 f4       	brge	.+12     	; 0x5090 <xTaskGenericNotifyFromISR+0x9a>
    5084:	89 89       	ldd	r24, Y+17	; 0x11
    5086:	9a 89       	ldd	r25, Y+18	; 0x12
    5088:	81 30       	cpi	r24, 0x01	; 1
    508a:	91 05       	cpc	r25, r1
    508c:	61 f0       	breq	.+24     	; 0x50a6 <xTaskGenericNotifyFromISR+0xb0>
    508e:	4a c0       	rjmp	.+148    	; 0x5124 <xTaskGenericNotifyFromISR+0x12e>
    5090:	29 89       	ldd	r18, Y+17	; 0x11
    5092:	3a 89       	ldd	r19, Y+18	; 0x12
    5094:	23 30       	cpi	r18, 0x03	; 3
    5096:	31 05       	cpc	r19, r1
    5098:	59 f1       	breq	.+86     	; 0x50f0 <xTaskGenericNotifyFromISR+0xfa>
    509a:	89 89       	ldd	r24, Y+17	; 0x11
    509c:	9a 89       	ldd	r25, Y+18	; 0x12
    509e:	84 30       	cpi	r24, 0x04	; 4
    50a0:	91 05       	cpc	r25, r1
    50a2:	89 f1       	breq	.+98     	; 0x5106 <xTaskGenericNotifyFromISR+0x110>
    50a4:	3f c0       	rjmp	.+126    	; 0x5124 <xTaskGenericNotifyFromISR+0x12e>
			{
				case eSetBits	:
					pxTCB->ulNotifiedValue |= ulValue;
    50a6:	ec 81       	ldd	r30, Y+4	; 0x04
    50a8:	fd 81       	ldd	r31, Y+5	; 0x05
    50aa:	25 a1       	ldd	r18, Z+37	; 0x25
    50ac:	36 a1       	ldd	r19, Z+38	; 0x26
    50ae:	47 a1       	ldd	r20, Z+39	; 0x27
    50b0:	50 a5       	ldd	r21, Z+40	; 0x28
    50b2:	88 85       	ldd	r24, Y+8	; 0x08
    50b4:	99 85       	ldd	r25, Y+9	; 0x09
    50b6:	aa 85       	ldd	r26, Y+10	; 0x0a
    50b8:	bb 85       	ldd	r27, Y+11	; 0x0b
    50ba:	82 2b       	or	r24, r18
    50bc:	93 2b       	or	r25, r19
    50be:	a4 2b       	or	r26, r20
    50c0:	b5 2b       	or	r27, r21
    50c2:	ec 81       	ldd	r30, Y+4	; 0x04
    50c4:	fd 81       	ldd	r31, Y+5	; 0x05
    50c6:	85 a3       	std	Z+37, r24	; 0x25
    50c8:	96 a3       	std	Z+38, r25	; 0x26
    50ca:	a7 a3       	std	Z+39, r26	; 0x27
    50cc:	b0 a7       	std	Z+40, r27	; 0x28
    50ce:	2a c0       	rjmp	.+84     	; 0x5124 <xTaskGenericNotifyFromISR+0x12e>
					break;

				case eIncrement	:
					( pxTCB->ulNotifiedValue )++;
    50d0:	ec 81       	ldd	r30, Y+4	; 0x04
    50d2:	fd 81       	ldd	r31, Y+5	; 0x05
    50d4:	85 a1       	ldd	r24, Z+37	; 0x25
    50d6:	96 a1       	ldd	r25, Z+38	; 0x26
    50d8:	a7 a1       	ldd	r26, Z+39	; 0x27
    50da:	b0 a5       	ldd	r27, Z+40	; 0x28
    50dc:	01 96       	adiw	r24, 0x01	; 1
    50de:	a1 1d       	adc	r26, r1
    50e0:	b1 1d       	adc	r27, r1
    50e2:	ec 81       	ldd	r30, Y+4	; 0x04
    50e4:	fd 81       	ldd	r31, Y+5	; 0x05
    50e6:	85 a3       	std	Z+37, r24	; 0x25
    50e8:	96 a3       	std	Z+38, r25	; 0x26
    50ea:	a7 a3       	std	Z+39, r26	; 0x27
    50ec:	b0 a7       	std	Z+40, r27	; 0x28
    50ee:	1a c0       	rjmp	.+52     	; 0x5124 <xTaskGenericNotifyFromISR+0x12e>
					break;

				case eSetValueWithOverwrite	:
					pxTCB->ulNotifiedValue = ulValue;
    50f0:	ec 81       	ldd	r30, Y+4	; 0x04
    50f2:	fd 81       	ldd	r31, Y+5	; 0x05
    50f4:	88 85       	ldd	r24, Y+8	; 0x08
    50f6:	99 85       	ldd	r25, Y+9	; 0x09
    50f8:	aa 85       	ldd	r26, Y+10	; 0x0a
    50fa:	bb 85       	ldd	r27, Y+11	; 0x0b
    50fc:	85 a3       	std	Z+37, r24	; 0x25
    50fe:	96 a3       	std	Z+38, r25	; 0x26
    5100:	a7 a3       	std	Z+39, r26	; 0x27
    5102:	b0 a7       	std	Z+40, r27	; 0x28
    5104:	0f c0       	rjmp	.+30     	; 0x5124 <xTaskGenericNotifyFromISR+0x12e>
					break;

				case eSetValueWithoutOverwrite :
					if( ucOriginalNotifyState != taskNOTIFICATION_RECEIVED )
    5106:	8b 81       	ldd	r24, Y+3	; 0x03
    5108:	82 30       	cpi	r24, 0x02	; 2
    510a:	59 f0       	breq	.+22     	; 0x5122 <xTaskGenericNotifyFromISR+0x12c>
					{
						pxTCB->ulNotifiedValue = ulValue;
    510c:	ec 81       	ldd	r30, Y+4	; 0x04
    510e:	fd 81       	ldd	r31, Y+5	; 0x05
    5110:	88 85       	ldd	r24, Y+8	; 0x08
    5112:	99 85       	ldd	r25, Y+9	; 0x09
    5114:	aa 85       	ldd	r26, Y+10	; 0x0a
    5116:	bb 85       	ldd	r27, Y+11	; 0x0b
    5118:	85 a3       	std	Z+37, r24	; 0x25
    511a:	96 a3       	std	Z+38, r25	; 0x26
    511c:	a7 a3       	std	Z+39, r26	; 0x27
    511e:	b0 a7       	std	Z+40, r27	; 0x28
    5120:	01 c0       	rjmp	.+2      	; 0x5124 <xTaskGenericNotifyFromISR+0x12e>
					}
					else
					{
						/* The value could not be written to the task. */
						xReturn = pdFAIL;
    5122:	1a 82       	std	Y+2, r1	; 0x02

			traceTASK_NOTIFY_FROM_ISR();

			/* If the task is in the blocked state specifically to wait for a
			notification then unblock it now. */
			if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
    5124:	8b 81       	ldd	r24, Y+3	; 0x03
    5126:	81 30       	cpi	r24, 0x01	; 1
    5128:	09 f0       	breq	.+2      	; 0x512c <xTaskGenericNotifyFromISR+0x136>
    512a:	4f c0       	rjmp	.+158    	; 0x51ca <xTaskGenericNotifyFromISR+0x1d4>
			{
				/* The task should not have been on an event list. */
				configASSERT( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL );

				if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    512c:	80 91 58 06 	lds	r24, 0x0658
    5130:	88 23       	and	r24, r24
    5132:	61 f5       	brne	.+88     	; 0x518c <xTaskGenericNotifyFromISR+0x196>
				{
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    5134:	8c 81       	ldd	r24, Y+4	; 0x04
    5136:	9d 81       	ldd	r25, Y+5	; 0x05
    5138:	02 96       	adiw	r24, 0x02	; 2
    513a:	0e 94 90 07 	call	0xf20	; 0xf20 <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
    513e:	ec 81       	ldd	r30, Y+4	; 0x04
    5140:	fd 81       	ldd	r31, Y+5	; 0x05
    5142:	96 89       	ldd	r25, Z+22	; 0x16
    5144:	80 91 4e 06 	lds	r24, 0x064E
    5148:	89 17       	cp	r24, r25
    514a:	28 f4       	brcc	.+10     	; 0x5156 <xTaskGenericNotifyFromISR+0x160>
    514c:	ec 81       	ldd	r30, Y+4	; 0x04
    514e:	fd 81       	ldd	r31, Y+5	; 0x05
    5150:	86 89       	ldd	r24, Z+22	; 0x16
    5152:	80 93 4e 06 	sts	0x064E, r24
    5156:	ec 81       	ldd	r30, Y+4	; 0x04
    5158:	fd 81       	ldd	r31, Y+5	; 0x05
    515a:	86 89       	ldd	r24, Z+22	; 0x16
    515c:	28 2f       	mov	r18, r24
    515e:	30 e0       	ldi	r19, 0x00	; 0
    5160:	c9 01       	movw	r24, r18
    5162:	88 0f       	add	r24, r24
    5164:	99 1f       	adc	r25, r25
    5166:	88 0f       	add	r24, r24
    5168:	99 1f       	adc	r25, r25
    516a:	88 0f       	add	r24, r24
    516c:	99 1f       	adc	r25, r25
    516e:	82 0f       	add	r24, r18
    5170:	93 1f       	adc	r25, r19
    5172:	ac 01       	movw	r20, r24
    5174:	47 5a       	subi	r20, 0xA7	; 167
    5176:	59 4f       	sbci	r21, 0xF9	; 249
    5178:	8c 81       	ldd	r24, Y+4	; 0x04
    517a:	9d 81       	ldd	r25, Y+5	; 0x05
    517c:	9c 01       	movw	r18, r24
    517e:	2e 5f       	subi	r18, 0xFE	; 254
    5180:	3f 4f       	sbci	r19, 0xFF	; 255
    5182:	ca 01       	movw	r24, r20
    5184:	b9 01       	movw	r22, r18
    5186:	0e 94 e0 06 	call	0xdc0	; 0xdc0 <vListInsertEnd>
    518a:	0a c0       	rjmp	.+20     	; 0x51a0 <xTaskGenericNotifyFromISR+0x1aa>
				}
				else
				{
					/* The delayed and ready lists cannot be accessed, so hold
					this task pending until the scheduler is resumed. */
					vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
    518c:	8c 81       	ldd	r24, Y+4	; 0x04
    518e:	9d 81       	ldd	r25, Y+5	; 0x05
    5190:	9c 01       	movw	r18, r24
    5192:	24 5f       	subi	r18, 0xF4	; 244
    5194:	3f 4f       	sbci	r19, 0xFF	; 255
    5196:	83 e9       	ldi	r24, 0x93	; 147
    5198:	96 e0       	ldi	r25, 0x06	; 6
    519a:	b9 01       	movw	r22, r18
    519c:	0e 94 e0 06 	call	0xdc0	; 0xdc0 <vListInsertEnd>
				}

				if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
    51a0:	ec 81       	ldd	r30, Y+4	; 0x04
    51a2:	fd 81       	ldd	r31, Y+5	; 0x05
    51a4:	96 89       	ldd	r25, Z+22	; 0x16
    51a6:	e0 91 48 06 	lds	r30, 0x0648
    51aa:	f0 91 49 06 	lds	r31, 0x0649
    51ae:	86 89       	ldd	r24, Z+22	; 0x16
    51b0:	89 17       	cp	r24, r25
    51b2:	58 f4       	brcc	.+22     	; 0x51ca <xTaskGenericNotifyFromISR+0x1d4>
				{
					/* The notified task has a priority above the currently
					executing task so a yield is required. */
					if( pxHigherPriorityTaskWoken != NULL )
    51b4:	8f 85       	ldd	r24, Y+15	; 0x0f
    51b6:	98 89       	ldd	r25, Y+16	; 0x10
    51b8:	00 97       	sbiw	r24, 0x00	; 0
    51ba:	21 f0       	breq	.+8      	; 0x51c4 <xTaskGenericNotifyFromISR+0x1ce>
					{
						*pxHigherPriorityTaskWoken = pdTRUE;
    51bc:	ef 85       	ldd	r30, Y+15	; 0x0f
    51be:	f8 89       	ldd	r31, Y+16	; 0x10
    51c0:	81 e0       	ldi	r24, 0x01	; 1
    51c2:	80 83       	st	Z, r24
					}

					/* Mark that a yield is pending in case the user is not
					using the "xHigherPriorityTaskWoken" parameter to an ISR
					safe FreeRTOS function. */
					xYieldPending = pdTRUE;
    51c4:	81 e0       	ldi	r24, 0x01	; 1
    51c6:	80 93 51 06 	sts	0x0651, r24
				}
			}
		}
		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

		return xReturn;
    51ca:	8a 81       	ldd	r24, Y+2	; 0x02
	}
    51cc:	62 96       	adiw	r28, 0x12	; 18
    51ce:	0f b6       	in	r0, 0x3f	; 63
    51d0:	f8 94       	cli
    51d2:	de bf       	out	0x3e, r29	; 62
    51d4:	0f be       	out	0x3f, r0	; 63
    51d6:	cd bf       	out	0x3d, r28	; 61
    51d8:	cf 91       	pop	r28
    51da:	df 91       	pop	r29
    51dc:	1f 91       	pop	r17
    51de:	0f 91       	pop	r16
    51e0:	ff 90       	pop	r15
    51e2:	ef 90       	pop	r14
    51e4:	08 95       	ret

000051e6 <vTaskNotifyGiveFromISR>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	void vTaskNotifyGiveFromISR( TaskHandle_t xTaskToNotify, BaseType_t *pxHigherPriorityTaskWoken )
	{
    51e6:	df 93       	push	r29
    51e8:	cf 93       	push	r28
    51ea:	cd b7       	in	r28, 0x3d	; 61
    51ec:	de b7       	in	r29, 0x3e	; 62
    51ee:	28 97       	sbiw	r28, 0x08	; 8
    51f0:	0f b6       	in	r0, 0x3f	; 63
    51f2:	f8 94       	cli
    51f4:	de bf       	out	0x3e, r29	; 62
    51f6:	0f be       	out	0x3f, r0	; 63
    51f8:	cd bf       	out	0x3d, r28	; 61
    51fa:	9e 83       	std	Y+6, r25	; 0x06
    51fc:	8d 83       	std	Y+5, r24	; 0x05
    51fe:	78 87       	std	Y+8, r23	; 0x08
    5200:	6f 83       	std	Y+7, r22	; 0x07
		simple as possible.  More information (albeit Cortex-M specific) is
		provided on the following link:
		http://www.freertos.org/RTOS-Cortex-M3-M4.html */
		portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

		pxTCB = xTaskToNotify;
    5202:	8d 81       	ldd	r24, Y+5	; 0x05
    5204:	9e 81       	ldd	r25, Y+6	; 0x06
    5206:	9c 83       	std	Y+4, r25	; 0x04
    5208:	8b 83       	std	Y+3, r24	; 0x03

		uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    520a:	19 82       	std	Y+1, r1	; 0x01
		{
			ucOriginalNotifyState = pxTCB->ucNotifyState;
    520c:	eb 81       	ldd	r30, Y+3	; 0x03
    520e:	fc 81       	ldd	r31, Y+4	; 0x04
    5210:	81 a5       	ldd	r24, Z+41	; 0x29
    5212:	8a 83       	std	Y+2, r24	; 0x02
			pxTCB->ucNotifyState = taskNOTIFICATION_RECEIVED;
    5214:	eb 81       	ldd	r30, Y+3	; 0x03
    5216:	fc 81       	ldd	r31, Y+4	; 0x04
    5218:	82 e0       	ldi	r24, 0x02	; 2
    521a:	81 a7       	std	Z+41, r24	; 0x29

			/* 'Giving' is equivalent to incrementing a count in a counting
			semaphore. */
			( pxTCB->ulNotifiedValue )++;
    521c:	eb 81       	ldd	r30, Y+3	; 0x03
    521e:	fc 81       	ldd	r31, Y+4	; 0x04
    5220:	85 a1       	ldd	r24, Z+37	; 0x25
    5222:	96 a1       	ldd	r25, Z+38	; 0x26
    5224:	a7 a1       	ldd	r26, Z+39	; 0x27
    5226:	b0 a5       	ldd	r27, Z+40	; 0x28
    5228:	01 96       	adiw	r24, 0x01	; 1
    522a:	a1 1d       	adc	r26, r1
    522c:	b1 1d       	adc	r27, r1
    522e:	eb 81       	ldd	r30, Y+3	; 0x03
    5230:	fc 81       	ldd	r31, Y+4	; 0x04
    5232:	85 a3       	std	Z+37, r24	; 0x25
    5234:	96 a3       	std	Z+38, r25	; 0x26
    5236:	a7 a3       	std	Z+39, r26	; 0x27
    5238:	b0 a7       	std	Z+40, r27	; 0x28

			traceTASK_NOTIFY_GIVE_FROM_ISR();

			/* If the task is in the blocked state specifically to wait for a
			notification then unblock it now. */
			if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
    523a:	8a 81       	ldd	r24, Y+2	; 0x02
    523c:	81 30       	cpi	r24, 0x01	; 1
    523e:	09 f0       	breq	.+2      	; 0x5242 <vTaskNotifyGiveFromISR+0x5c>
    5240:	4f c0       	rjmp	.+158    	; 0x52e0 <vTaskNotifyGiveFromISR+0xfa>
			{
				/* The task should not have been on an event list. */
				configASSERT( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL );

				if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    5242:	80 91 58 06 	lds	r24, 0x0658
    5246:	88 23       	and	r24, r24
    5248:	61 f5       	brne	.+88     	; 0x52a2 <vTaskNotifyGiveFromISR+0xbc>
				{
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    524a:	8b 81       	ldd	r24, Y+3	; 0x03
    524c:	9c 81       	ldd	r25, Y+4	; 0x04
    524e:	02 96       	adiw	r24, 0x02	; 2
    5250:	0e 94 90 07 	call	0xf20	; 0xf20 <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
    5254:	eb 81       	ldd	r30, Y+3	; 0x03
    5256:	fc 81       	ldd	r31, Y+4	; 0x04
    5258:	96 89       	ldd	r25, Z+22	; 0x16
    525a:	80 91 4e 06 	lds	r24, 0x064E
    525e:	89 17       	cp	r24, r25
    5260:	28 f4       	brcc	.+10     	; 0x526c <vTaskNotifyGiveFromISR+0x86>
    5262:	eb 81       	ldd	r30, Y+3	; 0x03
    5264:	fc 81       	ldd	r31, Y+4	; 0x04
    5266:	86 89       	ldd	r24, Z+22	; 0x16
    5268:	80 93 4e 06 	sts	0x064E, r24
    526c:	eb 81       	ldd	r30, Y+3	; 0x03
    526e:	fc 81       	ldd	r31, Y+4	; 0x04
    5270:	86 89       	ldd	r24, Z+22	; 0x16
    5272:	28 2f       	mov	r18, r24
    5274:	30 e0       	ldi	r19, 0x00	; 0
    5276:	c9 01       	movw	r24, r18
    5278:	88 0f       	add	r24, r24
    527a:	99 1f       	adc	r25, r25
    527c:	88 0f       	add	r24, r24
    527e:	99 1f       	adc	r25, r25
    5280:	88 0f       	add	r24, r24
    5282:	99 1f       	adc	r25, r25
    5284:	82 0f       	add	r24, r18
    5286:	93 1f       	adc	r25, r19
    5288:	ac 01       	movw	r20, r24
    528a:	47 5a       	subi	r20, 0xA7	; 167
    528c:	59 4f       	sbci	r21, 0xF9	; 249
    528e:	8b 81       	ldd	r24, Y+3	; 0x03
    5290:	9c 81       	ldd	r25, Y+4	; 0x04
    5292:	9c 01       	movw	r18, r24
    5294:	2e 5f       	subi	r18, 0xFE	; 254
    5296:	3f 4f       	sbci	r19, 0xFF	; 255
    5298:	ca 01       	movw	r24, r20
    529a:	b9 01       	movw	r22, r18
    529c:	0e 94 e0 06 	call	0xdc0	; 0xdc0 <vListInsertEnd>
    52a0:	0a c0       	rjmp	.+20     	; 0x52b6 <vTaskNotifyGiveFromISR+0xd0>
				}
				else
				{
					/* The delayed and ready lists cannot be accessed, so hold
					this task pending until the scheduler is resumed. */
					vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
    52a2:	8b 81       	ldd	r24, Y+3	; 0x03
    52a4:	9c 81       	ldd	r25, Y+4	; 0x04
    52a6:	9c 01       	movw	r18, r24
    52a8:	24 5f       	subi	r18, 0xF4	; 244
    52aa:	3f 4f       	sbci	r19, 0xFF	; 255
    52ac:	83 e9       	ldi	r24, 0x93	; 147
    52ae:	96 e0       	ldi	r25, 0x06	; 6
    52b0:	b9 01       	movw	r22, r18
    52b2:	0e 94 e0 06 	call	0xdc0	; 0xdc0 <vListInsertEnd>
				}

				if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
    52b6:	eb 81       	ldd	r30, Y+3	; 0x03
    52b8:	fc 81       	ldd	r31, Y+4	; 0x04
    52ba:	96 89       	ldd	r25, Z+22	; 0x16
    52bc:	e0 91 48 06 	lds	r30, 0x0648
    52c0:	f0 91 49 06 	lds	r31, 0x0649
    52c4:	86 89       	ldd	r24, Z+22	; 0x16
    52c6:	89 17       	cp	r24, r25
    52c8:	58 f4       	brcc	.+22     	; 0x52e0 <vTaskNotifyGiveFromISR+0xfa>
				{
					/* The notified task has a priority above the currently
					executing task so a yield is required. */
					if( pxHigherPriorityTaskWoken != NULL )
    52ca:	8f 81       	ldd	r24, Y+7	; 0x07
    52cc:	98 85       	ldd	r25, Y+8	; 0x08
    52ce:	00 97       	sbiw	r24, 0x00	; 0
    52d0:	21 f0       	breq	.+8      	; 0x52da <vTaskNotifyGiveFromISR+0xf4>
					{
						*pxHigherPriorityTaskWoken = pdTRUE;
    52d2:	ef 81       	ldd	r30, Y+7	; 0x07
    52d4:	f8 85       	ldd	r31, Y+8	; 0x08
    52d6:	81 e0       	ldi	r24, 0x01	; 1
    52d8:	80 83       	st	Z, r24
					}

					/* Mark that a yield is pending in case the user is not
					using the "xHigherPriorityTaskWoken" parameter in an ISR
					safe FreeRTOS function. */
					xYieldPending = pdTRUE;
    52da:	81 e0       	ldi	r24, 0x01	; 1
    52dc:	80 93 51 06 	sts	0x0651, r24
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
	}
    52e0:	28 96       	adiw	r28, 0x08	; 8
    52e2:	0f b6       	in	r0, 0x3f	; 63
    52e4:	f8 94       	cli
    52e6:	de bf       	out	0x3e, r29	; 62
    52e8:	0f be       	out	0x3f, r0	; 63
    52ea:	cd bf       	out	0x3d, r28	; 61
    52ec:	cf 91       	pop	r28
    52ee:	df 91       	pop	r29
    52f0:	08 95       	ret

000052f2 <xTaskNotifyStateClear>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	BaseType_t xTaskNotifyStateClear( TaskHandle_t xTask )
	{
    52f2:	df 93       	push	r29
    52f4:	cf 93       	push	r28
    52f6:	cd b7       	in	r28, 0x3d	; 61
    52f8:	de b7       	in	r29, 0x3e	; 62
    52fa:	27 97       	sbiw	r28, 0x07	; 7
    52fc:	0f b6       	in	r0, 0x3f	; 63
    52fe:	f8 94       	cli
    5300:	de bf       	out	0x3e, r29	; 62
    5302:	0f be       	out	0x3f, r0	; 63
    5304:	cd bf       	out	0x3d, r28	; 61
    5306:	9d 83       	std	Y+5, r25	; 0x05
    5308:	8c 83       	std	Y+4, r24	; 0x04
	TCB_t *pxTCB;
	BaseType_t xReturn;

		/* If null is passed in here then it is the calling task that is having
		its notification state cleared. */
		pxTCB = prvGetTCBFromHandle( xTask );
    530a:	8c 81       	ldd	r24, Y+4	; 0x04
    530c:	9d 81       	ldd	r25, Y+5	; 0x05
    530e:	00 97       	sbiw	r24, 0x00	; 0
    5310:	39 f4       	brne	.+14     	; 0x5320 <xTaskNotifyStateClear+0x2e>
    5312:	80 91 48 06 	lds	r24, 0x0648
    5316:	90 91 49 06 	lds	r25, 0x0649
    531a:	9f 83       	std	Y+7, r25	; 0x07
    531c:	8e 83       	std	Y+6, r24	; 0x06
    531e:	04 c0       	rjmp	.+8      	; 0x5328 <xTaskNotifyStateClear+0x36>
    5320:	8c 81       	ldd	r24, Y+4	; 0x04
    5322:	9d 81       	ldd	r25, Y+5	; 0x05
    5324:	9f 83       	std	Y+7, r25	; 0x07
    5326:	8e 83       	std	Y+6, r24	; 0x06
    5328:	8e 81       	ldd	r24, Y+6	; 0x06
    532a:	9f 81       	ldd	r25, Y+7	; 0x07
    532c:	9b 83       	std	Y+3, r25	; 0x03
    532e:	8a 83       	std	Y+2, r24	; 0x02

		taskENTER_CRITICAL();
    5330:	0f b6       	in	r0, 0x3f	; 63
    5332:	f8 94       	cli
    5334:	0f 92       	push	r0
		{
			if( pxTCB->ucNotifyState == taskNOTIFICATION_RECEIVED )
    5336:	ea 81       	ldd	r30, Y+2	; 0x02
    5338:	fb 81       	ldd	r31, Y+3	; 0x03
    533a:	81 a5       	ldd	r24, Z+41	; 0x29
    533c:	82 30       	cpi	r24, 0x02	; 2
    533e:	31 f4       	brne	.+12     	; 0x534c <xTaskNotifyStateClear+0x5a>
			{
				pxTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
    5340:	ea 81       	ldd	r30, Y+2	; 0x02
    5342:	fb 81       	ldd	r31, Y+3	; 0x03
    5344:	11 a6       	std	Z+41, r1	; 0x29
				xReturn = pdPASS;
    5346:	81 e0       	ldi	r24, 0x01	; 1
    5348:	89 83       	std	Y+1, r24	; 0x01
    534a:	01 c0       	rjmp	.+2      	; 0x534e <xTaskNotifyStateClear+0x5c>
			}
			else
			{
				xReturn = pdFAIL;
    534c:	19 82       	std	Y+1, r1	; 0x01
			}
		}
		taskEXIT_CRITICAL();
    534e:	0f 90       	pop	r0
    5350:	0f be       	out	0x3f, r0	; 63

		return xReturn;
    5352:	89 81       	ldd	r24, Y+1	; 0x01
	}
    5354:	27 96       	adiw	r28, 0x07	; 7
    5356:	0f b6       	in	r0, 0x3f	; 63
    5358:	f8 94       	cli
    535a:	de bf       	out	0x3e, r29	; 62
    535c:	0f be       	out	0x3f, r0	; 63
    535e:	cd bf       	out	0x3d, r28	; 61
    5360:	cf 91       	pop	r28
    5362:	df 91       	pop	r29
    5364:	08 95       	ret

00005366 <prvAddCurrentTaskToDelayedList>:
	}
#endif
/*-----------------------------------------------------------*/

static void prvAddCurrentTaskToDelayedList( TickType_t xTicksToWait, const BaseType_t xCanBlockIndefinitely )
{
    5366:	df 93       	push	r29
    5368:	cf 93       	push	r28
    536a:	cd b7       	in	r28, 0x3d	; 61
    536c:	de b7       	in	r29, 0x3e	; 62
    536e:	27 97       	sbiw	r28, 0x07	; 7
    5370:	0f b6       	in	r0, 0x3f	; 63
    5372:	f8 94       	cli
    5374:	de bf       	out	0x3e, r29	; 62
    5376:	0f be       	out	0x3f, r0	; 63
    5378:	cd bf       	out	0x3d, r28	; 61
    537a:	9e 83       	std	Y+6, r25	; 0x06
    537c:	8d 83       	std	Y+5, r24	; 0x05
    537e:	6f 83       	std	Y+7, r22	; 0x07
TickType_t xTimeToWake;
const TickType_t xConstTickCount = xTickCount;
    5380:	80 91 4c 06 	lds	r24, 0x064C
    5384:	90 91 4d 06 	lds	r25, 0x064D
    5388:	9a 83       	std	Y+2, r25	; 0x02
    538a:	89 83       	std	Y+1, r24	; 0x01
	}
	#endif

	/* Remove the task from the ready list before adding it to the blocked list
	as the same list item is used for both lists. */
	if( uxListRemove( &( pxCurrentTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
    538c:	80 91 48 06 	lds	r24, 0x0648
    5390:	90 91 49 06 	lds	r25, 0x0649
    5394:	02 96       	adiw	r24, 0x02	; 2
    5396:	0e 94 90 07 	call	0xf20	; 0xf20 <uxListRemove>
		mtCOVERAGE_TEST_MARKER();
	}

	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		if( ( xTicksToWait == portMAX_DELAY ) && ( xCanBlockIndefinitely != pdFALSE ) )
    539a:	8d 81       	ldd	r24, Y+5	; 0x05
    539c:	9e 81       	ldd	r25, Y+6	; 0x06
    539e:	2f ef       	ldi	r18, 0xFF	; 255
    53a0:	8f 3f       	cpi	r24, 0xFF	; 255
    53a2:	92 07       	cpc	r25, r18
    53a4:	81 f4       	brne	.+32     	; 0x53c6 <prvAddCurrentTaskToDelayedList+0x60>
    53a6:	8f 81       	ldd	r24, Y+7	; 0x07
    53a8:	88 23       	and	r24, r24
    53aa:	69 f0       	breq	.+26     	; 0x53c6 <prvAddCurrentTaskToDelayedList+0x60>
		{
			/* Add the task to the suspended task list instead of a delayed task
			list to ensure it is not woken by a timing event.  It will block
			indefinitely. */
			vListInsertEnd( &xSuspendedTaskList, &( pxCurrentTCB->xStateListItem ) );
    53ac:	80 91 48 06 	lds	r24, 0x0648
    53b0:	90 91 49 06 	lds	r25, 0x0649
    53b4:	9c 01       	movw	r18, r24
    53b6:	2e 5f       	subi	r18, 0xFE	; 254
    53b8:	3f 4f       	sbci	r19, 0xFF	; 255
    53ba:	85 ea       	ldi	r24, 0xA5	; 165
    53bc:	96 e0       	ldi	r25, 0x06	; 6
    53be:	b9 01       	movw	r22, r18
    53c0:	0e 94 e0 06 	call	0xdc0	; 0xdc0 <vListInsertEnd>
    53c4:	43 c0       	rjmp	.+134    	; 0x544c <prvAddCurrentTaskToDelayedList+0xe6>
		else
		{
			/* Calculate the time at which the task should be woken if the event
			does not occur.  This may overflow but this doesn't matter, the
			kernel will manage it correctly. */
			xTimeToWake = xConstTickCount + xTicksToWait;
    53c6:	29 81       	ldd	r18, Y+1	; 0x01
    53c8:	3a 81       	ldd	r19, Y+2	; 0x02
    53ca:	8d 81       	ldd	r24, Y+5	; 0x05
    53cc:	9e 81       	ldd	r25, Y+6	; 0x06
    53ce:	82 0f       	add	r24, r18
    53d0:	93 1f       	adc	r25, r19
    53d2:	9c 83       	std	Y+4, r25	; 0x04
    53d4:	8b 83       	std	Y+3, r24	; 0x03

			/* The list item will be inserted in wake time order. */
			listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xStateListItem ), xTimeToWake );
    53d6:	e0 91 48 06 	lds	r30, 0x0648
    53da:	f0 91 49 06 	lds	r31, 0x0649
    53de:	8b 81       	ldd	r24, Y+3	; 0x03
    53e0:	9c 81       	ldd	r25, Y+4	; 0x04
    53e2:	93 83       	std	Z+3, r25	; 0x03
    53e4:	82 83       	std	Z+2, r24	; 0x02

			if( xTimeToWake < xConstTickCount )
    53e6:	2b 81       	ldd	r18, Y+3	; 0x03
    53e8:	3c 81       	ldd	r19, Y+4	; 0x04
    53ea:	89 81       	ldd	r24, Y+1	; 0x01
    53ec:	9a 81       	ldd	r25, Y+2	; 0x02
    53ee:	28 17       	cp	r18, r24
    53f0:	39 07       	cpc	r19, r25
    53f2:	70 f4       	brcc	.+28     	; 0x5410 <prvAddCurrentTaskToDelayedList+0xaa>
			{
				/* Wake time has overflowed.  Place this item in the overflow
				list. */
				vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
    53f4:	80 91 91 06 	lds	r24, 0x0691
    53f8:	90 91 92 06 	lds	r25, 0x0692
    53fc:	20 91 48 06 	lds	r18, 0x0648
    5400:	30 91 49 06 	lds	r19, 0x0649
    5404:	2e 5f       	subi	r18, 0xFE	; 254
    5406:	3f 4f       	sbci	r19, 0xFF	; 255
    5408:	b9 01       	movw	r22, r18
    540a:	0e 94 24 07 	call	0xe48	; 0xe48 <vListInsert>
    540e:	1e c0       	rjmp	.+60     	; 0x544c <prvAddCurrentTaskToDelayedList+0xe6>
			}
			else
			{
				/* The wake time has not overflowed, so the current block list
				is used. */
				vListInsert( pxDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
    5410:	40 91 8f 06 	lds	r20, 0x068F
    5414:	50 91 90 06 	lds	r21, 0x0690
    5418:	80 91 48 06 	lds	r24, 0x0648
    541c:	90 91 49 06 	lds	r25, 0x0649
    5420:	9c 01       	movw	r18, r24
    5422:	2e 5f       	subi	r18, 0xFE	; 254
    5424:	3f 4f       	sbci	r19, 0xFF	; 255
    5426:	ca 01       	movw	r24, r20
    5428:	b9 01       	movw	r22, r18
    542a:	0e 94 24 07 	call	0xe48	; 0xe48 <vListInsert>

				/* If the task entering the blocked state was placed at the
				head of the list of blocked tasks then xNextTaskUnblockTime
				needs to be updated too. */
				if( xTimeToWake < xNextTaskUnblockTime )
    542e:	20 91 54 06 	lds	r18, 0x0654
    5432:	30 91 55 06 	lds	r19, 0x0655
    5436:	8b 81       	ldd	r24, Y+3	; 0x03
    5438:	9c 81       	ldd	r25, Y+4	; 0x04
    543a:	82 17       	cp	r24, r18
    543c:	93 07       	cpc	r25, r19
    543e:	30 f4       	brcc	.+12     	; 0x544c <prvAddCurrentTaskToDelayedList+0xe6>
				{
					xNextTaskUnblockTime = xTimeToWake;
    5440:	8b 81       	ldd	r24, Y+3	; 0x03
    5442:	9c 81       	ldd	r25, Y+4	; 0x04
    5444:	90 93 55 06 	sts	0x0655, r25
    5448:	80 93 54 06 	sts	0x0654, r24

		/* Avoid compiler warning when INCLUDE_vTaskSuspend is not 1. */
		( void ) xCanBlockIndefinitely;
	}
	#endif /* INCLUDE_vTaskSuspend */
}
    544c:	27 96       	adiw	r28, 0x07	; 7
    544e:	0f b6       	in	r0, 0x3f	; 63
    5450:	f8 94       	cli
    5452:	de bf       	out	0x3e, r29	; 62
    5454:	0f be       	out	0x3f, r0	; 63
    5456:	cd bf       	out	0x3d, r28	; 61
    5458:	cf 91       	pop	r28
    545a:	df 91       	pop	r29
    545c:	08 95       	ret

0000545e <memcpy>:
    545e:	fb 01       	movw	r30, r22
    5460:	dc 01       	movw	r26, r24
    5462:	02 c0       	rjmp	.+4      	; 0x5468 <memcpy+0xa>
    5464:	01 90       	ld	r0, Z+
    5466:	0d 92       	st	X+, r0
    5468:	41 50       	subi	r20, 0x01	; 1
    546a:	50 40       	sbci	r21, 0x00	; 0
    546c:	d8 f7       	brcc	.-10     	; 0x5464 <memcpy+0x6>
    546e:	08 95       	ret

00005470 <memset>:
    5470:	dc 01       	movw	r26, r24
    5472:	01 c0       	rjmp	.+2      	; 0x5476 <memset+0x6>
    5474:	6d 93       	st	X+, r22
    5476:	41 50       	subi	r20, 0x01	; 1
    5478:	50 40       	sbci	r21, 0x00	; 0
    547a:	e0 f7       	brcc	.-8      	; 0x5474 <memset+0x4>
    547c:	08 95       	ret

0000547e <_exit>:
    547e:	f8 94       	cli

00005480 <__stop_program>:
    5480:	ff cf       	rjmp	.-2      	; 0x5480 <__stop_program>
